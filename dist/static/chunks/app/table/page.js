/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/table/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fnekhavhambemartin%2FDesktop%2Finsnip%20copy%2Fapp%2Ftable%2Fpage.tsx&server=false!":
/*!***********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fnekhavhambemartin%2FDesktop%2Finsnip%20copy%2Fapp%2Ftable%2Fpage.tsx&server=false! ***!
  \***********************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/table/page.tsx */ \"(app-pages-browser)/./app/table/page.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lMkZVc2VycyUyRm5la2hhdmhhbWJlbWFydGluJTJGRGVza3RvcCUyRmluc25pcCUyMGNvcHklMkZhcHAlMkZ0YWJsZSUyRnBhZ2UudHN4JnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz81NGI4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL25la2hhdmhhbWJlbWFydGluL0Rlc2t0b3AvaW5zbmlwIGNvcHkvYXBwL3RhYmxlL3BhZ2UudHN4XCIpIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fnekhavhambemartin%2FDesktop%2Finsnip%20copy%2Fapp%2Ftable%2Fpage.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBRTlDLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyx5QkFBeUJSLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUSxzQkFBc0JULE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJUywyQkFBMkJWLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVSxrQkFBa0JYLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSx1QkFBdUJiLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYSxtQkFBbUJkLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJYyx3QkFBd0JmLE9BQU9nQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhO1lBQ2xDLElBQUlBLGtCQUFrQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVO2dCQUMv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LE9BQU8sUUFBUTtvQkFDckMsSUFBSXVFLGdCQUFnQnZHLHlCQUF5QmI7b0JBQzdDLElBQUlzTSxPQUFPM0ssT0FBTzJLLElBQUksQ0FBQ3pKLE9BQU9pSyxNQUFNLENBQUMsU0FBVUMsQ0FBQzt3QkFDOUMsT0FBT0EsTUFBTTtvQkFDZjtvQkFDQSxJQUFJQyxnQkFBZ0JWLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxvQkFBb0JpTyxLQUFLVyxJQUFJLENBQUMsYUFBYSxXQUFXO29CQUU1RixJQUFJLENBQUNWLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxFQUFFO3dCQUN6RCxJQUFJRSxlQUFlWixLQUFLak8sTUFBTSxHQUFHLElBQUksTUFBTWlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7d0JBRTdFaFAsTUFBTSx1RUFBdUUsd0JBQXdCLDBCQUEwQixzRUFBc0Usd0JBQXdCLHFDQUFxQytPLGVBQWU1RixlQUFlOEYsY0FBYzlGO3dCQUU5U21GLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxHQUFHO29CQUN6RDtnQkFDRjtnQkFFQSxJQUFJaE4sU0FBU25ELHFCQUFxQjtvQkFDaEN1UCxzQkFBc0J6RjtnQkFDeEIsT0FBTztvQkFDTG1GLGtCQUFrQm5GO2dCQUNwQjtnQkFFQSxPQUFPQTtZQUNUO1FBQ0YsRUFBRSwrREFBK0Q7UUFFakUsSUFBSXdHLFNBQVNYO1FBRWJZLGdCQUFnQixHQUFHdlE7UUFDbkJ1USxjQUFjLEdBQUdEO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/ZmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInVuZGVmaW5lZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJhc3NpZ24iLCJPYmplY3QiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiaGFzT3duUHJvcGVydHkiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYkMSIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImRpZFdhcm5BYm91dEtleVNwcmVhZCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImpvaW4iLCJhZnRlckV4YW1wbGUiLCJqc3hERVYiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDhMQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/table/styles.css":
/*!******************************!*\
  !*** ./app/table/styles.css ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"249f4dadfeac\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC90YWJsZS9zdHlsZXMuY3NzIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxjQUFjO0FBQzdCLElBQUksSUFBVSxJQUFJLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvdGFibGUvc3R5bGVzLmNzcz80MGMyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiMjQ5ZjRkYWRmZWFjXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/table/styles.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/table/page.tsx":
/*!****************************!*\
  !*** ./app/table/page.tsx ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ColumnGrouping; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./styles.css */ \"(app-pages-browser)/./app/table/styles.css\");\n/* harmony import */ var react_data_grid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-data-grid */ \"(app-pages-browser)/./node_modules/react-data-grid/lib/bundle.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n// import { renderCoordinates } from \"./renderers\";\n// import type { Props } from './types';\nlet lists = [\n    {\n        id: \"15783\",\n        name: \"<a href='pt_main.phtml?.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&pageId=12696&objDefId=10045&.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&id=15783'>15783--Majuba UCG Site-Hydrogeological Services</a>\",\n        value: \"51 055.40\",\n        billed: \"0\",\n        forecast: \"51 055.40\",\n        cashflow: \"[]\",\n        cashflow_monthly: \"{}\",\n        row: 0\n    },\n    {\n        id: \"15781\",\n        name: \"<a href='pt_main.phtml?.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&pageId=12696&objDefId=10045&.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&id=15781'>15781--MCWAP ECO</a>\",\n        value: \"454 489.92\",\n        billed: \"0\",\n        forecast: \"454 489.92\",\n        cashflow: \"[]\",\n        cashflow_monthly: \"{}\",\n        row: 1\n    },\n    {\n        id: \"15779\",\n        name: \"<a href='pt_main.phtml?.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&pageId=12696&objDefId=10045&.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&id=15779'>15779--Witkop Pietersburg line 3 132kv powerline-ECO-Task Order</a>\",\n        value: \"542 716.20\",\n        billed: \"0\",\n        forecast: \"542 716.20\",\n        cashflow: \"[]\",\n        cashflow_monthly: \"{}\",\n        row: 2\n    },\n    {\n        id: \"15770\",\n        name: \"<a href='pt_main.phtml?.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&pageId=12696&objDefId=10045&.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&id=15770'>15770--CMJAH Fire Remedial Works</a>\",\n        value: \"1 251 232.12\",\n        billed: \"0\",\n        forecast: \"1 251 232.12\",\n        cashflow: \"[]\",\n        cashflow_monthly: \"{}\",\n        row: 3\n    },\n    {\n        id: \"11364\",\n        name: \"<a href='pt_main.phtml?.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&pageId=12696&objDefId=10045&.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&id=11364'>11364--Tshebela  Rampheri Unin 132 kv Power line</a>\",\n        value: \"376 965.20\",\n        billed: \"0\",\n        forecast: \"376 965.20\",\n        cashflow: \"[]\",\n        cashflow_monthly: \"{}\",\n        row: 4\n    },\n    {\n        id: \"11365\",\n        name: \"<a href='pt_main.phtml?.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&pageId=12696&objDefId=10045&.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&id=11365'>11365--TASEZ PHASE 2 CDC/606/23</a>\",\n        value: \"316 375.00\",\n        billed: \"0\",\n        forecast: \"316 375.00\",\n        cashflow: \"[]\",\n        cashflow_monthly: \"{}\",\n        row: 5\n    },\n    {\n        id: \"11366\",\n        name: \"<a href='pt_main.phtml?.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&pageId=12696&objDefId=10045&.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&id=11366'>11366--Mhinga Substation 4503403637</a>\",\n        value: \"526 245.40\",\n        billed: \"0\",\n        forecast: \"526 245.40\",\n        cashflow: \"[]\",\n        cashflow_monthly: \"{}\",\n        row: 6\n    },\n    {\n        id: \"11367\",\n        name: \"<a href='pt_main.phtml?.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&pageId=12696&objDefId=10045&.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&id=11367'>11367--Majuba UCG</a>\",\n        value: \"2 561 280.00\",\n        billed: \"0\",\n        forecast: \"2 561 280.00\",\n        cashflow: \"[]\",\n        cashflow_monthly: \"{}\",\n        row: 7\n    },\n    {\n        id: \"11368\",\n        name: \"<a href='pt_main.phtml?.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&pageId=12696&objDefId=10045&.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&id=11368'>11368--Leseding Substation  0015TX</a>\",\n        value: \"443 330.00\",\n        billed: \"0\",\n        forecast: \"443 330.00\",\n        cashflow: \"[]\",\n        cashflow_monthly: \"{}\",\n        row: 8\n    },\n    {\n        id: \"11369\",\n        name: \"<a href='pt_main.phtml?.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&pageId=12696&objDefId=10045&.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&id=11369'>11369--Alex TRA 1081k</a>\",\n        value: \"136 610.00\",\n        billed: \"0\",\n        forecast: \"116 610.00\",\n        cashflow: \"[]\",\n        cashflow_monthly: '{\"Month Ended March 2024\":{\"amount\":20000,\"key\":\"1431\"}}',\n        row: 9\n    },\n    {\n        id: \"11538\",\n        name: \"<a href='pt_main.phtml?.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&pageId=12696&objDefId=10045&.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&id=11538'>11538--Non-billable</a>\",\n        value: \"57 750.00\",\n        billed: \"52 750.00\",\n        forecast: \"5 000.00\",\n        cashflow: '[{\"amount\":2750,\"date\":\"07/31/2024\"},{\"amount\":50000,\"date\":\"07/31/2024\"}]',\n        cashflow_monthly: '{\"Month Ended December 2024\":{\"amount\":5000,\"key\":\"1432\"},\"Month Ended July 2024\":{\"amount\":0,\"key\":\"1433\"},\"Month Ended August 2024\":{\"amount\":0,\"key\":\"1434\"},\"Month Ended September 2024\":{\"amount\":0,\"key\":\"1435\"},\"Month Ended October 2024\":{\"amount\":0,\"key\":\"1436\"},\"Month Ended November 2024\":{\"amount\":0,\"key\":\"1437\"},\"Month Ended March 2024\":{\"amount\":15000,\"key\":\"1421\"},\"Month Ended April 2024\":{\"amount\":20000,\"key\":\"1422\"},\"Month Ended May 2024\":{\"amount\":6787,\"key\":\"1423\"},\"Month Ended June 2024\":{\"amount\":5963,\"key\":\"1424\"}}',\n        row: 10\n    },\n    {\n        id: \"12045\",\n        name: \"<a href='pt_main.phtml?.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&pageId=12696&objDefId=10045&.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&id=12045'>12045--Uchoba Task Order -Ecological Walk down</a>\",\n        value: \"118 983.50\",\n        billed: \"0\",\n        forecast: \"118 983.50\",\n        cashflow: \"[]\",\n        cashflow_monthly: \"{}\",\n        row: 11\n    },\n    {\n        id: \"12051\",\n        name: \"<a href='pt_main.phtml?.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&pageId=12696&objDefId=10045&.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&id=12051'>12051--Uchoba Task Order - Heritage Walkdown</a>\",\n        value: \"164 309.50\",\n        billed: \"0\",\n        forecast: \"164 309.50\",\n        cashflow: \"[]\",\n        cashflow_monthly: \"{}\",\n        row: 12\n    },\n    {\n        id: \"12064\",\n        name: \"<a href='pt_main.phtml?.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&pageId=12696&objDefId=10045&.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&id=12064'>12064--Entokozweni Tekwane North 132KVS Power Line - Heritage Walkthrought</a>\",\n        value: \"94 646.80\",\n        billed: \"0\",\n        forecast: \"94 646.80\",\n        cashflow: \"[]\",\n        cashflow_monthly: \"{}\",\n        row: 13\n    },\n    {\n        id: \"12065\",\n        name: \"<a href='pt_main.phtml?.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&pageId=12696&objDefId=10045&.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&id=12065'>12065--Entokozweni Tekwane North 132KVS Power Line - Ecological Walkthrought</a>\",\n        value: \"104 306.80\",\n        billed: \"0\",\n        forecast: \"104 306.80\",\n        cashflow: \"[]\",\n        cashflow_monthly: \"{}\",\n        row: 14\n    },\n    {\n        id: \"12074\",\n        name: \"<a href='pt_main.phtml?.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&pageId=12696&objDefId=10045&.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&id=12074'>12074--2319H – ARIES UPINGTON 400KV</a>\",\n        value: \"4 407 800.00\",\n        billed: \"0\",\n        forecast: \"3 857 800.00\",\n        cashflow: \"[]\",\n        cashflow_monthly: '{\"Month Ended August 2024\":{\"amount\":500000,\"key\":\"1425\"},\"Month Ended March 2024\":{\"amount\":50000,\"key\":\"1426\"},\"Month Ended April 2024\":{\"amount\":0,\"key\":\"1427\"},\"Month Ended May 2024\":{\"amount\":0,\"key\":\"1428\"},\"Month Ended June 2024\":{\"amount\":0,\"key\":\"1429\"},\"Month Ended July 2024\":{\"amount\":0,\"key\":\"1430\"}}',\n        row: 15\n    },\n    {\n        id: \"12097\",\n        name: \"<a href='pt_main.phtml?.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&pageId=12696&objDefId=10045&.sess=u-Fjayk8b90-KP-K04W2B6KS3T4pbrvwD94-rVAVPyj-ytOFtgTB8d0-&.op=3801&id=12097'>12097--GEMSBOK KWAMHLANGA 132KV POWERLINE – ECOLOGICAL WALKTHROUGH</a>\",\n        value: \"53 675.00\",\n        billed: \"0\",\n        forecast: \"53 675.00\",\n        cashflow: \"[]\",\n        cashflow_monthly: \"{}\",\n        row: 16\n    }\n];\nfunction aggregateMonthlyTotals(data) {\n    // Object to store the sum of amounts for each month\n    const monthlyTotals = {};\n    data.forEach((entry)=>{\n        const amount = entry.amount;\n        const dateStr = entry.date;\n        // Parse the date string into a Date object\n        const dateObj = new Date(dateStr);\n        // Extract year and month (0-based month)\n        const year = dateObj.getFullYear();\n        const month = dateObj.getMonth(); // 0 for January, 11 for December\n        // Format the key as \"YYYY-MM\" to group by month and year\n        const yearMonth = \"\".concat(year, \"-\").concat(String(month + 1).padStart(2, \"0\"));\n        // Add the amount to the corresponding month\n        if (!monthlyTotals[yearMonth]) {\n            monthlyTotals[yearMonth] = 0;\n        }\n        monthlyTotals[yearMonth] += amount;\n    });\n    // Convert the result to the desired format\n    const result = {};\n    Object.keys(monthlyTotals).forEach((yearMonth)=>{\n        const [year, month] = yearMonth.split(\"-\");\n        // Create a date object for the last day of the month\n        const endDate = new Date(Number(year), Number(month), 0); // 0 is the last day of the previous month\n        // Format the date to \"Month Ended Month YYYY\"\n        const formattedDate = \"Month Ended \".concat(formatDateToCustomFormat(new Date(Number(year), Number(month) - 1)));\n        result[formattedDate] = monthlyTotals[yearMonth];\n    });\n    return result;\n}\nlists = lists.map((el)=>{\n    let new_el = el;\n    new_el.cashflow_monthly = JSON.parse(new_el.cashflow_monthly);\n    new_el.cashflow = aggregateMonthlyTotals(JSON.parse(new_el.cashflow));\n    return new_el;\n});\nconsole.log(\"updated el\", lists);\nfunction formatDateToCustomFormat(date) {\n    const options = {\n        month: \"long\",\n        year: \"numeric\"\n    };\n    return new Intl.DateTimeFormat(\"en-GB\", options).format(date);\n}\nfunction getFinancialYearPeriods() {\n    const today = new Date();\n    const year = today.getFullYear();\n    // Financial year starts on March 1st of the current year or previous year\n    const financialYearStart = new Date(year, 2, 1); // March 1st of the current year\n    if (today < financialYearStart) {\n        // If today is before March 1st, the financial year starts last year\n        financialYearStart.setFullYear(year - 1);\n    }\n    // Calculate the start and end dates for the current financial year\n    const financialYearEnd = new Date(financialYearStart);\n    financialYearEnd.setFullYear(financialYearStart.getFullYear() + 1);\n    financialYearEnd.setMonth(1); // February\n    financialYearEnd.setDate(29); // To ensure it's a leap year if necessary\n    // Periods for the current financial year\n    const currentYearPeriods = [];\n    let periodStart = new Date(financialYearStart);\n    for(let i = 0; i < 24; i++){\n        // Get the end of the month\n        const endOfMonth = new Date(periodStart.getFullYear(), periodStart.getMonth() + 1, 0);\n        // Format for \"Month Ended September 2024\"\n        const monthEnded = \"Month Ended \".concat(formatDateToCustomFormat(endOfMonth));\n        currentYearPeriods.push({\n            name: monthEnded,\n            children: [\n                {\n                    key: \"2\" + i,\n                    name: \"Claimed\",\n                    width: \"190px\",\n                    renderCell (props) {\n                        if (props.row.cashflow[props.column.parent.name]) {\n                            let amount = Number(props.row.cashflow[props.column.parent.name]) //* (100/115)\n                            ;\n                            return new Intl.NumberFormat(\"en-US\", {\n                                minimumFractionDigits: 2,\n                                maximumFractionDigits: 2,\n                                useGrouping: true\n                            }).format(amount).replace(/,/g, \" \");\n                        }\n                        return \"0.00\";\n                    }\n                },\n                {\n                    key: \"3\" + i,\n                    name: \"Vat\",\n                    width: \"150px\",\n                    renderCell (props) {\n                        if (props.row.cashflow[props.column.parent.name]) {\n                            let amount = Number(props.row.cashflow[props.column.parent.name]) * (15 / 100);\n                            return new Intl.NumberFormat(\"en-US\", {\n                                minimumFractionDigits: 2,\n                                maximumFractionDigits: 2,\n                                useGrouping: true\n                            }).format(amount).replace(/,/g, \" \");\n                        }\n                        return \"0.00\";\n                    }\n                },\n                {\n                    key: \"4\" + i,\n                    name: \"Total Claimed\",\n                    renderCell (props) {\n                        if (props.row.cashflow[props.column.parent.name]) {\n                            let amount = Number(props.row.cashflow[props.column.parent.name]) * (115 / 100);\n                            return new Intl.NumberFormat(\"en-US\", {\n                                minimumFractionDigits: 2,\n                                maximumFractionDigits: 2,\n                                useGrouping: true\n                            }).format(amount).replace(/,/g, \" \");\n                        }\n                        return \"0.00\";\n                    }\n                },\n                {\n                    key: monthEnded,\n                    name: \"Budgted\",\n                    width: \"150px\",\n                    renderEditCell: react_data_grid__WEBPACK_IMPORTED_MODULE_3__.textEditor,\n                    renderCell (props) {\n                        let amount = 0;\n                        if (props.row[props.column.parent.name]) {\n                            amount = Number(props.row[props.column.parent.name]);\n                        } else if (props.row.cashflow_monthly[props.column.parent.name]) {\n                            amount = Number(props.row.cashflow_monthly[props.column.parent.name].amount) * (100 / 100);\n                        }\n                        return new Intl.NumberFormat(\"en-US\", {\n                            minimumFractionDigits: 2,\n                            maximumFractionDigits: 2,\n                            useGrouping: true\n                        }).format(amount).replace(/,/g, \" \");\n                    }\n                },\n                {\n                    key: \"6\" + i,\n                    name: \"Vat\",\n                    width: \"150px\",\n                    renderCell (props) {\n                        let amount = 0;\n                        if (props.row[props.column.parent.name]) {\n                            amount = props.row[props.column.parent.name] * (15 / 100);\n                        } else if (props.row.cashflow_monthly[props.column.parent.name]) {\n                            amount = Number(props.row.cashflow_monthly[props.column.parent.name].amount) * (15 / 100);\n                        }\n                        return new Intl.NumberFormat(\"en-US\", {\n                            minimumFractionDigits: 2,\n                            maximumFractionDigits: 2,\n                            useGrouping: true\n                        }).format(amount).replace(/,/g, \" \");\n                    }\n                },\n                {\n                    key: \"7\" + i,\n                    name: \"Total Budgted\",\n                    width: \"150px\",\n                    renderCell (props) {\n                        let amount = 0;\n                        if (props.row[props.column.parent.name]) {\n                            amount = props.row[props.column.parent.name] * (115 / 100);\n                        } else if (props.row.cashflow_monthly[props.column.parent.name]) {\n                            amount = Number(props.row.cashflow_monthly[props.column.parent.name].amount) * (115 / 100);\n                        }\n                        return new Intl.NumberFormat(\"en-US\", {\n                            minimumFractionDigits: 2,\n                            maximumFractionDigits: 2,\n                            useGrouping: true\n                        }).format(amount).replace(/,/g, \" \");\n                    }\n                },\n                {\n                    key: \"8\" + i,\n                    name: \"Over/Under Billed\",\n                    renderCell (props) {\n                        let totoal_budget = 0;\n                        if (props.row[props.column.parent.name]) {\n                            totoal_budget = props.row[props.column.parent.name] * (115 / 100);\n                        } else if (props.row.cashflow_monthly[props.column.parent.name]) {\n                            totoal_budget = Number(props.row.cashflow_monthly[props.column.parent.name].amount) * (115 / 100);\n                        }\n                        let actual = 0;\n                        if (props.row.cashflow[props.column.parent.name]) {\n                            actual = Number(props.row.cashflow[props.column.parent.name]) * (115 / 100);\n                        }\n                        let diff = actual - totoal_budget;\n                        return new Intl.NumberFormat(\"en-US\", {\n                            minimumFractionDigits: 2,\n                            maximumFractionDigits: 2,\n                            useGrouping: true\n                        }).format(diff).replace(/,/g, \" \");\n                    }\n                }\n            ],\n            key: \"9\" + i\n        });\n        // Move to the next month\n        periodStart.setMonth(periodStart.getMonth() + 1);\n    }\n    return currentYearPeriods;\n}\nconsole.log(getFinancialYearPeriods());\nlet res = getFinancialYearPeriods();\nconst columns = [\n    {\n        name: \"Project Billing Projections\",\n        children: [\n            {\n                key: \"1\",\n                name: \"Task Order\",\n                frozen: true,\n                width: \"200px\",\n                renderCell (props) {\n                    return props.row[\"name\"];\n                }\n            },\n            {\n                key: \"3\",\n                name: \"Value\",\n                width: \"140px\",\n                renderCell (props) {\n                    return props.row[\"value\"];\n                }\n            },\n            {\n                key: \"4\",\n                name: \"Claimed Excl\",\n                width: \"140px\",\n                renderCell (props) {\n                    let num = Number(props.row[\"billed\"].replace(/\\s+/g, \"\")) * (100 / 100);\n                    return new Intl.NumberFormat(\"en-US\", {\n                        minimumFractionDigits: 2,\n                        maximumFractionDigits: 2,\n                        useGrouping: true\n                    }).format(num).replace(/,/g, \" \");\n                }\n            },\n            {\n                key: \"5\",\n                name: \"Vat\",\n                width: \"150px\",\n                renderCell (props) {\n                    let num = (Number(props.row[\"billed\"].replace(/\\s+/g, \"\")) * (15 / 100)).toFixed(2);\n                    return new Intl.NumberFormat(\"en-US\", {\n                        minimumFractionDigits: 2,\n                        maximumFractionDigits: 2,\n                        useGrouping: true\n                    }).format(num).replace(/,/g, \" \");\n                }\n            },\n            {\n                key: \"6\",\n                name: \"Total Claimed\",\n                width: \"150px\",\n                renderCell (props) {\n                    let num = (Number(props.row[\"billed\"].replace(/\\s+/g, \"\")) * (115 / 100)).toFixed(2);\n                    return new Intl.NumberFormat(\"en-US\", {\n                        minimumFractionDigits: 2,\n                        maximumFractionDigits: 2,\n                        useGrouping: true\n                    }).format(num).replace(/,/g, \" \");\n                }\n            },\n            {\n                key: \"forecast\",\n                width: \"150px\",\n                name: \"Budget Remaining\",\n                renderEditCell: react_data_grid__WEBPACK_IMPORTED_MODULE_3__.textEditor\n            }\n        ]\n    },\n    {\n        key: \"8\",\n        name: \" \"\n    },\n    ...res\n];\nconst rows = lists;\nconsole.log(rows);\nfunction rowKeyGetter(row) {\n    return row.id;\n}\nfunction ColumnGrouping(param) {\n    let {} = param;\n    _s();\n    const [rowss, setRowss] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(rows);\n    const [selectedRows, setSelectedRows] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(()=>new Set());\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_data_grid__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n        style: {\n            height: \"100vh\"\n        },\n        //   rowKeyGetter={rowKeyGetter}\n        columns: columns,\n        rows: rowss,\n        onRowsChange: setRowss,\n        onSelectedRowsChange: setSelectedRows,\n        topSummaryRows: [\n            0\n        ],\n        bottomSummaryRows: [\n            8\n        ],\n        className: \"fill-grid\",\n        // direction={direction}\n        selectedRows: selectedRows,\n        defaultColumnOptions: {\n        }\n    }, void 0, false, {\n        fileName: \"/Users/nekhavhambemartin/Desktop/insnip copy/app/table/page.tsx\",\n        lineNumber: 495,\n        columnNumber: 5\n    }, this);\n}\n_s(ColumnGrouping, \"KSIjp0A/1r3QfYwMvCXk16AoVi8=\");\n_c = ColumnGrouping;\nvar _c;\n$RefreshReg$(_c, \"ColumnGrouping\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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eEIsTUFBTSxDQUFDaUMsS0FBS1IsT0FBTyxDQUFDLE1BQU07Z0JBQ2pDO1lBQ0o7WUFDQTtnQkFDRVYsS0FBSztnQkFDTEMsT0FBTztnQkFDUDFELE1BQU07Z0JBQ05vRSxnQkFBZ0J6RSx1REFBVUE7WUFJNUI7U0FDRDtJQUNIO0lBQ0E7UUFBRThELEtBQUs7UUFBS3pELE1BQU07SUFBSTtPQUNuQndFO0NBQ0o7QUFFRCxNQUFNSyxPQUFPL0U7QUFDYnVDLFFBQVFDLEdBQUcsQ0FBQ3VDO0FBRVosU0FBU0MsYUFBYXhFLEdBQU87SUFDM0IsT0FBT0EsSUFBSVAsRUFBRTtBQUNmO0FBRWUsU0FBU2dGLGVBQWUsS0FBSTtRQUFKLEVBQUksR0FBSjs7SUFDbkMsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdwRiwrQ0FBUUEsQ0FBQ2dGO0lBQ25DLE1BQU0sQ0FBQ0ssY0FBY0MsZ0JBQWdCLEdBQUd0RiwrQ0FBUUEsQ0FBQyxJQUEyQixJQUFJdUY7SUFDbEYscUJBQ0UsOERBQUMxRix1REFBUUE7UUFDUDJGLE9BQU87WUFBRUMsUUFBUTtRQUFRO1FBQzNCLGdDQUFnQztRQUM5QmIsU0FBU0E7UUFDVEksTUFBTUc7UUFDTk8sY0FBY047UUFDZE8sc0JBQXNCTDtRQUN0Qk0sZ0JBQWdCO1lBQUM7U0FBRTtRQUNuQkMsbUJBQW1CO1lBQUM7U0FBRTtRQUN0QkMsV0FBVTtRQUNWLHdCQUF3QjtRQUN4QlQsY0FBY0E7UUFDZFUsc0JBQ0U7UUFHQTs7Ozs7O0FBSVI7R0F4QndCYjtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvdGFibGUvcGFnZS50c3g/MWUzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcbmltcG9ydCBcIi4vc3R5bGVzLmNzc1wiO1xuaW1wb3J0IERhdGFHcmlkLCB7XG4gIHR5cGUgQ29sdW1uT3JDb2x1bW5Hcm91cCxcbiAgcmVuZGVyVmFsdWUsXG4gIHRleHRFZGl0b3Jcbn0gZnJvbSBcInJlYWN0LWRhdGEtZ3JpZFwiO1xuaW1wb3J0IFJlYWN0LCB7dXNlU3RhdGV9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBpbXBvcnQgeyByZW5kZXJDb29yZGluYXRlcyB9IGZyb20gXCIuL3JlbmRlcmVyc1wiO1xuLy8gaW1wb3J0IHR5cGUgeyBQcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xuXG5sZXQgbGlzdHMgPSBbXG4gIHtcbiAgICBpZDogXCIxNTc4M1wiLFxuICAgIG5hbWU6IFwiPGEgaHJlZj0ncHRfbWFpbi5waHRtbD8uc2Vzcz11LUZqYXlrOGI5MC1LUC1LMDRXMkI2S1MzVDRwYnJ2d0Q5NC1yVkFWUHlqLXl0T0Z0Z1RCOGQwLSYub3A9MzgwMSZwYWdlSWQ9MTI2OTYmb2JqRGVmSWQ9MTAwNDUmLnNlc3M9dS1GamF5azhiOTAtS1AtSzA0VzJCNktTM1Q0cGJydndEOTQtclZBVlB5ai15dE9GdGdUQjhkMC0mLm9wPTM4MDEmaWQ9MTU3ODMnPjE1NzgzLS1NYWp1YmEgVUNHIFNpdGUtSHlkcm9nZW9sb2dpY2FsIFNlcnZpY2VzPC9hPlwiLFxuICAgIHZhbHVlOiBcIjUxIDA1NS40MFwiLFxuICAgIGJpbGxlZDogXCIwXCIsXG4gICAgZm9yZWNhc3Q6IFwiNTEgMDU1LjQwXCIsXG4gICAgY2FzaGZsb3c6IFwiW11cIixcbiAgICBjYXNoZmxvd19tb250aGx5OiBcInt9XCIsXG4gICAgcm93OiAwLFxuICB9LFxuICB7XG4gICAgaWQ6IFwiMTU3ODFcIixcbiAgICBuYW1lOiBcIjxhIGhyZWY9J3B0X21haW4ucGh0bWw/LnNlc3M9dS1GamF5azhiOTAtS1AtSzA0VzJCNktTM1Q0cGJydndEOTQtclZBVlB5ai15dE9GdGdUQjhkMC0mLm9wPTM4MDEmcGFnZUlkPTEyNjk2Jm9iakRlZklkPTEwMDQ1Ji5zZXNzPXUtRmpheWs4YjkwLUtQLUswNFcyQjZLUzNUNHBicnZ3RDk0LXJWQVZQeWoteXRPRnRnVEI4ZDAtJi5vcD0zODAxJmlkPTE1NzgxJz4xNTc4MS0tTUNXQVAgRUNPPC9hPlwiLFxuICAgIHZhbHVlOiBcIjQ1NCA0ODkuOTJcIixcbiAgICBiaWxsZWQ6IFwiMFwiLFxuICAgIGZvcmVjYXN0OiBcIjQ1NCA0ODkuOTJcIixcbiAgICBjYXNoZmxvdzogXCJbXVwiLFxuICAgIGNhc2hmbG93X21vbnRobHk6IFwie31cIixcbiAgICByb3c6IDEsXG4gIH0sXG4gIHtcbiAgICBpZDogXCIxNTc3OVwiLFxuICAgIG5hbWU6IFwiPGEgaHJlZj0ncHRfbWFpbi5waHRtbD8uc2Vzcz11LUZqYXlrOGI5MC1LUC1LMDRXMkI2S1MzVDRwYnJ2d0Q5NC1yVkFWUHlqLXl0T0Z0Z1RCOGQwLSYub3A9MzgwMSZwYWdlSWQ9MTI2OTYmb2JqRGVmSWQ9MTAwNDUmLnNlc3M9dS1GamF5azhiOTAtS1AtSzA0VzJCNktTM1Q0cGJydndEOTQtclZBVlB5ai15dE9GdGdUQjhkMC0mLm9wPTM4MDEmaWQ9MTU3NzknPjE1Nzc5LS1XaXRrb3AgUGlldGVyc2J1cmcgbGluZSAzIDEzMmt2IHBvd2VybGluZS1FQ08tVGFzayBPcmRlcjwvYT5cIixcbiAgICB2YWx1ZTogXCI1NDIgNzE2LjIwXCIsXG4gICAgYmlsbGVkOiBcIjBcIixcbiAgICBmb3JlY2FzdDogXCI1NDIgNzE2LjIwXCIsXG4gICAgY2FzaGZsb3c6IFwiW11cIixcbiAgICBjYXNoZmxvd19tb250aGx5OiBcInt9XCIsXG4gICAgcm93OiAyLFxuICB9LFxuICB7XG4gICAgaWQ6IFwiMTU3NzBcIixcbiAgICBuYW1lOiBcIjxhIGhyZWY9J3B0X21haW4ucGh0bWw/LnNlc3M9dS1GamF5azhiOTAtS1AtSzA0VzJCNktTM1Q0cGJydndEOTQtclZBVlB5ai15dE9GdGdUQjhkMC0mLm9wPTM4MDEmcGFnZUlkPTEyNjk2Jm9iakRlZklkPTEwMDQ1Ji5zZXNzPXUtRmpheWs4YjkwLUtQLUswNFcyQjZLUzNUNHBicnZ3RDk0LXJWQVZQeWoteXRPRnRnVEI4ZDAtJi5vcD0zODAxJmlkPTE1NzcwJz4xNTc3MC0tQ01KQUggRmlyZSBSZW1lZGlhbCBXb3JrczwvYT5cIixcbiAgICB2YWx1ZTogXCIxIDI1MSAyMzIuMTJcIixcbiAgICBiaWxsZWQ6IFwiMFwiLFxuICAgIGZvcmVjYXN0OiBcIjEgMjUxIDIzMi4xMlwiLFxuICAgIGNhc2hmbG93OiBcIltdXCIsXG4gICAgY2FzaGZsb3dfbW9udGhseTogXCJ7fVwiLFxuICAgIHJvdzogMyxcbiAgfSxcbiAge1xuICAgIGlkOiBcIjExMzY0XCIsXG4gICAgbmFtZTogXCI8YSBocmVmPSdwdF9tYWluLnBodG1sPy5zZXNzPXUtRmpheWs4YjkwLUtQLUswNFcyQjZLUzNUNHBicnZ3RDk0LXJWQVZQeWoteXRPRnRnVEI4ZDAtJi5vcD0zODAxJnBhZ2VJZD0xMjY5NiZvYmpEZWZJZD0xMDA0NSYuc2Vzcz11LUZqYXlrOGI5MC1LUC1LMDRXMkI2S1MzVDRwYnJ2d0Q5NC1yVkFWUHlqLXl0T0Z0Z1RCOGQwLSYub3A9MzgwMSZpZD0xMTM2NCc+MTEzNjQtLVRzaGViZWxhICBSYW1waGVyaSBVbmluIDEzMiBrdiBQb3dlciBsaW5lPC9hPlwiLFxuICAgIHZhbHVlOiBcIjM3NiA5NjUuMjBcIixcbiAgICBiaWxsZWQ6IFwiMFwiLFxuICAgIGZvcmVjYXN0OiBcIjM3NiA5NjUuMjBcIixcbiAgICBjYXNoZmxvdzogXCJbXVwiLFxuICAgIGNhc2hmbG93X21vbnRobHk6IFwie31cIixcbiAgICByb3c6IDQsXG4gIH0sXG4gIHtcbiAgICBpZDogXCIxMTM2NVwiLFxuICAgIG5hbWU6IFwiPGEgaHJlZj0ncHRfbWFpbi5waHRtbD8uc2Vzcz11LUZqYXlrOGI5MC1LUC1LMDRXMkI2S1MzVDRwYnJ2d0Q5NC1yVkFWUHlqLXl0T0Z0Z1RCOGQwLSYub3A9MzgwMSZwYWdlSWQ9MTI2OTYmb2JqRGVmSWQ9MTAwNDUmLnNlc3M9dS1GamF5azhiOTAtS1AtSzA0VzJCNktTM1Q0cGJydndEOTQtclZBVlB5ai15dE9GdGdUQjhkMC0mLm9wPTM4MDEmaWQ9MTEzNjUnPjExMzY1LS1UQVNFWiBQSEFTRSAyIENEQy82MDYvMjM8L2E+XCIsXG4gICAgdmFsdWU6IFwiMzE2IDM3NS4wMFwiLFxuICAgIGJpbGxlZDogXCIwXCIsXG4gICAgZm9yZWNhc3Q6IFwiMzE2IDM3NS4wMFwiLFxuICAgIGNhc2hmbG93OiBcIltdXCIsXG4gICAgY2FzaGZsb3dfbW9udGhseTogXCJ7fVwiLFxuICAgIHJvdzogNSxcbiAgfSxcbiAge1xuICAgIGlkOiBcIjExMzY2XCIsXG4gICAgbmFtZTogXCI8YSBocmVmPSdwdF9tYWluLnBodG1sPy5zZXNzPXUtRmpheWs4YjkwLUtQLUswNFcyQjZLUzNUNHBicnZ3RDk0LXJWQVZQeWoteXRPRnRnVEI4ZDAtJi5vcD0zODAxJnBhZ2VJZD0xMjY5NiZvYmpEZWZJZD0xMDA0NSYuc2Vzcz11LUZqYXlrOGI5MC1LUC1LMDRXMkI2S1MzVDRwYnJ2d0Q5NC1yVkFWUHlqLXl0T0Z0Z1RCOGQwLSYub3A9MzgwMSZpZD0xMTM2Nic+MTEzNjYtLU1oaW5nYSBTdWJzdGF0aW9uIDQ1MDM0MDM2Mzc8L2E+XCIsXG4gICAgdmFsdWU6IFwiNTI2IDI0NS40MFwiLFxuICAgIGJpbGxlZDogXCIwXCIsXG4gICAgZm9yZWNhc3Q6IFwiNTI2IDI0NS40MFwiLFxuICAgIGNhc2hmbG93OiBcIltdXCIsXG4gICAgY2FzaGZsb3dfbW9udGhseTogXCJ7fVwiLFxuICAgIHJvdzogNixcbiAgfSxcbiAge1xuICAgIGlkOiBcIjExMzY3XCIsXG4gICAgbmFtZTogXCI8YSBocmVmPSdwdF9tYWluLnBodG1sPy5zZXNzPXUtRmpheWs4YjkwLUtQLUswNFcyQjZLUzNUNHBicnZ3RDk0LXJWQVZQeWoteXRPRnRnVEI4ZDAtJi5vcD0zODAxJnBhZ2VJZD0xMjY5NiZvYmpEZWZJZD0xMDA0NSYuc2Vzcz11LUZqYXlrOGI5MC1LUC1LMDRXMkI2S1MzVDRwYnJ2d0Q5NC1yVkFWUHlqLXl0T0Z0Z1RCOGQwLSYub3A9MzgwMSZpZD0xMTM2Nyc+MTEzNjctLU1hanViYSBVQ0c8L2E+XCIsXG4gICAgdmFsdWU6IFwiMiA1NjEgMjgwLjAwXCIsXG4gICAgYmlsbGVkOiBcIjBcIixcbiAgICBmb3JlY2FzdDogXCIyIDU2MSAyODAuMDBcIixcbiAgICBjYXNoZmxvdzogXCJbXVwiLFxuICAgIGNhc2hmbG93X21vbnRobHk6IFwie31cIixcbiAgICByb3c6IDcsXG4gIH0sXG4gIHtcbiAgICBpZDogXCIxMTM2OFwiLFxuICAgIG5hbWU6IFwiPGEgaHJlZj0ncHRfbWFpbi5waHRtbD8uc2Vzcz11LUZqYXlrOGI5MC1LUC1LMDRXMkI2S1MzVDRwYnJ2d0Q5NC1yVkFWUHlqLXl0T0Z0Z1RCOGQwLSYub3A9MzgwMSZwYWdlSWQ9MTI2OTYmb2JqRGVmSWQ9MTAwNDUmLnNlc3M9dS1GamF5azhiOTAtS1AtSzA0VzJCNktTM1Q0cGJydndEOTQtclZBVlB5ai15dE9GdGdUQjhkMC0mLm9wPTM4MDEmaWQ9MTEzNjgnPjExMzY4LS1MZXNlZGluZyBTdWJzdGF0aW9uICAwMDE1VFg8L2E+XCIsXG4gICAgdmFsdWU6IFwiNDQzIDMzMC4wMFwiLFxuICAgIGJpbGxlZDogXCIwXCIsXG4gICAgZm9yZWNhc3Q6IFwiNDQzIDMzMC4wMFwiLFxuICAgIGNhc2hmbG93OiBcIltdXCIsXG4gICAgY2FzaGZsb3dfbW9udGhseTogXCJ7fVwiLFxuICAgIHJvdzogOCxcbiAgfSxcbiAge1xuICAgIGlkOiBcIjExMzY5XCIsXG4gICAgbmFtZTogXCI8YSBocmVmPSdwdF9tYWluLnBodG1sPy5zZXNzPXUtRmpheWs4YjkwLUtQLUswNFcyQjZLUzNUNHBicnZ3RDk0LXJWQVZQeWoteXRPRnRnVEI4ZDAtJi5vcD0zODAxJnBhZ2VJZD0xMjY5NiZvYmpEZWZJZD0xMDA0NSYuc2Vzcz11LUZqYXlrOGI5MC1LUC1LMDRXMkI2S1MzVDRwYnJ2d0Q5NC1yVkFWUHlqLXl0T0Z0Z1RCOGQwLSYub3A9MzgwMSZpZD0xMTM2OSc+MTEzNjktLUFsZXggVFJBIDEwODFrPC9hPlwiLFxuICAgIHZhbHVlOiBcIjEzNiA2MTAuMDBcIixcbiAgICBiaWxsZWQ6IFwiMFwiLFxuICAgIGZvcmVjYXN0OiBcIjExNiA2MTAuMDBcIixcbiAgICBjYXNoZmxvdzogXCJbXVwiLFxuICAgIGNhc2hmbG93X21vbnRobHk6XG4gICAgICAne1wiTW9udGggRW5kZWQgTWFyY2ggMjAyNFwiOntcImFtb3VudFwiOjIwMDAwLFwia2V5XCI6XCIxNDMxXCJ9fScsXG4gICAgcm93OiA5LFxuICB9LFxuICB7XG4gICAgaWQ6IFwiMTE1MzhcIixcbiAgICBuYW1lOiBcIjxhIGhyZWY9J3B0X21haW4ucGh0bWw/LnNlc3M9dS1GamF5azhiOTAtS1AtSzA0VzJCNktTM1Q0cGJydndEOTQtclZBVlB5ai15dE9GdGdUQjhkMC0mLm9wPTM4MDEmcGFnZUlkPTEyNjk2Jm9iakRlZklkPTEwMDQ1Ji5zZXNzPXUtRmpheWs4YjkwLUtQLUswNFcyQjZLUzNUNHBicnZ3RDk0LXJWQVZQeWoteXRPRnRnVEI4ZDAtJi5vcD0zODAxJmlkPTExNTM4Jz4xMTUzOC0tTm9uLWJpbGxhYmxlPC9hPlwiLFxuICAgIHZhbHVlOiBcIjU3IDc1MC4wMFwiLFxuICAgIGJpbGxlZDogXCI1MiA3NTAuMDBcIixcbiAgICBmb3JlY2FzdDogXCI1IDAwMC4wMFwiLFxuICAgIGNhc2hmbG93OlxuICAgICAgJ1t7XCJhbW91bnRcIjoyNzUwLFwiZGF0ZVwiOlwiMDcvMzEvMjAyNFwifSx7XCJhbW91bnRcIjo1MDAwMCxcImRhdGVcIjpcIjA3LzMxLzIwMjRcIn1dJyxcbiAgICBjYXNoZmxvd19tb250aGx5OlxuICAgICAgJ3tcIk1vbnRoIEVuZGVkIERlY2VtYmVyIDIwMjRcIjp7XCJhbW91bnRcIjo1MDAwLFwia2V5XCI6XCIxNDMyXCJ9LFwiTW9udGggRW5kZWQgSnVseSAyMDI0XCI6e1wiYW1vdW50XCI6MCxcImtleVwiOlwiMTQzM1wifSxcIk1vbnRoIEVuZGVkIEF1Z3VzdCAyMDI0XCI6e1wiYW1vdW50XCI6MCxcImtleVwiOlwiMTQzNFwifSxcIk1vbnRoIEVuZGVkIFNlcHRlbWJlciAyMDI0XCI6e1wiYW1vdW50XCI6MCxcImtleVwiOlwiMTQzNVwifSxcIk1vbnRoIEVuZGVkIE9jdG9iZXIgMjAyNFwiOntcImFtb3VudFwiOjAsXCJrZXlcIjpcIjE0MzZcIn0sXCJNb250aCBFbmRlZCBOb3ZlbWJlciAyMDI0XCI6e1wiYW1vdW50XCI6MCxcImtleVwiOlwiMTQzN1wifSxcIk1vbnRoIEVuZGVkIE1hcmNoIDIwMjRcIjp7XCJhbW91bnRcIjoxNTAwMCxcImtleVwiOlwiMTQyMVwifSxcIk1vbnRoIEVuZGVkIEFwcmlsIDIwMjRcIjp7XCJhbW91bnRcIjoyMDAwMCxcImtleVwiOlwiMTQyMlwifSxcIk1vbnRoIEVuZGVkIE1heSAyMDI0XCI6e1wiYW1vdW50XCI6Njc4NyxcImtleVwiOlwiMTQyM1wifSxcIk1vbnRoIEVuZGVkIEp1bmUgMjAyNFwiOntcImFtb3VudFwiOjU5NjMsXCJrZXlcIjpcIjE0MjRcIn19JyxcbiAgICByb3c6IDEwLFxuICB9LFxuICB7XG4gICAgaWQ6IFwiMTIwNDVcIixcbiAgICBuYW1lOiBcIjxhIGhyZWY9J3B0X21haW4ucGh0bWw/LnNlc3M9dS1GamF5azhiOTAtS1AtSzA0VzJCNktTM1Q0cGJydndEOTQtclZBVlB5ai15dE9GdGdUQjhkMC0mLm9wPTM4MDEmcGFnZUlkPTEyNjk2Jm9iakRlZklkPTEwMDQ1Ji5zZXNzPXUtRmpheWs4YjkwLUtQLUswNFcyQjZLUzNUNHBicnZ3RDk0LXJWQVZQeWoteXRPRnRnVEI4ZDAtJi5vcD0zODAxJmlkPTEyMDQ1Jz4xMjA0NS0tVWNob2JhIFRhc2sgT3JkZXIgLUVjb2xvZ2ljYWwgV2FsayBkb3duPC9hPlwiLFxuICAgIHZhbHVlOiBcIjExOCA5ODMuNTBcIixcbiAgICBiaWxsZWQ6IFwiMFwiLFxuICAgIGZvcmVjYXN0OiBcIjExOCA5ODMuNTBcIixcbiAgICBjYXNoZmxvdzogXCJbXVwiLFxuICAgIGNhc2hmbG93X21vbnRobHk6IFwie31cIixcbiAgICByb3c6IDExLFxuICB9LFxuICB7XG4gICAgaWQ6IFwiMTIwNTFcIixcbiAgICBuYW1lOiBcIjxhIGhyZWY9J3B0X21haW4ucGh0bWw/LnNlc3M9dS1GamF5azhiOTAtS1AtSzA0VzJCNktTM1Q0cGJydndEOTQtclZBVlB5ai15dE9GdGdUQjhkMC0mLm9wPTM4MDEmcGFnZUlkPTEyNjk2Jm9iakRlZklkPTEwMDQ1Ji5zZXNzPXUtRmpheWs4YjkwLUtQLUswNFcyQjZLUzNUNHBicnZ3RDk0LXJWQVZQeWoteXRPRnRnVEI4ZDAtJi5vcD0zODAxJmlkPTEyMDUxJz4xMjA1MS0tVWNob2JhIFRhc2sgT3JkZXIgLSBIZXJpdGFnZSBXYWxrZG93bjwvYT5cIixcbiAgICB2YWx1ZTogXCIxNjQgMzA5LjUwXCIsXG4gICAgYmlsbGVkOiBcIjBcIixcbiAgICBmb3JlY2FzdDogXCIxNjQgMzA5LjUwXCIsXG4gICAgY2FzaGZsb3c6IFwiW11cIixcbiAgICBjYXNoZmxvd19tb250aGx5OiBcInt9XCIsXG4gICAgcm93OiAxMixcbiAgfSxcbiAge1xuICAgIGlkOiBcIjEyMDY0XCIsXG4gICAgbmFtZTogXCI8YSBocmVmPSdwdF9tYWluLnBodG1sPy5zZXNzPXUtRmpheWs4YjkwLUtQLUswNFcyQjZLUzNUNHBicnZ3RDk0LXJWQVZQeWoteXRPRnRnVEI4ZDAtJi5vcD0zODAxJnBhZ2VJZD0xMjY5NiZvYmpEZWZJZD0xMDA0NSYuc2Vzcz11LUZqYXlrOGI5MC1LUC1LMDRXMkI2S1MzVDRwYnJ2d0Q5NC1yVkFWUHlqLXl0T0Z0Z1RCOGQwLSYub3A9MzgwMSZpZD0xMjA2NCc+MTIwNjQtLUVudG9rb3p3ZW5pIFRla3dhbmUgTm9ydGggMTMyS1ZTIFBvd2VyIExpbmUgLSBIZXJpdGFnZSBXYWxrdGhyb3VnaHQ8L2E+XCIsXG4gICAgdmFsdWU6IFwiOTQgNjQ2LjgwXCIsXG4gICAgYmlsbGVkOiBcIjBcIixcbiAgICBmb3JlY2FzdDogXCI5NCA2NDYuODBcIixcbiAgICBjYXNoZmxvdzogXCJbXVwiLFxuICAgIGNhc2hmbG93X21vbnRobHk6IFwie31cIixcbiAgICByb3c6IDEzLFxuICB9LFxuICB7XG4gICAgaWQ6IFwiMTIwNjVcIixcbiAgICBuYW1lOiBcIjxhIGhyZWY9J3B0X21haW4ucGh0bWw/LnNlc3M9dS1GamF5azhiOTAtS1AtSzA0VzJCNktTM1Q0cGJydndEOTQtclZBVlB5ai15dE9GdGdUQjhkMC0mLm9wPTM4MDEmcGFnZUlkPTEyNjk2Jm9iakRlZklkPTEwMDQ1Ji5zZXNzPXUtRmpheWs4YjkwLUtQLUswNFcyQjZLUzNUNHBicnZ3RDk0LXJWQVZQeWoteXRPRnRnVEI4ZDAtJi5vcD0zODAxJmlkPTEyMDY1Jz4xMjA2NS0tRW50b2tvendlbmkgVGVrd2FuZSBOb3J0aCAxMzJLVlMgUG93ZXIgTGluZSAtIEVjb2xvZ2ljYWwgV2Fsa3Rocm91Z2h0PC9hPlwiLFxuICAgIHZhbHVlOiBcIjEwNCAzMDYuODBcIixcbiAgICBiaWxsZWQ6IFwiMFwiLFxuICAgIGZvcmVjYXN0OiBcIjEwNCAzMDYuODBcIixcbiAgICBjYXNoZmxvdzogXCJbXVwiLFxuICAgIGNhc2hmbG93X21vbnRobHk6IFwie31cIixcbiAgICByb3c6IDE0LFxuICB9LFxuICB7XG4gICAgaWQ6IFwiMTIwNzRcIixcbiAgICBuYW1lOiBcIjxhIGhyZWY9J3B0X21haW4ucGh0bWw/LnNlc3M9dS1GamF5azhiOTAtS1AtSzA0VzJCNktTM1Q0cGJydndEOTQtclZBVlB5ai15dE9GdGdUQjhkMC0mLm9wPTM4MDEmcGFnZUlkPTEyNjk2Jm9iakRlZklkPTEwMDQ1Ji5zZXNzPXUtRmpheWs4YjkwLUtQLUswNFcyQjZLUzNUNHBicnZ3RDk0LXJWQVZQeWoteXRPRnRnVEI4ZDAtJi5vcD0zODAxJmlkPTEyMDc0Jz4xMjA3NC0tMjMxOUgg4oCTIEFSSUVTIFVQSU5HVE9OIDQwMEtWPC9hPlwiLFxuICAgIHZhbHVlOiBcIjQgNDA3IDgwMC4wMFwiLFxuICAgIGJpbGxlZDogXCIwXCIsXG4gICAgZm9yZWNhc3Q6IFwiMyA4NTcgODAwLjAwXCIsXG4gICAgY2FzaGZsb3c6IFwiW11cIixcbiAgICBjYXNoZmxvd19tb250aGx5OlxuICAgICAgJ3tcIk1vbnRoIEVuZGVkIEF1Z3VzdCAyMDI0XCI6e1wiYW1vdW50XCI6NTAwMDAwLFwia2V5XCI6XCIxNDI1XCJ9LFwiTW9udGggRW5kZWQgTWFyY2ggMjAyNFwiOntcImFtb3VudFwiOjUwMDAwLFwia2V5XCI6XCIxNDI2XCJ9LFwiTW9udGggRW5kZWQgQXByaWwgMjAyNFwiOntcImFtb3VudFwiOjAsXCJrZXlcIjpcIjE0MjdcIn0sXCJNb250aCBFbmRlZCBNYXkgMjAyNFwiOntcImFtb3VudFwiOjAsXCJrZXlcIjpcIjE0MjhcIn0sXCJNb250aCBFbmRlZCBKdW5lIDIwMjRcIjp7XCJhbW91bnRcIjowLFwia2V5XCI6XCIxNDI5XCJ9LFwiTW9udGggRW5kZWQgSnVseSAyMDI0XCI6e1wiYW1vdW50XCI6MCxcImtleVwiOlwiMTQzMFwifX0nLFxuICAgIHJvdzogMTUsXG4gIH0sXG4gIHtcbiAgICBpZDogXCIxMjA5N1wiLFxuICAgIG5hbWU6IFwiPGEgaHJlZj0ncHRfbWFpbi5waHRtbD8uc2Vzcz11LUZqYXlrOGI5MC1LUC1LMDRXMkI2S1MzVDRwYnJ2d0Q5NC1yVkFWUHlqLXl0T0Z0Z1RCOGQwLSYub3A9MzgwMSZwYWdlSWQ9MTI2OTYmb2JqRGVmSWQ9MTAwNDUmLnNlc3M9dS1GamF5azhiOTAtS1AtSzA0VzJCNktTM1Q0cGJydndEOTQtclZBVlB5ai15dE9GdGdUQjhkMC0mLm9wPTM4MDEmaWQ9MTIwOTcnPjEyMDk3LS1HRU1TQk9LIEtXQU1ITEFOR0EgMTMyS1YgUE9XRVJMSU5FIOKAkyBFQ09MT0dJQ0FMIFdBTEtUSFJPVUdIPC9hPlwiLFxuICAgIHZhbHVlOiBcIjUzIDY3NS4wMFwiLFxuICAgIGJpbGxlZDogXCIwXCIsXG4gICAgZm9yZWNhc3Q6IFwiNTMgNjc1LjAwXCIsXG4gICAgY2FzaGZsb3c6IFwiW11cIixcbiAgICBjYXNoZmxvd19tb250aGx5OiBcInt9XCIsXG4gICAgcm93OiAxNixcbiAgfSxcbl07XG5cbmZ1bmN0aW9uIGFnZ3JlZ2F0ZU1vbnRobHlUb3RhbHMoZGF0YTphbnkpIHtcbiAgICAvLyBPYmplY3QgdG8gc3RvcmUgdGhlIHN1bSBvZiBhbW91bnRzIGZvciBlYWNoIG1vbnRoXG4gICAgY29uc3QgbW9udGhseVRvdGFsczphbnkgPSB7fTtcblxuICAgIGRhdGEuZm9yRWFjaCgoZW50cnk6IGFueSApPT4ge1xuICAgICAgICBjb25zdCBhbW91bnQgPSBlbnRyeS5hbW91bnQ7XG4gICAgICAgIGNvbnN0IGRhdGVTdHIgPSBlbnRyeS5kYXRlO1xuXG4gICAgICAgIC8vIFBhcnNlIHRoZSBkYXRlIHN0cmluZyBpbnRvIGEgRGF0ZSBvYmplY3RcbiAgICAgICAgY29uc3QgZGF0ZU9iaiA9IG5ldyBEYXRlKGRhdGVTdHIpO1xuXG4gICAgICAgIC8vIEV4dHJhY3QgeWVhciBhbmQgbW9udGggKDAtYmFzZWQgbW9udGgpXG4gICAgICAgIGNvbnN0IHllYXIgPSBkYXRlT2JqLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIGNvbnN0IG1vbnRoID0gZGF0ZU9iai5nZXRNb250aCgpOyAvLyAwIGZvciBKYW51YXJ5LCAxMSBmb3IgRGVjZW1iZXJcblxuICAgICAgICAvLyBGb3JtYXQgdGhlIGtleSBhcyBcIllZWVktTU1cIiB0byBncm91cCBieSBtb250aCBhbmQgeWVhclxuICAgICAgICBjb25zdCB5ZWFyTW9udGggPSBgJHt5ZWFyfS0ke1N0cmluZyhtb250aCArIDEpLnBhZFN0YXJ0KDIsICcwJyl9YDtcblxuICAgICAgICAvLyBBZGQgdGhlIGFtb3VudCB0byB0aGUgY29ycmVzcG9uZGluZyBtb250aFxuICAgICAgICBpZiAoIW1vbnRobHlUb3RhbHNbeWVhck1vbnRoXSkge1xuICAgICAgICAgICAgbW9udGhseVRvdGFsc1t5ZWFyTW9udGhdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBtb250aGx5VG90YWxzW3llYXJNb250aF0gKz0gYW1vdW50OyBcbiAgICB9KTtcblxuICAgIC8vIENvbnZlcnQgdGhlIHJlc3VsdCB0byB0aGUgZGVzaXJlZCBmb3JtYXRcbiAgICBjb25zdCByZXN1bHQ6YW55ID0ge307XG4gICAgT2JqZWN0LmtleXMobW9udGhseVRvdGFscykuZm9yRWFjaCh5ZWFyTW9udGggPT4ge1xuICAgICAgICBjb25zdCBbeWVhciwgbW9udGhdID0geWVhck1vbnRoLnNwbGl0KCctJyk7XG4gICAgICAgIC8vIENyZWF0ZSBhIGRhdGUgb2JqZWN0IGZvciB0aGUgbGFzdCBkYXkgb2YgdGhlIG1vbnRoXG4gICAgICAgIGNvbnN0IGVuZERhdGUgPSBuZXcgRGF0ZShOdW1iZXIoeWVhciksIE51bWJlcihtb250aCksIDApOyAvLyAwIGlzIHRoZSBsYXN0IGRheSBvZiB0aGUgcHJldmlvdXMgbW9udGhcblxuICAgICAgICAvLyBGb3JtYXQgdGhlIGRhdGUgdG8gXCJNb250aCBFbmRlZCBNb250aCBZWVlZXCJcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkRGF0ZSA9IGBNb250aCBFbmRlZCAke2Zvcm1hdERhdGVUb0N1c3RvbUZvcm1hdChuZXcgRGF0ZShOdW1iZXIoeWVhciksIE51bWJlcihtb250aCkgLSAxKSl9YDtcbiAgICAgICAgcmVzdWx0W2Zvcm1hdHRlZERhdGVdID0gbW9udGhseVRvdGFsc1t5ZWFyTW9udGhdO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxubGlzdHMgPSBsaXN0cy5tYXAoIGVsID0+IHtcblxuICAgIGxldCBuZXdfZWwgPSBlbFxuICAgIG5ld19lbC5jYXNoZmxvd19tb250aGx5ID0gSlNPTi5wYXJzZShuZXdfZWwuY2FzaGZsb3dfbW9udGhseSlcbiAgICBuZXdfZWwuY2FzaGZsb3cgPSBhZ2dyZWdhdGVNb250aGx5VG90YWxzKEpTT04ucGFyc2UobmV3X2VsLmNhc2hmbG93KSlcbiAgICByZXR1cm4gbmV3X2VsXG5cbn0pXG5cbmNvbnNvbGUubG9nKFwidXBkYXRlZCBlbFwiLCBsaXN0cylcblxuZnVuY3Rpb24gZm9ybWF0RGF0ZVRvQ3VzdG9tRm9ybWF0KGRhdGU6YW55KSB7XG4gIGNvbnN0IG9wdGlvbnM6YW55ID0geyBtb250aDogXCJsb25nXCIsIHllYXI6IFwibnVtZXJpY1wiIH07XG4gIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLUdCXCIsIG9wdGlvbnMpLmZvcm1hdChkYXRlKTtcbn1cblxuZnVuY3Rpb24gZ2V0RmluYW5jaWFsWWVhclBlcmlvZHMoKSB7XG4gIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgY29uc3QgeWVhciA9IHRvZGF5LmdldEZ1bGxZZWFyKCk7XG5cbiAgLy8gRmluYW5jaWFsIHllYXIgc3RhcnRzIG9uIE1hcmNoIDFzdCBvZiB0aGUgY3VycmVudCB5ZWFyIG9yIHByZXZpb3VzIHllYXJcbiAgY29uc3QgZmluYW5jaWFsWWVhclN0YXJ0ID0gbmV3IERhdGUoeWVhciwgMiwgMSk7IC8vIE1hcmNoIDFzdCBvZiB0aGUgY3VycmVudCB5ZWFyXG4gIGlmICh0b2RheSA8IGZpbmFuY2lhbFllYXJTdGFydCkge1xuICAgIC8vIElmIHRvZGF5IGlzIGJlZm9yZSBNYXJjaCAxc3QsIHRoZSBmaW5hbmNpYWwgeWVhciBzdGFydHMgbGFzdCB5ZWFyXG4gICAgZmluYW5jaWFsWWVhclN0YXJ0LnNldEZ1bGxZZWFyKHllYXIgLSAxKTtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSB0aGUgc3RhcnQgYW5kIGVuZCBkYXRlcyBmb3IgdGhlIGN1cnJlbnQgZmluYW5jaWFsIHllYXJcbiAgY29uc3QgZmluYW5jaWFsWWVhckVuZCA9IG5ldyBEYXRlKGZpbmFuY2lhbFllYXJTdGFydCk7XG4gIGZpbmFuY2lhbFllYXJFbmQuc2V0RnVsbFllYXIoZmluYW5jaWFsWWVhclN0YXJ0LmdldEZ1bGxZZWFyKCkgKyAxKTtcbiAgZmluYW5jaWFsWWVhckVuZC5zZXRNb250aCgxKTsgLy8gRmVicnVhcnlcbiAgZmluYW5jaWFsWWVhckVuZC5zZXREYXRlKDI5KTsgLy8gVG8gZW5zdXJlIGl0J3MgYSBsZWFwIHllYXIgaWYgbmVjZXNzYXJ5XG5cbiAgLy8gUGVyaW9kcyBmb3IgdGhlIGN1cnJlbnQgZmluYW5jaWFsIHllYXJcbiAgY29uc3QgY3VycmVudFllYXJQZXJpb2RzID0gW107XG4gIGxldCBwZXJpb2RTdGFydCA9IG5ldyBEYXRlKGZpbmFuY2lhbFllYXJTdGFydCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG4gICAgLy8gR2V0IHRoZSBlbmQgb2YgdGhlIG1vbnRoXG4gICAgY29uc3QgZW5kT2ZNb250aCA9IG5ldyBEYXRlKFxuICAgICAgcGVyaW9kU3RhcnQuZ2V0RnVsbFllYXIoKSxcbiAgICAgIHBlcmlvZFN0YXJ0LmdldE1vbnRoKCkgKyAxLFxuICAgICAgMFxuICAgICk7XG5cbiAgICAvLyBGb3JtYXQgZm9yIFwiTW9udGggRW5kZWQgU2VwdGVtYmVyIDIwMjRcIlxuICAgIGNvbnN0IG1vbnRoRW5kZWQgPSBgTW9udGggRW5kZWQgJHtmb3JtYXREYXRlVG9DdXN0b21Gb3JtYXQoZW5kT2ZNb250aCl9YDtcblxuICAgIGN1cnJlbnRZZWFyUGVyaW9kcy5wdXNoKHtcbiAgICAgIG5hbWU6IG1vbnRoRW5kZWQsIC8vIE9ubHkgdGhlIGZvcm1hdHRlZCBtb250aCBhbmQgeWVhcixcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIHsga2V5OiBcIjJcIiArIGksIG5hbWU6IFwiQ2xhaW1lZFwiLCB3aWR0aDogXCIxOTBweFwiLCByZW5kZXJDZWxsKHByb3BzOmFueSkge1xuXG4gICAgICAgICAgICBpZihwcm9wcy5yb3cuY2FzaGZsb3dbcHJvcHMuY29sdW1uLnBhcmVudC5uYW1lXSl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhbW91bnQgPSAoTnVtYmVyKHByb3BzLnJvdy5jYXNoZmxvd1twcm9wcy5jb2x1bW4ucGFyZW50Lm5hbWVdKSkgLy8qICgxMDAvMTE1KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludGwuTnVtYmVyRm9ybWF0KCdlbi1VUycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUdyb3VwaW5nOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgfSkuZm9ybWF0KGFtb3VudCkucmVwbGFjZSgvLC9nLCAnICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gXCIwLjAwXCJcbiAgICAgICAgICB9ICB9LFxuICAgICAgICB7IGtleTogXCIzXCIgKyBpLCBuYW1lOiBcIlZhdFwiICx3aWR0aDogXCIxNTBweFwiICxyZW5kZXJDZWxsKHByb3BzOmFueSkge1xuXG4gICAgICAgICAgICBpZihwcm9wcy5yb3cuY2FzaGZsb3dbcHJvcHMuY29sdW1uLnBhcmVudC5uYW1lXSl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhbW91bnQgPSAoTnVtYmVyKHByb3BzLnJvdy5jYXNoZmxvd1twcm9wcy5jb2x1bW4ucGFyZW50Lm5hbWVdKSkgKiAoMTUvMTAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludGwuTnVtYmVyRm9ybWF0KCdlbi1VUycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUdyb3VwaW5nOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgfSkuZm9ybWF0KGFtb3VudCkucmVwbGFjZSgvLC9nLCAnICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gXCIwLjAwXCJcbiAgICAgICAgICB9fSxcbiAgICAgICAgeyBrZXk6IFwiNFwiK2ksIG5hbWU6IFwiVG90YWwgQ2xhaW1lZFwiICwgcmVuZGVyQ2VsbChwcm9wczphbnkpIHtcblxuICAgICAgICAgICAgaWYocHJvcHMucm93LmNhc2hmbG93W3Byb3BzLmNvbHVtbi5wYXJlbnQubmFtZV0pe1xuICAgICAgICAgICAgICAgICAgICBsZXQgYW1vdW50ID0gKE51bWJlcihwcm9wcy5yb3cuY2FzaGZsb3dbcHJvcHMuY29sdW1uLnBhcmVudC5uYW1lXSkpICogKDExNS8xMDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoJ2VuLVVTJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlR3JvdXBpbmc6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICB9KS5mb3JtYXQoYW1vdW50KS5yZXBsYWNlKC8sL2csICcgJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBcIjAuMDBcIlxuICAgICAgICAgIH19LFxuICAgICAgICB7IGtleTogbW9udGhFbmRlZCwgbmFtZTogXCJCdWRndGVkXCIsIHdpZHRoOlwiMTUwcHhcIiwgcmVuZGVyRWRpdENlbGw6IHRleHRFZGl0b3IgLHJlbmRlckNlbGwocHJvcHM6YW55KSB7XG4gICAgICAgICAgICBsZXQgYW1vdW50ID0gMDtcbiAgICAgICAgICAgIGlmKHByb3BzLnJvd1twcm9wcy5jb2x1bW4ucGFyZW50Lm5hbWVdKXtcbiAgICAgICAgICAgICAgIGFtb3VudCA9IChOdW1iZXIocHJvcHMucm93W3Byb3BzLmNvbHVtbi5wYXJlbnQubmFtZV0pKVxuICAgICAgICAgICAgfWVsc2UgaWYocHJvcHMucm93LmNhc2hmbG93X21vbnRobHlbcHJvcHMuY29sdW1uLnBhcmVudC5uYW1lXSl7XG4gICAgICAgICAgICAgICAgYW1vdW50ID0gKE51bWJlcihwcm9wcy5yb3cuY2FzaGZsb3dfbW9udGhseVtwcm9wcy5jb2x1bW4ucGFyZW50Lm5hbWVdLmFtb3VudCkpICogKDEwMC8xMDApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoJ2VuLVVTJywge1xuICAgICAgICAgICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMixcbiAgICAgICAgICAgICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDIsXG4gICAgICAgICAgICAgICAgdXNlR3JvdXBpbmc6IHRydWVcbiAgICAgICAgICAgICAgfSkuZm9ybWF0KGFtb3VudCkucmVwbGFjZSgvLC9nLCAnICcpO1xuXG4gICAgICAgICAgfSB9LFxuICAgICAgICB7IGtleTogXCI2XCIraSwgbmFtZTogXCJWYXRcIix3aWR0aDpcIjE1MHB4XCIgLHJlbmRlckNlbGwocHJvcHM6YW55KSB7XG4gICAgICAgICAgICBsZXQgYW1vdW50ID0gMDtcbiAgICAgICAgICAgIGlmKHByb3BzLnJvd1twcm9wcy5jb2x1bW4ucGFyZW50Lm5hbWVdKXtcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50ID0gcHJvcHMucm93W3Byb3BzLmNvbHVtbi5wYXJlbnQubmFtZV0gKiAoMTUvMTAwKVxuXG4gICAgICAgICAgICB9ZWxzZSBpZihwcm9wcy5yb3cuY2FzaGZsb3dfbW9udGhseVtwcm9wcy5jb2x1bW4ucGFyZW50Lm5hbWVdKXtcbiAgICAgICAgICAgICAgICBhbW91bnQgPSAoTnVtYmVyKHByb3BzLnJvdy5jYXNoZmxvd19tb250aGx5W3Byb3BzLmNvbHVtbi5wYXJlbnQubmFtZV0uYW1vdW50KSkgKiAoMTUvMTAwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gIG5ldyBJbnRsLk51bWJlckZvcm1hdCgnZW4tVVMnLCB7XG4gICAgICAgICAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiAyLFxuICAgICAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMixcbiAgICAgICAgICAgICAgICB1c2VHcm91cGluZzogdHJ1ZVxuICAgICAgICAgICAgICB9KS5mb3JtYXQoYW1vdW50KS5yZXBsYWNlKC8sL2csICcgJyk7XG4gICAgICAgICAgIH19LFxuXG5cbiAgICAgICAgeyBrZXk6IFwiN1wiK2ksIG5hbWU6IFwiVG90YWwgQnVkZ3RlZFwiLCB3aWR0aDpcIjE1MHB4XCIscmVuZGVyQ2VsbChwcm9wczphbnkpIHtcblxuXG4gICAgICAgICAgICBcblxuICAgICAgICAgICAgbGV0IGFtb3VudCA9IDA7XG4gICAgICAgICAgICBpZihwcm9wcy5yb3dbcHJvcHMuY29sdW1uLnBhcmVudC5uYW1lXSl7XG4gICAgICAgICAgICAgICAgYW1vdW50ID0gcHJvcHMucm93W3Byb3BzLmNvbHVtbi5wYXJlbnQubmFtZV0gKiAoMTE1LzEwMClcblxuICAgICAgICAgICAgfWVsc2UgaWYocHJvcHMucm93LmNhc2hmbG93X21vbnRobHlbcHJvcHMuY29sdW1uLnBhcmVudC5uYW1lXSl7XG4gICAgICAgICAgICAgICAgYW1vdW50ID0gKE51bWJlcihwcm9wcy5yb3cuY2FzaGZsb3dfbW9udGhseVtwcm9wcy5jb2x1bW4ucGFyZW50Lm5hbWVdLmFtb3VudCkpICogKDExNS8xMDApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiAgbmV3IEludGwuTnVtYmVyRm9ybWF0KCdlbi1VUycsIHtcbiAgICAgICAgICAgICAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIsXG4gICAgICAgICAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAyLFxuICAgICAgICAgICAgICAgIHVzZUdyb3VwaW5nOiB0cnVlXG4gICAgICAgICAgICAgIH0pLmZvcm1hdChhbW91bnQpLnJlcGxhY2UoLywvZywgJyAnKTtcbiAgICAgICAgICAgXG4gICAgICAgICAgIH0gfSxcbiAgICAgICAgeyBrZXk6IFwiOFwiK2ksIG5hbWU6IFwiT3Zlci9VbmRlciBCaWxsZWRcIiwgcmVuZGVyQ2VsbChwcm9wczphbnkpIHtcblxuICAgICAgICAgICAgbGV0ICB0b3RvYWxfYnVkZ2V0ICA9IDA7XG4gICAgICAgICAgICBpZihwcm9wcy5yb3dbcHJvcHMuY29sdW1uLnBhcmVudC5uYW1lXSl7XG4gICAgICAgICAgICAgICAgdG90b2FsX2J1ZGdldCA9IHByb3BzLnJvd1twcm9wcy5jb2x1bW4ucGFyZW50Lm5hbWVdICogKDExNS8xMDApXG5cbiAgICAgICAgICAgIH1lbHNlIGlmKHByb3BzLnJvdy5jYXNoZmxvd19tb250aGx5W3Byb3BzLmNvbHVtbi5wYXJlbnQubmFtZV0pe1xuICAgICAgICAgICAgICAgIHRvdG9hbF9idWRnZXQgPSAoTnVtYmVyKHByb3BzLnJvdy5jYXNoZmxvd19tb250aGx5W3Byb3BzLmNvbHVtbi5wYXJlbnQubmFtZV0uYW1vdW50KSkgKiAoMTE1LzEwMClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IGFjdHVhbCA9IDA7IFxuICAgICAgICAgICAgaWYocHJvcHMucm93LmNhc2hmbG93W3Byb3BzLmNvbHVtbi5wYXJlbnQubmFtZV0pe1xuICAgICAgICAgICAgICAgIGFjdHVhbCA9IChOdW1iZXIocHJvcHMucm93LmNhc2hmbG93W3Byb3BzLmNvbHVtbi5wYXJlbnQubmFtZV0pKSAqICgxMTUvMTAwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgZGlmZiA9IGFjdHVhbCAtIHRvdG9hbF9idWRnZXRcbiAgICAgICAgICAgICByZXR1cm4gIG5ldyBJbnRsLk51bWJlckZvcm1hdCgnZW4tVVMnLCB7XG4gICAgICAgICAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiAyLFxuICAgICAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMixcbiAgICAgICAgICAgICAgICB1c2VHcm91cGluZzogdHJ1ZVxuICAgICAgICAgICAgICB9KS5mb3JtYXQoZGlmZikucmVwbGFjZSgvLC9nLCAnICcpO1xuICAgICAgICAgICB9IH0sXG4gICAgICBdLFxuICAgICAga2V5OiBcIjlcIitpLFxuICAgIH0pO1xuXG4gICAgLy8gTW92ZSB0byB0aGUgbmV4dCBtb250aFxuICAgIHBlcmlvZFN0YXJ0LnNldE1vbnRoKHBlcmlvZFN0YXJ0LmdldE1vbnRoKCkgKyAxKTtcbiAgfVxuXG4gIHJldHVybiBjdXJyZW50WWVhclBlcmlvZHM7XG59XG5cbmNvbnNvbGUubG9nKGdldEZpbmFuY2lhbFllYXJQZXJpb2RzKCkpO1xubGV0IHJlcyA9IGdldEZpbmFuY2lhbFllYXJQZXJpb2RzKCk7XG5jb25zdCBjb2x1bW5zID0gW1xuICB7XG4gICAgbmFtZTogXCJQcm9qZWN0IEJpbGxpbmcgUHJvamVjdGlvbnNcIixcblxuICAgIGNoaWxkcmVuOiBbXG4gICAgICB7XG4gICAgICAgIGtleTogXCIxXCIsXG4gICAgICAgIG5hbWU6IFwiVGFzayBPcmRlclwiLFxuICAgICAgICBmcm96ZW46IHRydWUsXG4gICAgICAgIHdpZHRoOiBcIjIwMHB4XCIsXG4gICAgICAgIHJlbmRlckNlbGwocHJvcHM6YW55KSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLnJvd1snbmFtZSddO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IFwiM1wiLFxuICAgICAgICBuYW1lOiBcIlZhbHVlXCIsXG4gICAgICAgIHdpZHRoOiBcIjE0MHB4XCIsXG4gICAgICAgIHJlbmRlckNlbGwocHJvcHM6YW55KSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLnJvd1sndmFsdWUnXTtcbiAgICAgICAgfSxcblxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBcIjRcIixcbiAgICAgICAgbmFtZTogXCJDbGFpbWVkIEV4Y2xcIixcbiAgICAgICAgd2lkdGg6IFwiMTQwcHhcIixcbiAgICAgICAgcmVuZGVyQ2VsbChwcm9wczphbnkpIHtcbiAgICAgICAgICAgIGxldCBudW0gPSAoTnVtYmVyKHByb3BzLnJvd1snYmlsbGVkJ10ucmVwbGFjZSgvXFxzKy9nLCAnJykpKigxMDAvMTAwKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoJ2VuLVVTJywge1xuICAgICAgICAgICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMixcbiAgICAgICAgICAgICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDIsXG4gICAgICAgICAgICAgICAgdXNlR3JvdXBpbmc6IHRydWVcbiAgICAgICAgICAgICAgfSkuZm9ybWF0KG51bSkucmVwbGFjZSgvLC9nLCAnICcpO1xuICAgICAgICAgIH0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IFwiNVwiLFxuICAgICAgICBuYW1lOiBcIlZhdFwiLFxuICAgICAgICB3aWR0aDogXCIxNTBweFwiLFxuICAgICAgICByZW5kZXJDZWxsKHByb3BzOmFueSkge1xuICAgICAgICAgICAgbGV0IG51bTphbnkgPSAoTnVtYmVyKHByb3BzLnJvd1snYmlsbGVkJ10ucmVwbGFjZSgvXFxzKy9nLCAnJykpKigxNS8xMDApKS50b0ZpeGVkKDIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdCgnZW4tVVMnLCB7XG4gICAgICAgICAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiAyLFxuICAgICAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMixcbiAgICAgICAgICAgICAgICB1c2VHcm91cGluZzogdHJ1ZVxuICAgICAgICAgICAgICB9KS5mb3JtYXQobnVtKS5yZXBsYWNlKC8sL2csICcgJyk7XG4gICAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogXCI2XCIsXG4gICAgICAgIG5hbWU6IFwiVG90YWwgQ2xhaW1lZFwiLFxuICAgICAgICB3aWR0aDogXCIxNTBweFwiLFxuICAgICAgICByZW5kZXJDZWxsKHByb3BzOmFueSkge1xuICAgICAgICAgICAgbGV0IG51bTphbnkgPSAoTnVtYmVyKHByb3BzLnJvd1snYmlsbGVkJ10ucmVwbGFjZSgvXFxzKy9nLCAnJykpKigxMTUvMTAwKSkudG9GaXhlZCgyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoJ2VuLVVTJywge1xuICAgICAgICAgICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMixcbiAgICAgICAgICAgICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDIsXG4gICAgICAgICAgICAgICAgdXNlR3JvdXBpbmc6IHRydWVcbiAgICAgICAgICAgICAgfSkuZm9ybWF0KG51bSkucmVwbGFjZSgvLC9nLCAnICcpO1xuICAgICAgICAgIH0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IFwiZm9yZWNhc3RcIixcbiAgICAgICAgd2lkdGg6IFwiMTUwcHhcIixcbiAgICAgICAgbmFtZTogXCJCdWRnZXQgUmVtYWluaW5nXCIsXG4gICAgICAgIHJlbmRlckVkaXRDZWxsOiB0ZXh0RWRpdG9yXG4gICAgICAgIC8vIHJlbmRlckNlbGwocHJvcHM6YW55KSB7XG4gICAgICAgIC8vICAgICByZXR1cm4gcHJvcHMucm93Wydmb3JlY2FzdCddO1xuICAgICAgICAvLyAgIH0sXG4gICAgICB9LFxuICAgIF0sXG4gIH0sXG4gIHsga2V5OiBcIjhcIiwgbmFtZTogXCIgXCIgfSxcbiAgLi4ucmVzLFxuXTtcblxuY29uc3Qgcm93cyA9IGxpc3RzO1xuY29uc29sZS5sb2cocm93cyk7XG5cbmZ1bmN0aW9uIHJvd0tleUdldHRlcihyb3c6YW55KSB7XG4gIHJldHVybiByb3cuaWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENvbHVtbkdyb3VwaW5nKHsgIH0pIHtcbiAgICBjb25zdCBbcm93c3MsIHNldFJvd3NzXSA9IHVzZVN0YXRlKHJvd3MpO1xuICAgIGNvbnN0IFtzZWxlY3RlZFJvd3MsIHNldFNlbGVjdGVkUm93c10gPSB1c2VTdGF0ZSgoKTogUmVhZG9ubHlTZXQ8bnVtYmVyPiA9PiBuZXcgU2V0KCkpO1xuICByZXR1cm4gKFxuICAgIDxEYXRhR3JpZFxuICAgICAgc3R5bGU9e3sgaGVpZ2h0OiBcIjEwMHZoXCIgfX1cbiAgICAvLyAgIHJvd0tleUdldHRlcj17cm93S2V5R2V0dGVyfVxuICAgICAgY29sdW1ucz17Y29sdW1uc31cbiAgICAgIHJvd3M9e3Jvd3NzfVxuICAgICAgb25Sb3dzQ2hhbmdlPXtzZXRSb3dzc31cbiAgICAgIG9uU2VsZWN0ZWRSb3dzQ2hhbmdlPXtzZXRTZWxlY3RlZFJvd3N9XG4gICAgICB0b3BTdW1tYXJ5Um93cz17WzBdfVxuICAgICAgYm90dG9tU3VtbWFyeVJvd3M9e1s4XX1cbiAgICAgIGNsYXNzTmFtZT1cImZpbGwtZ3JpZFwiXG4gICAgICAvLyBkaXJlY3Rpb249e2RpcmVjdGlvbn1cbiAgICAgIHNlbGVjdGVkUm93cz17c2VsZWN0ZWRSb3dzfVxuICAgICAgZGVmYXVsdENvbHVtbk9wdGlvbnM9e1xuICAgICAgICB7XG4gICAgICAgICAgLy8gcmVzaXphYmxlOiB0cnVlLFxuICAgICAgICAgIC8vIHJlbmRlckNlbGw6IHJlbmRlclxuICAgICAgICB9XG4gICAgICB9XG4gICAgLz5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJEYXRhR3JpZCIsInRleHRFZGl0b3IiLCJSZWFjdCIsInVzZVN0YXRlIiwibGlzdHMiLCJpZCIsIm5hbWUiLCJ2YWx1ZSIsImJpbGxlZCIsImZvcmVjYXN0IiwiY2FzaGZsb3ciLCJjYXNoZmxvd19tb250aGx5Iiwicm93IiwiYWdncmVnYXRlTW9udGhseVRvdGFscyIsImRhdGEiLCJtb250aGx5VG90YWxzIiwiZm9yRWFjaCIsImVudHJ5IiwiYW1vdW50IiwiZGF0ZVN0ciIsImRhdGUiLCJkYXRlT2JqIiwiRGF0ZSIsInllYXIiLCJnZXRGdWxsWWVhciIsIm1vbnRoIiwiZ2V0TW9udGgiLCJ5ZWFyTW9udGgiLCJTdHJpbmciLCJwYWRTdGFydCIsInJlc3VsdCIsIk9iamVjdCIsImtleXMiLCJzcGxpdCIsImVuZERhdGUiLCJOdW1iZXIiLCJmb3JtYXR0ZWREYXRlIiwiZm9ybWF0RGF0ZVRvQ3VzdG9tRm9ybWF0IiwibWFwIiwiZWwiLCJuZXdfZWwiLCJKU09OIiwicGFyc2UiLCJjb25zb2xlIiwibG9nIiwib3B0aW9ucyIsIkludGwiLCJEYXRlVGltZUZvcm1hdCIsImZvcm1hdCIsImdldEZpbmFuY2lhbFllYXJQZXJpb2RzIiwidG9kYXkiLCJmaW5hbmNpYWxZZWFyU3RhcnQiLCJzZXRGdWxsWWVhciIsImZpbmFuY2lhbFllYXJFbmQiLCJzZXRNb250aCIsInNldERhdGUiLCJjdXJyZW50WWVhclBlcmlvZHMiLCJwZXJpb2RTdGFydCIsImkiLCJlbmRPZk1vbnRoIiwibW9udGhFbmRlZCIsInB1c2giLCJjaGlsZHJlbiIsImtleSIsIndpZHRoIiwicmVuZGVyQ2VsbCIsInByb3BzIiwiY29sdW1uIiwicGFyZW50IiwiTnVtYmVyRm9ybWF0IiwibWluaW11bUZyYWN0aW9uRGlnaXRzIiwibWF4aW11bUZyYWN0aW9uRGlnaXRzIiwidXNlR3JvdXBpbmciLCJyZXBsYWNlIiwicmVuZGVyRWRpdENlbGwiLCJ0b3RvYWxfYnVkZ2V0IiwiYWN0dWFsIiwiZGlmZiIsInJlcyIsImNvbHVtbnMiLCJmcm96ZW4iLCJudW0iLCJ0b0ZpeGVkIiwicm93cyIsInJvd0tleUdldHRlciIsIkNvbHVtbkdyb3VwaW5nIiwicm93c3MiLCJzZXRSb3dzcyIsInNlbGVjdGVkUm93cyIsInNldFNlbGVjdGVkUm93cyIsIlNldCIsInN0eWxlIiwiaGVpZ2h0Iiwib25Sb3dzQ2hhbmdlIiwib25TZWxlY3RlZFJvd3NDaGFuZ2UiLCJ0b3BTdW1tYXJ5Um93cyIsImJvdHRvbVN1bW1hcnlSb3dzIiwiY2xhc3NOYW1lIiwiZGVmYXVsdENvbHVtbk9wdGlvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/table/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/clsx/dist/clsx.mjs":
/*!*****************************************!*\
  !*** ./node_modules/clsx/dist/clsx.mjs ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clsx: function() { return /* binding */ clsx; }\n/* harmony export */ });\nfunction r(e) {\n    var t, f, n = \"\";\n    if (\"string\" == typeof e || \"number\" == typeof e) n += e;\n    else if (\"object\" == typeof e) if (Array.isArray(e)) {\n        var o = e.length;\n        for(t = 0; t < o; t++)e[t] && (f = r(e[t])) && (n && (n += \" \"), n += f);\n    } else for(f in e)e[f] && (n && (n += \" \"), n += f);\n    return n;\n}\nfunction clsx() {\n    for(var e, t, f = 0, n = \"\", o = arguments.length; f < o; f++)(e = arguments[f]) && (t = r(e)) && (n && (n += \" \"), n += t);\n    return n;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (clsx);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLFNBQVNBLEVBQUVDLENBQUM7SUFBRSxJQUFJQyxHQUFFQyxHQUFFQyxJQUFFO0lBQUcsSUFBRyxZQUFVLE9BQU9ILEtBQUcsWUFBVSxPQUFPQSxHQUFFRyxLQUFHSDtTQUFPLElBQUcsWUFBVSxPQUFPQSxHQUFFLElBQUdJLE1BQU1DLE9BQU8sQ0FBQ0wsSUFBRztRQUFDLElBQUlNLElBQUVOLEVBQUVPLE1BQU07UUFBQyxJQUFJTixJQUFFLEdBQUVBLElBQUVLLEdBQUVMLElBQUlELENBQUMsQ0FBQ0MsRUFBRSxJQUFHQyxDQUFBQSxJQUFFSCxFQUFFQyxDQUFDLENBQUNDLEVBQUUsTUFBS0UsQ0FBQUEsS0FBSUEsQ0FBQUEsS0FBRyxHQUFFLEdBQUdBLEtBQUdELENBQUFBO0lBQUUsT0FBTSxJQUFJQSxLQUFLRixFQUFFQSxDQUFDLENBQUNFLEVBQUUsSUFBR0MsQ0FBQUEsS0FBSUEsQ0FBQUEsS0FBRyxHQUFFLEdBQUdBLEtBQUdELENBQUFBO0lBQUcsT0FBT0M7QUFBQztBQUFRLFNBQVNLO0lBQU8sSUFBSSxJQUFJUixHQUFFQyxHQUFFQyxJQUFFLEdBQUVDLElBQUUsSUFBR0csSUFBRUcsVUFBVUYsTUFBTSxFQUFDTCxJQUFFSSxHQUFFSixJQUFJLENBQUNGLElBQUVTLFNBQVMsQ0FBQ1AsRUFBRSxLQUFJRCxDQUFBQSxJQUFFRixFQUFFQyxFQUFDLEtBQUtHLENBQUFBLEtBQUlBLENBQUFBLEtBQUcsR0FBRSxHQUFHQSxLQUFHRixDQUFBQTtJQUFHLE9BQU9FO0FBQUM7QUFBQywrREFBZUssSUFBSUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubWpzP2Q5YzYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gcihlKXt2YXIgdCxmLG49XCJcIjtpZihcInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGUpbis9ZTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKEFycmF5LmlzQXJyYXkoZSkpe3ZhciBvPWUubGVuZ3RoO2Zvcih0PTA7dDxvO3QrKyllW3RdJiYoZj1yKGVbdF0pKSYmKG4mJihuKz1cIiBcIiksbis9Zil9ZWxzZSBmb3IoZiBpbiBlKWVbZl0mJihuJiYobis9XCIgXCIpLG4rPWYpO3JldHVybiBufWV4cG9ydCBmdW5jdGlvbiBjbHN4KCl7Zm9yKHZhciBlLHQsZj0wLG49XCJcIixvPWFyZ3VtZW50cy5sZW5ndGg7ZjxvO2YrKykoZT1hcmd1bWVudHNbZl0pJiYodD1yKGUpKSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGRlZmF1bHQgY2xzeDsiXSwibmFtZXMiOlsiciIsImUiLCJ0IiwiZiIsIm4iLCJBcnJheSIsImlzQXJyYXkiLCJvIiwibGVuZ3RoIiwiY2xzeCIsImFyZ3VtZW50cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/clsx/dist/clsx.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-data-grid/lib/bundle.js":
/*!****************************************************!*\
  !*** ./node_modules/react-data-grid/lib/bundle.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataGridDefaultRenderersProvider: function() { return /* binding */ DataGridDefaultRenderersProvider; },\n/* harmony export */   Row: function() { return /* binding */ RowComponent$1; },\n/* harmony export */   SELECT_COLUMN_KEY: function() { return /* binding */ SELECT_COLUMN_KEY; },\n/* harmony export */   SelectCellFormatter: function() { return /* binding */ SelectCellFormatter; },\n/* harmony export */   SelectColumn: function() { return /* binding */ SelectColumn; },\n/* harmony export */   ToggleGroup: function() { return /* binding */ ToggleGroup; },\n/* harmony export */   TreeDataGrid: function() { return /* binding */ TreeDataGrid$1; },\n/* harmony export */   \"default\": function() { return /* binding */ DataGrid$1; },\n/* harmony export */   renderCheckbox: function() { return /* binding */ renderCheckbox; },\n/* harmony export */   renderHeaderCell: function() { return /* binding */ renderHeaderCell; },\n/* harmony export */   renderSortIcon: function() { return /* binding */ renderSortIcon; },\n/* harmony export */   renderSortPriority: function() { return /* binding */ renderSortPriority; },\n/* harmony export */   renderToggleGroup: function() { return /* binding */ renderToggleGroup; },\n/* harmony export */   renderValue: function() { return /* binding */ renderValue; },\n/* harmony export */   textEditor: function() { return /* binding */ textEditor; },\n/* harmony export */   useRowSelection: function() { return /* binding */ useRowSelection; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$(), _s8 = $RefreshSig$(), _s9 = $RefreshSig$(), _s10 = $RefreshSig$(), _s11 = $RefreshSig$(), _s12 = $RefreshSig$(), _s13 = $RefreshSig$(), _s14 = $RefreshSig$(), _s15 = $RefreshSig$(), _s16 = $RefreshSig$(), _s17 = $RefreshSig$(), _s18 = $RefreshSig$(), _s19 = $RefreshSig$(), _s20 = $RefreshSig$(), _s21 = $RefreshSig$(), _s22 = $RefreshSig$(), _s23 = $RefreshSig$(), _s24 = $RefreshSig$();\n\n\n\n\nfunction getColSpan(column, lastFrozenColumnIndex, args) {\n    const colSpan = typeof column.colSpan === \"function\" ? column.colSpan(args) : 1;\n    if (Number.isInteger(colSpan) && colSpan > 1 && (!column.frozen || column.idx + colSpan - 1 <= lastFrozenColumnIndex)) {\n        return colSpan;\n    }\n    return undefined;\n}\nfunction stopPropagation(event) {\n    event.stopPropagation();\n}\nfunction scrollIntoView(element) {\n    element === null || element === void 0 ? void 0 : element.scrollIntoView({\n        inline: \"nearest\",\n        block: \"nearest\"\n    });\n}\nfunction createCellEvent(event) {\n    let defaultPrevented = false;\n    const cellEvent = {\n        ...event,\n        preventGridDefault () {\n            defaultPrevented = true;\n        },\n        isGridDefaultPrevented () {\n            return defaultPrevented;\n        }\n    };\n    Object.setPrototypeOf(cellEvent, Object.getPrototypeOf(event));\n    return cellEvent;\n}\nconst nonInputKeys = new Set([\n    \"Unidentified\",\n    \"Alt\",\n    \"AltGraph\",\n    \"CapsLock\",\n    \"Control\",\n    \"Fn\",\n    \"FnLock\",\n    \"Meta\",\n    \"NumLock\",\n    \"ScrollLock\",\n    \"Shift\",\n    \"Tab\",\n    \"ArrowDown\",\n    \"ArrowLeft\",\n    \"ArrowRight\",\n    \"ArrowUp\",\n    \"End\",\n    \"Home\",\n    \"PageDown\",\n    \"PageUp\",\n    \"Insert\",\n    \"ContextMenu\",\n    \"Escape\",\n    \"Pause\",\n    \"Play\",\n    \"PrintScreen\",\n    \"F1\",\n    \"F3\",\n    \"F4\",\n    \"F5\",\n    \"F6\",\n    \"F7\",\n    \"F8\",\n    \"F9\",\n    \"F10\",\n    \"F11\",\n    \"F12\"\n]);\nfunction isCtrlKeyHeldDown(e) {\n    return (e.ctrlKey || e.metaKey) && e.key !== \"Control\";\n}\nfunction isDefaultCellInput(event) {\n    const vKey = 86;\n    if (isCtrlKeyHeldDown(event) && event.keyCode !== vKey) return false;\n    return !nonInputKeys.has(event.key);\n}\nfunction onEditorNavigation(param) {\n    let { key, target } = param;\n    if (key === \"Tab\" && (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement || target instanceof HTMLSelectElement)) {\n        var _target_closest;\n        return ((_target_closest = target.closest(\".rdg-editor-container\")) === null || _target_closest === void 0 ? void 0 : _target_closest.querySelectorAll(\"input, textarea, select\").length) === 1;\n    }\n    return false;\n}\nconst measuringCellClassname = \"mlln6zg7-0-0-beta-46\";\nfunction renderMeasuringCells(viewportColumns) {\n    return viewportColumns.map((param)=>{\n        let { key, idx, minWidth, maxWidth } = param;\n        return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n            className: measuringCellClassname,\n            style: {\n                gridColumnStart: idx + 1,\n                minWidth,\n                maxWidth\n            },\n            \"data-measuring-cell-key\": key\n        }, key);\n    });\n}\nfunction isSelectedCellEditable(param) {\n    let { selectedPosition, columns, rows } = param;\n    const column = columns[selectedPosition.idx];\n    const row = rows[selectedPosition.rowIdx];\n    return isCellEditableUtil(column, row);\n}\nfunction isCellEditableUtil(column, row) {\n    return column.renderEditCell != null && (typeof column.editable === \"function\" ? column.editable(row) : column.editable) !== false;\n}\nfunction getSelectedCellColSpan(param) {\n    let { rows, topSummaryRows, bottomSummaryRows, rowIdx, mainHeaderRowIdx, lastFrozenColumnIndex, column } = param;\n    var _topSummaryRows_length;\n    const topSummaryRowsCount = (_topSummaryRows_length = topSummaryRows === null || topSummaryRows === void 0 ? void 0 : topSummaryRows.length) !== null && _topSummaryRows_length !== void 0 ? _topSummaryRows_length : 0;\n    if (rowIdx === mainHeaderRowIdx) {\n        return getColSpan(column, lastFrozenColumnIndex, {\n            type: \"HEADER\"\n        });\n    }\n    if (topSummaryRows && rowIdx > mainHeaderRowIdx && rowIdx <= topSummaryRowsCount + mainHeaderRowIdx) {\n        return getColSpan(column, lastFrozenColumnIndex, {\n            type: \"SUMMARY\",\n            row: topSummaryRows[rowIdx + topSummaryRowsCount]\n        });\n    }\n    if (rowIdx >= 0 && rowIdx < rows.length) {\n        const row = rows[rowIdx];\n        return getColSpan(column, lastFrozenColumnIndex, {\n            type: \"ROW\",\n            row\n        });\n    }\n    if (bottomSummaryRows) {\n        return getColSpan(column, lastFrozenColumnIndex, {\n            type: \"SUMMARY\",\n            row: bottomSummaryRows[rowIdx - rows.length]\n        });\n    }\n    return undefined;\n}\nfunction getNextSelectedCellPosition(param) {\n    let { moveUp, moveNext, cellNavigationMode, columns, colSpanColumns, rows, topSummaryRows, bottomSummaryRows, minRowIdx, mainHeaderRowIdx, maxRowIdx, currentPosition: { idx: currentIdx, rowIdx: currentRowIdx }, nextPosition, lastFrozenColumnIndex, isCellWithinBounds } = param;\n    let { idx: nextIdx, rowIdx: nextRowIdx } = nextPosition;\n    const columnsCount = columns.length;\n    const setColSpan = (moveNext)=>{\n        for (const column of colSpanColumns){\n            const colIdx = column.idx;\n            if (colIdx > nextIdx) break;\n            const colSpan = getSelectedCellColSpan({\n                rows,\n                topSummaryRows,\n                bottomSummaryRows,\n                rowIdx: nextRowIdx,\n                mainHeaderRowIdx,\n                lastFrozenColumnIndex,\n                column\n            });\n            if (colSpan && nextIdx > colIdx && nextIdx < colSpan + colIdx) {\n                nextIdx = colIdx + (moveNext ? colSpan : 0);\n                break;\n            }\n        }\n    };\n    const getParentRowIdx = (parent)=>{\n        return parent.level + mainHeaderRowIdx;\n    };\n    const setHeaderGroupColAndRowSpan = ()=>{\n        if (moveNext) {\n            const nextColumn = columns[nextIdx];\n            let parent = nextColumn.parent;\n            while(parent !== undefined){\n                const parentRowIdx = getParentRowIdx(parent);\n                if (nextRowIdx === parentRowIdx) {\n                    nextIdx = parent.idx + parent.colSpan;\n                    break;\n                }\n                parent = parent.parent;\n            }\n        } else if (moveUp) {\n            const nextColumn = columns[nextIdx];\n            let parent = nextColumn.parent;\n            let found = false;\n            while(parent !== undefined){\n                const parentRowIdx = getParentRowIdx(parent);\n                if (nextRowIdx >= parentRowIdx) {\n                    nextIdx = parent.idx;\n                    nextRowIdx = parentRowIdx;\n                    found = true;\n                    break;\n                }\n                parent = parent.parent;\n            }\n            if (!found) {\n                nextIdx = currentIdx;\n                nextRowIdx = currentRowIdx;\n            }\n        }\n    };\n    if (isCellWithinBounds(nextPosition)) {\n        setColSpan(moveNext);\n        if (nextRowIdx < mainHeaderRowIdx) {\n            setHeaderGroupColAndRowSpan();\n        }\n    }\n    if (cellNavigationMode === \"CHANGE_ROW\") {\n        const isAfterLastColumn = nextIdx === columnsCount;\n        const isBeforeFirstColumn = nextIdx === -1;\n        if (isAfterLastColumn) {\n            const isLastRow = nextRowIdx === maxRowIdx;\n            if (!isLastRow) {\n                nextIdx = 0;\n                nextRowIdx += 1;\n            }\n        } else if (isBeforeFirstColumn) {\n            const isFirstRow = nextRowIdx === minRowIdx;\n            if (!isFirstRow) {\n                nextRowIdx -= 1;\n                nextIdx = columnsCount - 1;\n            }\n            setColSpan(false);\n        }\n    }\n    if (nextRowIdx < mainHeaderRowIdx) {\n        const nextColumn = columns[nextIdx];\n        let parent = nextColumn.parent;\n        const nextParentRowIdx = nextRowIdx;\n        nextRowIdx = mainHeaderRowIdx;\n        while(parent !== undefined){\n            const parentRowIdx = getParentRowIdx(parent);\n            if (parentRowIdx >= nextParentRowIdx) {\n                nextRowIdx = parentRowIdx;\n                nextIdx = parent.idx;\n            }\n            parent = parent.parent;\n        }\n    }\n    return {\n        idx: nextIdx,\n        rowIdx: nextRowIdx\n    };\n}\nfunction canExitGrid(param) {\n    let { maxColIdx, minRowIdx, maxRowIdx, selectedPosition: { rowIdx, idx }, shiftKey } = param;\n    const atLastCellInRow = idx === maxColIdx;\n    const atFirstCellInRow = idx === 0;\n    const atLastRow = rowIdx === maxRowIdx;\n    const atFirstRow = rowIdx === minRowIdx;\n    return shiftKey ? atFirstCellInRow && atFirstRow : atLastCellInRow && atLastRow;\n}\nconst cell = \"cj343x07-0-0-beta-46\";\nconst cellClassname = \"rdg-cell \".concat(cell);\nconst cellFrozen = \"csofj7r7-0-0-beta-46\";\nconst cellFrozenClassname = \"rdg-cell-frozen \".concat(cellFrozen);\nfunction getRowStyle(rowIdx) {\n    return {\n        \"--rdg-grid-row-start\": rowIdx\n    };\n}\nfunction getHeaderCellStyle(column, rowIdx, rowSpan) {\n    const gridRowEnd = rowIdx + 1;\n    const paddingBlockStart = \"calc(\".concat(rowSpan - 1, \" * var(--rdg-header-row-height))\");\n    if (column.parent === undefined) {\n        return {\n            insetBlockStart: 0,\n            gridRowStart: 1,\n            gridRowEnd,\n            paddingBlockStart\n        };\n    }\n    return {\n        insetBlockStart: \"calc(\".concat(rowIdx - rowSpan, \" * var(--rdg-header-row-height))\"),\n        gridRowStart: gridRowEnd - rowSpan,\n        gridRowEnd,\n        paddingBlockStart\n    };\n}\nfunction getCellStyle(column) {\n    let colSpan = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n    const index = column.idx + 1;\n    return {\n        gridColumnStart: index,\n        gridColumnEnd: index + colSpan,\n        insetInlineStart: column.frozen ? \"var(--rdg-frozen-left-\".concat(column.idx, \")\") : undefined\n    };\n}\nfunction getCellClassname(column) {\n    for(var _len = arguments.length, extraClasses = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        extraClasses[_key - 1] = arguments[_key];\n    }\n    return (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(cellClassname, ...extraClasses, column.frozen && cellFrozenClassname);\n}\nconst { min, max, floor, sign, abs } = Math;\nfunction assertIsValidKeyGetter(keyGetter) {\n    if (typeof keyGetter !== \"function\") {\n        throw new Error(\"Please specify the rowKeyGetter prop to use selection\");\n    }\n}\nfunction clampColumnWidth(width, param) {\n    let { minWidth, maxWidth } = param;\n    width = max(width, minWidth);\n    if (typeof maxWidth === \"number\" && maxWidth >= minWidth) {\n        return min(width, maxWidth);\n    }\n    return width;\n}\nfunction getHeaderCellRowSpan(column, rowIdx) {\n    return column.parent === undefined ? rowIdx : column.level - column.parent.level;\n}\nconst checkboxContainer = \"c1bn88vv7-0-0-beta-46\";\nconst checkbox = \"c1qt073l7-0-0-beta-46\";\nconst checkboxClassname = \"rdg-checkbox-input \".concat(checkbox);\nfunction renderCheckbox(param) {\n    let { onChange, ...props } = param;\n    function handleChange(e) {\n        onChange(e.target.checked, e.nativeEvent.shiftKey);\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        className: checkboxContainer,\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"input\", {\n            type: \"checkbox\",\n            ...props,\n            className: checkboxClassname,\n            onChange: handleChange\n        })\n    });\n}\nconst groupCellContent = \"g1s9ylgp7-0-0-beta-46\";\nconst groupCellContentClassname = \"rdg-group-cell-content \".concat(groupCellContent);\nconst caret = \"cz54e4y7-0-0-beta-46\";\nconst caretClassname = \"rdg-caret \".concat(caret);\nfunction renderToggleGroup(props) {\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(ToggleGroup, {\n        ...props\n    });\n}\nfunction ToggleGroup(param) {\n    let { groupKey, isExpanded, tabIndex, toggleGroup } = param;\n    function handleKeyDown(param) {\n        let { key } = param;\n        if (key === \"Enter\") {\n            toggleGroup();\n        }\n    }\n    const d = isExpanded ? \"M1 1 L 7 7 L 13 1\" : \"M1 7 L 7 1 L 13 7\";\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(\"span\", {\n        className: groupCellContentClassname,\n        tabIndex: tabIndex,\n        onKeyDown: handleKeyDown,\n        children: [\n            groupKey,\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"svg\", {\n                viewBox: \"0 0 14 8\",\n                width: \"14\",\n                height: \"8\",\n                className: caretClassname,\n                \"aria-hidden\": true,\n                children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"path\", {\n                    d: d\n                })\n            })\n        ]\n    });\n}\n_c = ToggleGroup;\nfunction renderValue(props) {\n    try {\n        return props.row[props.column.key];\n    } catch (e) {\n        return null;\n    }\n}\nconst DataGridDefaultRenderersContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\nconst DataGridDefaultRenderersProvider = DataGridDefaultRenderersContext.Provider;\nfunction useDefaultRenderers() {\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DataGridDefaultRenderersContext);\n}\n_s(useDefaultRenderers, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nfunction SelectCellFormatter(param) {\n    let { value, tabIndex, disabled, onChange, \"aria-label\": ariaLabel, \"aria-labelledby\": ariaLabelledBy } = param;\n    _s1();\n    const renderCheckbox = useDefaultRenderers().renderCheckbox;\n    return renderCheckbox({\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": ariaLabelledBy,\n        tabIndex,\n        disabled,\n        checked: value,\n        onChange\n    });\n}\n_s1(SelectCellFormatter, \"a14rNTCCLYsN2sBpDkNzRee2VAA=\", false, function() {\n    return [\n        useDefaultRenderers\n    ];\n});\n_c1 = SelectCellFormatter;\nconst RowSelectionContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\nconst RowSelectionProvider = RowSelectionContext.Provider;\nconst RowSelectionChangeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\nconst RowSelectionChangeProvider = RowSelectionChangeContext.Provider;\nfunction useRowSelection() {\n    _s2();\n    const rowSelectionContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RowSelectionContext);\n    const rowSelectionChangeContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RowSelectionChangeContext);\n    if (rowSelectionContext === undefined || rowSelectionChangeContext === undefined) {\n        throw new Error(\"useRowSelection must be used within DataGrid cells\");\n    }\n    return [\n        rowSelectionContext,\n        rowSelectionChangeContext\n    ];\n}\n_s2(useRowSelection, \"aqU8GdUfJW2wMarj94NGQABJBw0=\");\nconst SELECT_COLUMN_KEY = \"select-row\";\nfunction HeaderRenderer(props) {\n    _s3();\n    const [isRowSelected, onRowSelectionChange] = useRowSelection();\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(SelectCellFormatter, {\n        \"aria-label\": \"Select All\",\n        tabIndex: props.tabIndex,\n        value: isRowSelected,\n        onChange: (checked)=>{\n            onRowSelectionChange({\n                type: \"HEADER\",\n                checked\n            });\n        }\n    });\n}\n_s3(HeaderRenderer, \"k9uFIpP/J3RmXb41UqoaNV0F7SQ=\", false, function() {\n    return [\n        useRowSelection\n    ];\n});\n_c2 = HeaderRenderer;\nfunction SelectFormatter(props) {\n    _s4();\n    const [isRowSelected, onRowSelectionChange] = useRowSelection();\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(SelectCellFormatter, {\n        \"aria-label\": \"Select\",\n        tabIndex: props.tabIndex,\n        value: isRowSelected,\n        onChange: (checked, isShiftClick)=>{\n            onRowSelectionChange({\n                type: \"ROW\",\n                row: props.row,\n                checked,\n                isShiftClick\n            });\n        }\n    });\n}\n_s4(SelectFormatter, \"k9uFIpP/J3RmXb41UqoaNV0F7SQ=\", false, function() {\n    return [\n        useRowSelection\n    ];\n});\n_c3 = SelectFormatter;\nfunction SelectGroupFormatter(props) {\n    _s5();\n    const [isRowSelected, onRowSelectionChange] = useRowSelection();\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(SelectCellFormatter, {\n        \"aria-label\": \"Select Group\",\n        tabIndex: props.tabIndex,\n        value: isRowSelected,\n        onChange: (checked)=>{\n            onRowSelectionChange({\n                type: \"ROW\",\n                row: props.row,\n                checked,\n                isShiftClick: false\n            });\n        }\n    });\n}\n_s5(SelectGroupFormatter, \"k9uFIpP/J3RmXb41UqoaNV0F7SQ=\", false, function() {\n    return [\n        useRowSelection\n    ];\n});\n_c4 = SelectGroupFormatter;\nconst SelectColumn = {\n    key: SELECT_COLUMN_KEY,\n    name: \"\",\n    width: 35,\n    minWidth: 35,\n    maxWidth: 35,\n    resizable: false,\n    sortable: false,\n    frozen: true,\n    renderHeaderCell (props) {\n        return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(HeaderRenderer, {\n            ...props\n        });\n    },\n    renderCell (props) {\n        return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(SelectFormatter, {\n            ...props\n        });\n    },\n    renderGroupCell (props) {\n        return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(SelectGroupFormatter, {\n            ...props\n        });\n    }\n};\nconst DEFAULT_COLUMN_WIDTH = \"auto\";\nconst DEFAULT_COLUMN_MIN_WIDTH = 50;\nfunction useCalculatedColumns(param) {\n    let { rawColumns, defaultColumnOptions, getColumnWidth, viewportWidth, scrollLeft, enableVirtualization } = param;\n    _s6();\n    var _defaultColumnOptions_width;\n    const defaultWidth = (_defaultColumnOptions_width = defaultColumnOptions === null || defaultColumnOptions === void 0 ? void 0 : defaultColumnOptions.width) !== null && _defaultColumnOptions_width !== void 0 ? _defaultColumnOptions_width : DEFAULT_COLUMN_WIDTH;\n    var _defaultColumnOptions_minWidth;\n    const defaultMinWidth = (_defaultColumnOptions_minWidth = defaultColumnOptions === null || defaultColumnOptions === void 0 ? void 0 : defaultColumnOptions.minWidth) !== null && _defaultColumnOptions_minWidth !== void 0 ? _defaultColumnOptions_minWidth : DEFAULT_COLUMN_MIN_WIDTH;\n    var _defaultColumnOptions_maxWidth;\n    const defaultMaxWidth = (_defaultColumnOptions_maxWidth = defaultColumnOptions === null || defaultColumnOptions === void 0 ? void 0 : defaultColumnOptions.maxWidth) !== null && _defaultColumnOptions_maxWidth !== void 0 ? _defaultColumnOptions_maxWidth : undefined;\n    var _defaultColumnOptions_renderCell;\n    const defaultCellRenderer = (_defaultColumnOptions_renderCell = defaultColumnOptions === null || defaultColumnOptions === void 0 ? void 0 : defaultColumnOptions.renderCell) !== null && _defaultColumnOptions_renderCell !== void 0 ? _defaultColumnOptions_renderCell : renderValue;\n    var _defaultColumnOptions_sortable;\n    const defaultSortable = (_defaultColumnOptions_sortable = defaultColumnOptions === null || defaultColumnOptions === void 0 ? void 0 : defaultColumnOptions.sortable) !== null && _defaultColumnOptions_sortable !== void 0 ? _defaultColumnOptions_sortable : false;\n    var _defaultColumnOptions_resizable;\n    const defaultResizable = (_defaultColumnOptions_resizable = defaultColumnOptions === null || defaultColumnOptions === void 0 ? void 0 : defaultColumnOptions.resizable) !== null && _defaultColumnOptions_resizable !== void 0 ? _defaultColumnOptions_resizable : false;\n    var _defaultColumnOptions_draggable;\n    const defaultDraggable = (_defaultColumnOptions_draggable = defaultColumnOptions === null || defaultColumnOptions === void 0 ? void 0 : defaultColumnOptions.draggable) !== null && _defaultColumnOptions_draggable !== void 0 ? _defaultColumnOptions_draggable : false;\n    const { columns, colSpanColumns, lastFrozenColumnIndex, headerRowsCount } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let lastFrozenColumnIndex = -1;\n        let headerRowsCount = 1;\n        const columns = [];\n        collectColumns(rawColumns, 1);\n        function collectColumns(rawColumns, level, parent) {\n            for (const rawColumn of rawColumns){\n                if (\"children\" in rawColumn) {\n                    const calculatedColumnParent = {\n                        name: rawColumn.name,\n                        parent,\n                        idx: -1,\n                        colSpan: 0,\n                        level: 0,\n                        headerCellClass: rawColumn.headerCellClass\n                    };\n                    collectColumns(rawColumn.children, level + 1, calculatedColumnParent);\n                    continue;\n                }\n                var _rawColumn_frozen;\n                const frozen = (_rawColumn_frozen = rawColumn.frozen) !== null && _rawColumn_frozen !== void 0 ? _rawColumn_frozen : false;\n                var _rawColumn_width, _rawColumn_minWidth, _rawColumn_maxWidth, _rawColumn_sortable, _rawColumn_resizable, _rawColumn_draggable, _rawColumn_renderCell;\n                const column = {\n                    ...rawColumn,\n                    parent,\n                    idx: 0,\n                    level: 0,\n                    frozen,\n                    width: (_rawColumn_width = rawColumn.width) !== null && _rawColumn_width !== void 0 ? _rawColumn_width : defaultWidth,\n                    minWidth: (_rawColumn_minWidth = rawColumn.minWidth) !== null && _rawColumn_minWidth !== void 0 ? _rawColumn_minWidth : defaultMinWidth,\n                    maxWidth: (_rawColumn_maxWidth = rawColumn.maxWidth) !== null && _rawColumn_maxWidth !== void 0 ? _rawColumn_maxWidth : defaultMaxWidth,\n                    sortable: (_rawColumn_sortable = rawColumn.sortable) !== null && _rawColumn_sortable !== void 0 ? _rawColumn_sortable : defaultSortable,\n                    resizable: (_rawColumn_resizable = rawColumn.resizable) !== null && _rawColumn_resizable !== void 0 ? _rawColumn_resizable : defaultResizable,\n                    draggable: (_rawColumn_draggable = rawColumn.draggable) !== null && _rawColumn_draggable !== void 0 ? _rawColumn_draggable : defaultDraggable,\n                    renderCell: (_rawColumn_renderCell = rawColumn.renderCell) !== null && _rawColumn_renderCell !== void 0 ? _rawColumn_renderCell : defaultCellRenderer\n                };\n                columns.push(column);\n                if (frozen) {\n                    lastFrozenColumnIndex++;\n                }\n                if (level > headerRowsCount) {\n                    headerRowsCount = level;\n                }\n            }\n        }\n        columns.sort((param, param1)=>{\n            let { key: aKey, frozen: frozenA } = param, { key: bKey, frozen: frozenB } = param1;\n            if (aKey === SELECT_COLUMN_KEY) return -1;\n            if (bKey === SELECT_COLUMN_KEY) return 1;\n            if (frozenA) {\n                if (frozenB) return 0;\n                return -1;\n            }\n            if (frozenB) return 1;\n            return 0;\n        });\n        const colSpanColumns = [];\n        columns.forEach((column, idx)=>{\n            column.idx = idx;\n            updateColumnParent(column, idx, 0);\n            if (column.colSpan != null) {\n                colSpanColumns.push(column);\n            }\n        });\n        return {\n            columns,\n            colSpanColumns,\n            lastFrozenColumnIndex,\n            headerRowsCount\n        };\n    }, [\n        rawColumns,\n        defaultWidth,\n        defaultMinWidth,\n        defaultMaxWidth,\n        defaultCellRenderer,\n        defaultResizable,\n        defaultSortable,\n        defaultDraggable\n    ]);\n    const { templateColumns, layoutCssVars, totalFrozenColumnWidth, columnMetrics } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const columnMetrics = new Map();\n        let left = 0;\n        let totalFrozenColumnWidth = 0;\n        const templateColumns = [];\n        for (const column of columns){\n            let width = getColumnWidth(column);\n            if (typeof width === \"number\") {\n                width = clampColumnWidth(width, column);\n            } else {\n                width = column.minWidth;\n            }\n            templateColumns.push(\"\".concat(width, \"px\"));\n            columnMetrics.set(column, {\n                width,\n                left\n            });\n            left += width;\n        }\n        if (lastFrozenColumnIndex !== -1) {\n            const columnMetric = columnMetrics.get(columns[lastFrozenColumnIndex]);\n            totalFrozenColumnWidth = columnMetric.left + columnMetric.width;\n        }\n        const layoutCssVars = {};\n        for(let i = 0; i <= lastFrozenColumnIndex; i++){\n            const column = columns[i];\n            layoutCssVars[\"--rdg-frozen-left-\".concat(column.idx)] = \"\".concat(columnMetrics.get(column).left, \"px\");\n        }\n        return {\n            templateColumns,\n            layoutCssVars,\n            totalFrozenColumnWidth,\n            columnMetrics\n        };\n    }, [\n        getColumnWidth,\n        columns,\n        lastFrozenColumnIndex\n    ]);\n    const [colOverscanStartIdx, colOverscanEndIdx] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (!enableVirtualization) {\n            return [\n                0,\n                columns.length - 1\n            ];\n        }\n        const viewportLeft = scrollLeft + totalFrozenColumnWidth;\n        const viewportRight = scrollLeft + viewportWidth;\n        const lastColIdx = columns.length - 1;\n        const firstUnfrozenColumnIdx = min(lastFrozenColumnIndex + 1, lastColIdx);\n        if (viewportLeft >= viewportRight) {\n            return [\n                firstUnfrozenColumnIdx,\n                firstUnfrozenColumnIdx\n            ];\n        }\n        let colVisibleStartIdx = firstUnfrozenColumnIdx;\n        while(colVisibleStartIdx < lastColIdx){\n            const { left, width } = columnMetrics.get(columns[colVisibleStartIdx]);\n            if (left + width > viewportLeft) {\n                break;\n            }\n            colVisibleStartIdx++;\n        }\n        let colVisibleEndIdx = colVisibleStartIdx;\n        while(colVisibleEndIdx < lastColIdx){\n            const { left, width } = columnMetrics.get(columns[colVisibleEndIdx]);\n            if (left + width >= viewportRight) {\n                break;\n            }\n            colVisibleEndIdx++;\n        }\n        const colOverscanStartIdx = max(firstUnfrozenColumnIdx, colVisibleStartIdx - 1);\n        const colOverscanEndIdx = min(lastColIdx, colVisibleEndIdx + 1);\n        return [\n            colOverscanStartIdx,\n            colOverscanEndIdx\n        ];\n    }, [\n        columnMetrics,\n        columns,\n        lastFrozenColumnIndex,\n        scrollLeft,\n        totalFrozenColumnWidth,\n        viewportWidth,\n        enableVirtualization\n    ]);\n    return {\n        columns,\n        colSpanColumns,\n        colOverscanStartIdx,\n        colOverscanEndIdx,\n        templateColumns,\n        layoutCssVars,\n        headerRowsCount,\n        lastFrozenColumnIndex,\n        totalFrozenColumnWidth\n    };\n}\n_s6(useCalculatedColumns, \"ygPLZeuHtbeScPJd1kAlCpYpiSU=\");\nfunction updateColumnParent(column, index, level) {\n    if (level < column.level) {\n        column.level = level;\n    }\n    if (column.parent !== undefined) {\n        const { parent } = column;\n        if (parent.idx === -1) {\n            parent.idx = index;\n        }\n        parent.colSpan += 1;\n        updateColumnParent(parent, index, level - 1);\n    }\n}\nconst useLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\nfunction useColumnWidths(columns, viewportColumns, templateColumns, gridRef, gridWidth, resizedColumnWidths, measuredColumnWidths, setResizedColumnWidths, setMeasuredColumnWidths, onColumnResize) {\n    _s7();\n    const prevGridWidthRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(gridWidth);\n    const columnsCanFlex = columns.length === viewportColumns.length;\n    const ignorePreviouslyMeasuredColumns = columnsCanFlex && gridWidth !== prevGridWidthRef.current;\n    const newTemplateColumns = [\n        ...templateColumns\n    ];\n    const columnsToMeasure = [];\n    for (const { key, idx, width } of viewportColumns){\n        if (typeof width === \"string\" && (ignorePreviouslyMeasuredColumns || !measuredColumnWidths.has(key)) && !resizedColumnWidths.has(key)) {\n            newTemplateColumns[idx] = width;\n            columnsToMeasure.push(key);\n        }\n    }\n    const gridTemplateColumns = newTemplateColumns.join(\" \");\n    useLayoutEffect(()=>{\n        prevGridWidthRef.current = gridWidth;\n        updateMeasuredWidths(columnsToMeasure);\n    });\n    function updateMeasuredWidths(columnsToMeasure) {\n        if (columnsToMeasure.length === 0) return;\n        setMeasuredColumnWidths((measuredColumnWidths)=>{\n            const newMeasuredColumnWidths = new Map(measuredColumnWidths);\n            let hasChanges = false;\n            for (const key of columnsToMeasure){\n                const measuredWidth = measureColumnWidth(gridRef, key);\n                hasChanges || (hasChanges = measuredWidth !== measuredColumnWidths.get(key));\n                if (measuredWidth === undefined) {\n                    newMeasuredColumnWidths.delete(key);\n                } else {\n                    newMeasuredColumnWidths.set(key, measuredWidth);\n                }\n            }\n            return hasChanges ? newMeasuredColumnWidths : measuredColumnWidths;\n        });\n    }\n    function handleColumnResize(column, nextWidth) {\n        const { key: resizingKey } = column;\n        const newTemplateColumns = [\n            ...templateColumns\n        ];\n        const columnsToMeasure = [];\n        for (const { key, idx, width } of viewportColumns){\n            if (resizingKey === key) {\n                const width = typeof nextWidth === \"number\" ? \"\".concat(nextWidth, \"px\") : nextWidth;\n                newTemplateColumns[idx] = width;\n            } else if (columnsCanFlex && typeof width === \"string\" && !resizedColumnWidths.has(key)) {\n                newTemplateColumns[idx] = width;\n                columnsToMeasure.push(key);\n            }\n        }\n        gridRef.current.style.gridTemplateColumns = newTemplateColumns.join(\" \");\n        const measuredWidth = typeof nextWidth === \"number\" ? nextWidth : measureColumnWidth(gridRef, resizingKey);\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>{\n            setResizedColumnWidths((resizedColumnWidths)=>{\n                const newResizedColumnWidths = new Map(resizedColumnWidths);\n                newResizedColumnWidths.set(resizingKey, measuredWidth);\n                return newResizedColumnWidths;\n            });\n            updateMeasuredWidths(columnsToMeasure);\n        });\n        onColumnResize === null || onColumnResize === void 0 ? void 0 : onColumnResize(column.idx, measuredWidth);\n    }\n    return {\n        gridTemplateColumns,\n        handleColumnResize\n    };\n}\n_s7(useColumnWidths, \"gUMcABS2lEQHvFqOOPlisHbgXxI=\");\nfunction measureColumnWidth(gridRef, key) {\n    var _gridRef_current;\n    const selector = '[data-measuring-cell-key=\"'.concat(CSS.escape(key), '\"]');\n    const measuringCell = (_gridRef_current = gridRef.current) === null || _gridRef_current === void 0 ? void 0 : _gridRef_current.querySelector(selector);\n    return measuringCell === null || measuringCell === void 0 ? void 0 : measuringCell.getBoundingClientRect().width;\n}\nfunction useGridDimensions() {\n    _s8();\n    const gridRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [inlineSize, setInlineSize] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n    const [blockSize, setBlockSize] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n    const [horizontalScrollbarHeight, setHorizontalScrollbarHeight] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    useLayoutEffect(()=>{\n        const { ResizeObserver } = window;\n        if (ResizeObserver == null) return;\n        const { clientWidth, clientHeight, offsetWidth, offsetHeight } = gridRef.current;\n        const { width, height } = gridRef.current.getBoundingClientRect();\n        const initialHorizontalScrollbarHeight = offsetHeight - clientHeight;\n        const initialWidth = width - offsetWidth + clientWidth;\n        const initialHeight = height - initialHorizontalScrollbarHeight;\n        setInlineSize(initialWidth);\n        setBlockSize(initialHeight);\n        setHorizontalScrollbarHeight(initialHorizontalScrollbarHeight);\n        const resizeObserver = new ResizeObserver((entries)=>{\n            const size = entries[0].contentBoxSize[0];\n            const { clientHeight, offsetHeight } = gridRef.current;\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>{\n                setInlineSize(size.inlineSize);\n                setBlockSize(size.blockSize);\n                setHorizontalScrollbarHeight(offsetHeight - clientHeight);\n            });\n        });\n        resizeObserver.observe(gridRef.current);\n        return ()=>{\n            resizeObserver.disconnect();\n        };\n    }, []);\n    return [\n        gridRef,\n        inlineSize,\n        blockSize,\n        horizontalScrollbarHeight\n    ];\n}\n_s8(useGridDimensions, \"+8x4gQ8p4rspMyXvDUC/d1/xApI=\");\nfunction useLatestFunc(fn) {\n    _s9();\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(fn);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = fn;\n    });\n    const callbackFn = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        ref.current(...args);\n    }, []);\n    return fn ? callbackFn : fn;\n}\n_s9(useLatestFunc, \"rxO4L95aXDxN9hGhw3hvuJn02rE=\");\nfunction useRovingTabIndex(isSelected) {\n    _s10();\n    const [isChildFocused, setIsChildFocused] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    if (isChildFocused && !isSelected) {\n        setIsChildFocused(false);\n    }\n    function onFocus(event) {\n        if (event.target !== event.currentTarget) {\n            setIsChildFocused(true);\n        }\n    }\n    const isFocusable = isSelected && !isChildFocused;\n    return {\n        tabIndex: isFocusable ? 0 : -1,\n        childTabIndex: isSelected ? 0 : -1,\n        onFocus: isSelected ? onFocus : undefined\n    };\n}\n_s10(useRovingTabIndex, \"BR7c3T7Bygfa08k6NaJzlxd+yKU=\");\nfunction useViewportColumns(param) {\n    let { columns, colSpanColumns, rows, topSummaryRows, bottomSummaryRows, colOverscanStartIdx, colOverscanEndIdx, lastFrozenColumnIndex, rowOverscanStartIdx, rowOverscanEndIdx } = param;\n    _s11();\n    const startIdx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (colOverscanStartIdx === 0) return 0;\n        let startIdx = colOverscanStartIdx;\n        const updateStartIdx = (colIdx, colSpan)=>{\n            if (colSpan !== undefined && colIdx + colSpan > colOverscanStartIdx) {\n                startIdx = colIdx;\n                return true;\n            }\n            return false;\n        };\n        for (const column of colSpanColumns){\n            const colIdx = column.idx;\n            if (colIdx >= startIdx) break;\n            if (updateStartIdx(colIdx, getColSpan(column, lastFrozenColumnIndex, {\n                type: \"HEADER\"\n            }))) {\n                break;\n            }\n            for(let rowIdx = rowOverscanStartIdx; rowIdx <= rowOverscanEndIdx; rowIdx++){\n                const row = rows[rowIdx];\n                if (updateStartIdx(colIdx, getColSpan(column, lastFrozenColumnIndex, {\n                    type: \"ROW\",\n                    row\n                }))) {\n                    break;\n                }\n            }\n            if (topSummaryRows != null) {\n                for (const row of topSummaryRows){\n                    if (updateStartIdx(colIdx, getColSpan(column, lastFrozenColumnIndex, {\n                        type: \"SUMMARY\",\n                        row\n                    }))) {\n                        break;\n                    }\n                }\n            }\n            if (bottomSummaryRows != null) {\n                for (const row of bottomSummaryRows){\n                    if (updateStartIdx(colIdx, getColSpan(column, lastFrozenColumnIndex, {\n                        type: \"SUMMARY\",\n                        row\n                    }))) {\n                        break;\n                    }\n                }\n            }\n        }\n        return startIdx;\n    }, [\n        rowOverscanStartIdx,\n        rowOverscanEndIdx,\n        rows,\n        topSummaryRows,\n        bottomSummaryRows,\n        colOverscanStartIdx,\n        lastFrozenColumnIndex,\n        colSpanColumns\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const viewportColumns = [];\n        for(let colIdx = 0; colIdx <= colOverscanEndIdx; colIdx++){\n            const column = columns[colIdx];\n            if (colIdx < startIdx && !column.frozen) continue;\n            viewportColumns.push(column);\n        }\n        return viewportColumns;\n    }, [\n        startIdx,\n        colOverscanEndIdx,\n        columns\n    ]);\n}\n_s11(useViewportColumns, \"S7a5BAsXWjdmUyumXGHlWyhhSUo=\");\nfunction useViewportRows(param) {\n    let { rows, rowHeight, clientHeight, scrollTop, enableVirtualization } = param;\n    _s12();\n    const { totalRowHeight, gridTemplateRows, getRowTop, getRowHeight, findRowIdx } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (typeof rowHeight === \"number\") {\n            return {\n                totalRowHeight: rowHeight * rows.length,\n                gridTemplateRows: \" repeat(\".concat(rows.length, \", \").concat(rowHeight, \"px)\"),\n                getRowTop: (rowIdx)=>rowIdx * rowHeight,\n                getRowHeight: ()=>rowHeight,\n                findRowIdx: (offset)=>floor(offset / rowHeight)\n            };\n        }\n        let totalRowHeight = 0;\n        let gridTemplateRows = \" \";\n        const rowPositions = rows.map((row)=>{\n            const currentRowHeight = rowHeight(row);\n            const position = {\n                top: totalRowHeight,\n                height: currentRowHeight\n            };\n            gridTemplateRows += \"\".concat(currentRowHeight, \"px \");\n            totalRowHeight += currentRowHeight;\n            return position;\n        });\n        const validateRowIdx = (rowIdx)=>{\n            return max(0, min(rows.length - 1, rowIdx));\n        };\n        return {\n            totalRowHeight,\n            gridTemplateRows,\n            getRowTop: (rowIdx)=>rowPositions[validateRowIdx(rowIdx)].top,\n            getRowHeight: (rowIdx)=>rowPositions[validateRowIdx(rowIdx)].height,\n            findRowIdx (offset) {\n                let start = 0;\n                let end = rowPositions.length - 1;\n                while(start <= end){\n                    const middle = start + floor((end - start) / 2);\n                    const currentOffset = rowPositions[middle].top;\n                    if (currentOffset === offset) return middle;\n                    if (currentOffset < offset) {\n                        start = middle + 1;\n                    } else if (currentOffset > offset) {\n                        end = middle - 1;\n                    }\n                    if (start > end) return end;\n                }\n                return 0;\n            }\n        };\n    }, [\n        rowHeight,\n        rows\n    ]);\n    let rowOverscanStartIdx = 0;\n    let rowOverscanEndIdx = rows.length - 1;\n    if (enableVirtualization) {\n        const overscanThreshold = 4;\n        const rowVisibleStartIdx = findRowIdx(scrollTop);\n        const rowVisibleEndIdx = findRowIdx(scrollTop + clientHeight);\n        rowOverscanStartIdx = max(0, rowVisibleStartIdx - overscanThreshold);\n        rowOverscanEndIdx = min(rows.length - 1, rowVisibleEndIdx + overscanThreshold);\n    }\n    return {\n        rowOverscanStartIdx,\n        rowOverscanEndIdx,\n        totalRowHeight,\n        gridTemplateRows,\n        getRowTop,\n        getRowHeight,\n        findRowIdx\n    };\n}\n_s12(useViewportRows, \"KjOuaX+3pYy8RpaOlI0viFP3teQ=\");\nconst cellDragHandle = \"c1w9bbhr7-0-0-beta-46\";\nconst cellDragHandleFrozenClassname = \"c1creorc7-0-0-beta-46\";\nconst cellDragHandleClassname = \"rdg-cell-drag-handle \".concat(cellDragHandle);\nfunction DragHandle(param) {\n    let { gridRowStart, rows, column, columnWidth, maxColIdx, isLastRow, selectedPosition, latestDraggedOverRowIdx, isCellEditable, onRowsChange, onFill, onClick, setDragging, setDraggedOverRowIdx } = param;\n    const { idx, rowIdx } = selectedPosition;\n    function handleMouseDown(event) {\n        event.preventDefault();\n        if (event.buttons !== 1) return;\n        setDragging(true);\n        window.addEventListener(\"mouseover\", onMouseOver);\n        window.addEventListener(\"mouseup\", onMouseUp);\n        function onMouseOver(event) {\n            if (event.buttons !== 1) onMouseUp();\n        }\n        function onMouseUp() {\n            window.removeEventListener(\"mouseover\", onMouseOver);\n            window.removeEventListener(\"mouseup\", onMouseUp);\n            setDragging(false);\n            handleDragEnd();\n        }\n    }\n    function handleDragEnd() {\n        const overRowIdx = latestDraggedOverRowIdx.current;\n        if (overRowIdx === undefined) return;\n        const startRowIndex = rowIdx < overRowIdx ? rowIdx + 1 : overRowIdx;\n        const endRowIndex = rowIdx < overRowIdx ? overRowIdx + 1 : rowIdx;\n        updateRows(startRowIndex, endRowIndex);\n        setDraggedOverRowIdx(undefined);\n    }\n    function handleDoubleClick(event) {\n        event.stopPropagation();\n        updateRows(rowIdx + 1, rows.length);\n    }\n    function updateRows(startRowIdx, endRowIdx) {\n        const sourceRow = rows[rowIdx];\n        const updatedRows = [\n            ...rows\n        ];\n        const indexes = [];\n        for(let i = startRowIdx; i < endRowIdx; i++){\n            if (isCellEditable({\n                rowIdx: i,\n                idx\n            })) {\n                const updatedRow = onFill({\n                    columnKey: column.key,\n                    sourceRow,\n                    targetRow: rows[i]\n                });\n                if (updatedRow !== rows[i]) {\n                    updatedRows[i] = updatedRow;\n                    indexes.push(i);\n                }\n            }\n        }\n        if (indexes.length > 0) {\n            onRowsChange === null || onRowsChange === void 0 ? void 0 : onRowsChange(updatedRows, {\n                indexes,\n                column\n            });\n        }\n    }\n    function getStyle() {\n        var _column_colSpan;\n        var _column_colSpan1;\n        const colSpan = (_column_colSpan1 = (_column_colSpan = column.colSpan) === null || _column_colSpan === void 0 ? void 0 : _column_colSpan.call(column, {\n            type: \"ROW\",\n            row: rows[rowIdx]\n        })) !== null && _column_colSpan1 !== void 0 ? _column_colSpan1 : 1;\n        const { insetInlineStart, ...style } = getCellStyle(column, colSpan);\n        const marginEnd = \"calc(var(--rdg-drag-handle-size) * -0.5 + 1px)\";\n        const isLastColumn = column.idx + colSpan - 1 === maxColIdx;\n        return {\n            ...style,\n            gridRowStart,\n            marginInlineEnd: isLastColumn ? undefined : marginEnd,\n            marginBlockEnd: isLastRow ? undefined : marginEnd,\n            insetInlineStart: insetInlineStart ? \"calc(\".concat(insetInlineStart, \" + \").concat(columnWidth, \"px + var(--rdg-drag-handle-size) * -0.5 - 1px)\") : undefined\n        };\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        style: getStyle(),\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(cellDragHandleClassname, column.frozen && cellDragHandleFrozenClassname),\n        onClick: onClick,\n        onMouseDown: handleMouseDown,\n        onDoubleClick: handleDoubleClick\n    });\n}\n_c5 = DragHandle;\nconst cellEditing = \"cis5rrm7-0-0-beta-46\";\nfunction EditCell(param) {\n    let { column, colSpan, row, rowIdx, onRowChange, closeEditor, onKeyDown, navigate } = param;\n    var _column_editorOptions, _column_editorOptions1, _column_editorOptions2;\n    _s13();\n    const frameRequestRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n    const commitOnOutsideClick = ((_column_editorOptions = column.editorOptions) === null || _column_editorOptions === void 0 ? void 0 : _column_editorOptions.commitOnOutsideClick) !== false;\n    const commitOnOutsideMouseDown = useLatestFunc(()=>{\n        onClose(true, false);\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!commitOnOutsideClick) return;\n        function onWindowCaptureMouseDown() {\n            frameRequestRef.current = requestAnimationFrame(commitOnOutsideMouseDown);\n        }\n        addEventListener(\"mousedown\", onWindowCaptureMouseDown, {\n            capture: true\n        });\n        return ()=>{\n            removeEventListener(\"mousedown\", onWindowCaptureMouseDown, {\n                capture: true\n            });\n            cancelFrameRequest();\n        };\n    }, [\n        commitOnOutsideClick,\n        commitOnOutsideMouseDown\n    ]);\n    function cancelFrameRequest() {\n        cancelAnimationFrame(frameRequestRef.current);\n    }\n    function handleKeyDown(event) {\n        if (onKeyDown) {\n            const cellEvent = createCellEvent(event);\n            onKeyDown({\n                mode: \"EDIT\",\n                row,\n                column,\n                rowIdx,\n                navigate () {\n                    navigate(event);\n                },\n                onClose\n            }, cellEvent);\n            if (cellEvent.isGridDefaultPrevented()) return;\n        }\n        if (event.key === \"Escape\") {\n            onClose();\n        } else if (event.key === \"Enter\") {\n            onClose(true);\n        } else if (onEditorNavigation(event)) {\n            navigate(event);\n        }\n    }\n    function onClose() {\n        let commitChanges = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, shouldFocusCell = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        if (commitChanges) {\n            onRowChange(row, true, shouldFocusCell);\n        } else {\n            closeEditor(shouldFocusCell);\n        }\n    }\n    function onEditorRowChange(row) {\n        let commitChangesAndFocus = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        onRowChange(row, commitChangesAndFocus, commitChangesAndFocus);\n    }\n    const { cellClass } = column;\n    const className = getCellClassname(column, \"rdg-editor-container\", typeof cellClass === \"function\" ? cellClass(row) : cellClass, !((_column_editorOptions1 = column.editorOptions) === null || _column_editorOptions1 === void 0 ? void 0 : _column_editorOptions1.displayCellContent) && cellEditing);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        role: \"gridcell\",\n        \"aria-colindex\": column.idx + 1,\n        \"aria-colspan\": colSpan,\n        \"aria-selected\": true,\n        className: className,\n        style: getCellStyle(column, colSpan),\n        onKeyDown: handleKeyDown,\n        onMouseDownCapture: cancelFrameRequest,\n        children: column.renderEditCell != null && /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, {\n            children: [\n                column.renderEditCell({\n                    column,\n                    row,\n                    rowIdx,\n                    onRowChange: onEditorRowChange,\n                    onClose\n                }),\n                ((_column_editorOptions2 = column.editorOptions) === null || _column_editorOptions2 === void 0 ? void 0 : _column_editorOptions2.displayCellContent) && column.renderCell({\n                    column,\n                    row,\n                    rowIdx,\n                    isCellEditable: true,\n                    tabIndex: -1,\n                    onRowChange: onEditorRowChange\n                })\n            ]\n        })\n    });\n}\n_s13(EditCell, \"+QAwg0lkm4ZIIR6smN4Vh/v8K9s=\", false, function() {\n    return [\n        useLatestFunc\n    ];\n});\n_c6 = EditCell;\nfunction GroupedColumnHeaderCell(param) {\n    let { column, rowIdx, isCellSelected, selectCell } = param;\n    _s14();\n    const { tabIndex, onFocus } = useRovingTabIndex(isCellSelected);\n    const { colSpan } = column;\n    const rowSpan = getHeaderCellRowSpan(column, rowIdx);\n    const index = column.idx + 1;\n    function onClick() {\n        selectCell({\n            idx: column.idx,\n            rowIdx\n        });\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        role: \"columnheader\",\n        \"aria-colindex\": index,\n        \"aria-colspan\": colSpan,\n        \"aria-rowspan\": rowSpan,\n        \"aria-selected\": isCellSelected,\n        tabIndex: tabIndex,\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(cellClassname, column.headerCellClass),\n        style: {\n            ...getHeaderCellStyle(column, rowIdx, rowSpan),\n            gridColumnStart: index,\n            gridColumnEnd: index + colSpan\n        },\n        onFocus: onFocus,\n        onClick: onClick,\n        children: column.name\n    });\n}\n_s14(GroupedColumnHeaderCell, \"BDUIpzU7Bw3Jw6L8bt9JxpEenUk=\", false, function() {\n    return [\n        useRovingTabIndex\n    ];\n});\n_c7 = GroupedColumnHeaderCell;\nconst headerSortCellClassname = \"h44jtk67-0-0-beta-46\";\nconst headerSortName = \"hcgkhxz7-0-0-beta-46\";\nconst headerSortNameClassname = \"rdg-header-sort-name \".concat(headerSortName);\nfunction renderHeaderCell(param) {\n    let { column, sortDirection, priority } = param;\n    if (!column.sortable) return column.name;\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(SortableHeaderCell, {\n        sortDirection: sortDirection,\n        priority: priority,\n        children: column.name\n    });\n}\nfunction SortableHeaderCell(param) {\n    let { sortDirection, priority, children } = param;\n    _s15();\n    const renderSortStatus = useDefaultRenderers().renderSortStatus;\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(\"span\", {\n        className: headerSortCellClassname,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"span\", {\n                className: headerSortNameClassname,\n                children: children\n            }),\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"span\", {\n                children: renderSortStatus({\n                    sortDirection,\n                    priority\n                })\n            })\n        ]\n    });\n}\n_s15(SortableHeaderCell, \"a14rNTCCLYsN2sBpDkNzRee2VAA=\", false, function() {\n    return [\n        useDefaultRenderers\n    ];\n});\n_c8 = SortableHeaderCell;\nconst cellSortableClassname = \"c6l2wv17-0-0-beta-46\";\nconst cellResizable = \"c1kqdw7y7-0-0-beta-46\";\nconst cellResizableClassname = \"rdg-cell-resizable \".concat(cellResizable);\nconst resizeHandleClassname = \"r1y6ywlx7-0-0-beta-46\";\nconst cellDraggableClassname = \"rdg-cell-draggable\";\nconst cellDragging = \"c1bezg5o7-0-0-beta-46\";\nconst cellDraggingClassname = \"rdg-cell-dragging \".concat(cellDragging);\nconst cellOver = \"c1vc96037-0-0-beta-46\";\nconst cellOverClassname = \"rdg-cell-drag-over \".concat(cellOver);\nfunction HeaderCell(param) {\n    let { column, colSpan, rowIdx, isCellSelected, onColumnResize, onColumnsReorder, sortColumns, onSortColumnsChange, selectCell, shouldFocusGrid, direction, dragDropKey } = param;\n    _s16();\n    const [isDragging, setIsDragging] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isOver, setIsOver] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const isRtl = direction === \"rtl\";\n    const rowSpan = getHeaderCellRowSpan(column, rowIdx);\n    const { tabIndex, childTabIndex, onFocus } = useRovingTabIndex(isCellSelected);\n    const sortIndex = sortColumns === null || sortColumns === void 0 ? void 0 : sortColumns.findIndex((sort)=>sort.columnKey === column.key);\n    const sortColumn = sortIndex !== undefined && sortIndex > -1 ? sortColumns[sortIndex] : undefined;\n    const sortDirection = sortColumn === null || sortColumn === void 0 ? void 0 : sortColumn.direction;\n    const priority = sortColumn !== undefined && sortColumns.length > 1 ? sortIndex + 1 : undefined;\n    const ariaSort = sortDirection && !priority ? sortDirection === \"ASC\" ? \"ascending\" : \"descending\" : undefined;\n    const { sortable, resizable, draggable } = column;\n    const className = getCellClassname(column, column.headerCellClass, sortable && cellSortableClassname, resizable && cellResizableClassname, draggable && cellDraggableClassname, isDragging && cellDraggingClassname, isOver && cellOverClassname);\n    var _column_renderHeaderCell;\n    const renderHeaderCell$1 = (_column_renderHeaderCell = column.renderHeaderCell) !== null && _column_renderHeaderCell !== void 0 ? _column_renderHeaderCell : renderHeaderCell;\n    function onPointerDown(event) {\n        if (event.pointerType === \"mouse\" && event.buttons !== 1) {\n            return;\n        }\n        event.preventDefault();\n        const { currentTarget, pointerId } = event;\n        const headerCell = currentTarget.parentElement;\n        const { right, left } = headerCell.getBoundingClientRect();\n        const offset = isRtl ? event.clientX - left : right - event.clientX;\n        function onPointerMove(event) {\n            const { right, left } = headerCell.getBoundingClientRect();\n            const width = isRtl ? right + offset - event.clientX : event.clientX + offset - left;\n            if (width > 0) {\n                onColumnResize(column, clampColumnWidth(width, column));\n            }\n        }\n        function onLostPointerCapture() {\n            currentTarget.removeEventListener(\"pointermove\", onPointerMove);\n            currentTarget.removeEventListener(\"lostpointercapture\", onLostPointerCapture);\n        }\n        currentTarget.setPointerCapture(pointerId);\n        currentTarget.addEventListener(\"pointermove\", onPointerMove);\n        currentTarget.addEventListener(\"lostpointercapture\", onLostPointerCapture);\n    }\n    function onSort(ctrlClick) {\n        if (onSortColumnsChange == null) return;\n        const { sortDescendingFirst } = column;\n        if (sortColumn === undefined) {\n            const nextSort = {\n                columnKey: column.key,\n                direction: sortDescendingFirst ? \"DESC\" : \"ASC\"\n            };\n            onSortColumnsChange(sortColumns && ctrlClick ? [\n                ...sortColumns,\n                nextSort\n            ] : [\n                nextSort\n            ]);\n        } else {\n            let nextSortColumn;\n            if (sortDescendingFirst === true && sortDirection === \"DESC\" || sortDescendingFirst !== true && sortDirection === \"ASC\") {\n                nextSortColumn = {\n                    columnKey: column.key,\n                    direction: sortDirection === \"ASC\" ? \"DESC\" : \"ASC\"\n                };\n            }\n            if (ctrlClick) {\n                const nextSortColumns = [\n                    ...sortColumns\n                ];\n                if (nextSortColumn) {\n                    nextSortColumns[sortIndex] = nextSortColumn;\n                } else {\n                    nextSortColumns.splice(sortIndex, 1);\n                }\n                onSortColumnsChange(nextSortColumns);\n            } else {\n                onSortColumnsChange(nextSortColumn ? [\n                    nextSortColumn\n                ] : []);\n            }\n        }\n    }\n    function onClick(event) {\n        selectCell({\n            idx: column.idx,\n            rowIdx\n        });\n        if (sortable) {\n            onSort(event.ctrlKey || event.metaKey);\n        }\n    }\n    function onDoubleClick() {\n        onColumnResize(column, \"max-content\");\n    }\n    function handleFocus(event) {\n        onFocus === null || onFocus === void 0 ? void 0 : onFocus(event);\n        if (shouldFocusGrid) {\n            selectCell({\n                idx: 0,\n                rowIdx\n            });\n        }\n    }\n    function onKeyDown(event) {\n        if (event.key === \" \" || event.key === \"Enter\") {\n            event.preventDefault();\n            onSort(event.ctrlKey || event.metaKey);\n        }\n    }\n    function onDragStart(event) {\n        event.dataTransfer.setData(dragDropKey, column.key);\n        event.dataTransfer.dropEffect = \"move\";\n        setIsDragging(true);\n    }\n    function onDragEnd() {\n        setIsDragging(false);\n    }\n    function onDragOver(event) {\n        event.preventDefault();\n        event.dataTransfer.dropEffect = \"move\";\n    }\n    function onDrop(event) {\n        setIsOver(false);\n        if (event.dataTransfer.types.includes(dragDropKey)) {\n            const sourceKey = event.dataTransfer.getData(dragDropKey);\n            if (sourceKey !== column.key) {\n                event.preventDefault();\n                onColumnsReorder === null || onColumnsReorder === void 0 ? void 0 : onColumnsReorder(sourceKey, column.key);\n            }\n        }\n    }\n    function onDragEnter(event) {\n        if (isEventPertinent(event)) {\n            setIsOver(true);\n        }\n    }\n    function onDragLeave(event) {\n        if (isEventPertinent(event)) {\n            setIsOver(false);\n        }\n    }\n    let draggableProps;\n    if (draggable) {\n        draggableProps = {\n            draggable: true,\n            onDragStart,\n            onDragEnd,\n            onDragOver,\n            onDragEnter,\n            onDragLeave,\n            onDrop\n        };\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(\"div\", {\n        role: \"columnheader\",\n        \"aria-colindex\": column.idx + 1,\n        \"aria-colspan\": colSpan,\n        \"aria-rowspan\": rowSpan,\n        \"aria-selected\": isCellSelected,\n        \"aria-sort\": ariaSort,\n        tabIndex: shouldFocusGrid ? 0 : tabIndex,\n        className: className,\n        style: {\n            ...getHeaderCellStyle(column, rowIdx, rowSpan),\n            ...getCellStyle(column, colSpan)\n        },\n        onFocus: handleFocus,\n        onClick: onClick,\n        onKeyDown: sortable ? onKeyDown : undefined,\n        ...draggableProps,\n        children: [\n            renderHeaderCell$1({\n                column,\n                sortDirection,\n                priority,\n                tabIndex: childTabIndex\n            }),\n            resizable && /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n                className: resizeHandleClassname,\n                onClick: stopPropagation,\n                onDoubleClick: onDoubleClick,\n                onPointerDown: onPointerDown\n            })\n        ]\n    });\n}\n_s16(HeaderCell, \"8Lg0yy8u/L0mSTyGcfGkUEWXRtA=\", false, function() {\n    return [\n        useRovingTabIndex\n    ];\n});\n_c9 = HeaderCell;\nfunction isEventPertinent(event) {\n    const relatedTarget = event.relatedTarget;\n    return !event.currentTarget.contains(relatedTarget);\n}\nconst row = \"r1upfr807-0-0-beta-46\";\nconst rowClassname = \"rdg-row \".concat(row);\nconst rowSelected = \"r190mhd37-0-0-beta-46\";\nconst rowSelectedClassname = \"rdg-row-selected\";\nconst rowSelectedWithFrozenCell = \"r139qu9m7-0-0-beta-46\";\nconst topSummaryRowClassname = \"rdg-top-summary-row\";\nconst bottomSummaryRowClassname = \"rdg-bottom-summary-row\";\nconst headerRow = \"h10tskcx7-0-0-beta-46\";\nconst headerRowClassname = \"rdg-header-row \".concat(headerRow);\nfunction HeaderRow(param) {\n    let { rowIdx, columns, onColumnResize, onColumnsReorder, sortColumns, onSortColumnsChange, lastFrozenColumnIndex, selectedCellIdx, selectCell, shouldFocusGrid, direction } = param;\n    _s17();\n    const dragDropKey = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const cells = [];\n    for(let index = 0; index < columns.length; index++){\n        const column = columns[index];\n        const colSpan = getColSpan(column, lastFrozenColumnIndex, {\n            type: \"HEADER\"\n        });\n        if (colSpan !== undefined) {\n            index += colSpan - 1;\n        }\n        cells.push(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(HeaderCell, {\n            column: column,\n            colSpan: colSpan,\n            rowIdx: rowIdx,\n            isCellSelected: selectedCellIdx === column.idx,\n            onColumnResize: onColumnResize,\n            onColumnsReorder: onColumnsReorder,\n            onSortColumnsChange: onSortColumnsChange,\n            sortColumns: sortColumns,\n            selectCell: selectCell,\n            shouldFocusGrid: shouldFocusGrid && index === 0,\n            direction: direction,\n            dragDropKey: dragDropKey\n        }, column.key));\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        role: \"row\",\n        \"aria-rowindex\": rowIdx,\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(headerRowClassname, selectedCellIdx === -1 && rowSelectedClassname),\n        children: cells\n    });\n}\n_s17(HeaderRow, \"EumhshiMZSJF+mMVQ2IMIYc/Pio=\", false, function() {\n    return [\n        react__WEBPACK_IMPORTED_MODULE_0__.useId\n    ];\n});\n_c10 = HeaderRow;\nconst HeaderRow$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(HeaderRow);\n_c11 = HeaderRow$1;\nfunction GroupedColumnHeaderRow(param) {\n    let { rowIdx, level, columns, selectedCellIdx, selectCell } = param;\n    const cells = [];\n    const renderedParents = new Set();\n    for (const column of columns){\n        let { parent } = column;\n        if (parent === undefined) continue;\n        while(parent.level > level){\n            if (parent.parent === undefined) break;\n            parent = parent.parent;\n        }\n        if (parent.level === level && !renderedParents.has(parent)) {\n            renderedParents.add(parent);\n            const { idx } = parent;\n            cells.push(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(GroupedColumnHeaderCell, {\n                column: parent,\n                rowIdx: rowIdx,\n                isCellSelected: selectedCellIdx === idx,\n                selectCell: selectCell\n            }, idx));\n        }\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        role: \"row\",\n        \"aria-rowindex\": rowIdx,\n        className: headerRowClassname,\n        children: cells\n    });\n}\n_c12 = GroupedColumnHeaderRow;\nconst GroupedColumnHeaderRow$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(GroupedColumnHeaderRow);\n_c13 = GroupedColumnHeaderRow$1;\nconst cellCopied = \"c6ra8a37-0-0-beta-46\";\nconst cellCopiedClassname = \"rdg-cell-copied \".concat(cellCopied);\nconst cellDraggedOver = \"cq910m07-0-0-beta-46\";\nconst cellDraggedOverClassname = \"rdg-cell-dragged-over \".concat(cellDraggedOver);\nfunction Cell(param) {\n    let { column, colSpan, isCellSelected, isCopied, isDraggedOver, row, rowIdx, onClick, onDoubleClick, onContextMenu, onRowChange, selectCell, ...props } = param;\n    _s18();\n    const { tabIndex, childTabIndex, onFocus } = useRovingTabIndex(isCellSelected);\n    const { cellClass } = column;\n    const className = getCellClassname(column, typeof cellClass === \"function\" ? cellClass(row) : cellClass, isCopied && cellCopiedClassname, isDraggedOver && cellDraggedOverClassname);\n    const isEditable = isCellEditableUtil(column, row);\n    function selectCellWrapper(openEditor) {\n        selectCell({\n            rowIdx,\n            idx: column.idx\n        }, openEditor);\n    }\n    function handleClick(event) {\n        if (onClick) {\n            const cellEvent = createCellEvent(event);\n            onClick({\n                row,\n                column,\n                selectCell: selectCellWrapper\n            }, cellEvent);\n            if (cellEvent.isGridDefaultPrevented()) return;\n        }\n        selectCellWrapper();\n    }\n    function handleContextMenu(event) {\n        if (onContextMenu) {\n            const cellEvent = createCellEvent(event);\n            onContextMenu({\n                row,\n                column,\n                selectCell: selectCellWrapper\n            }, cellEvent);\n            if (cellEvent.isGridDefaultPrevented()) return;\n        }\n        selectCellWrapper();\n    }\n    function handleDoubleClick(event) {\n        if (onDoubleClick) {\n            const cellEvent = createCellEvent(event);\n            onDoubleClick({\n                row,\n                column,\n                selectCell: selectCellWrapper\n            }, cellEvent);\n            if (cellEvent.isGridDefaultPrevented()) return;\n        }\n        selectCellWrapper(true);\n    }\n    function handleRowChange(newRow) {\n        onRowChange(column, newRow);\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        role: \"gridcell\",\n        \"aria-colindex\": column.idx + 1,\n        \"aria-colspan\": colSpan,\n        \"aria-selected\": isCellSelected,\n        \"aria-readonly\": !isEditable || undefined,\n        tabIndex: tabIndex,\n        className: className,\n        style: getCellStyle(column, colSpan),\n        onClick: handleClick,\n        onDoubleClick: handleDoubleClick,\n        onContextMenu: handleContextMenu,\n        onFocus: onFocus,\n        ...props,\n        children: column.renderCell({\n            column,\n            row,\n            rowIdx,\n            isCellEditable: isEditable,\n            tabIndex: childTabIndex,\n            onRowChange: handleRowChange\n        })\n    });\n}\n_s18(Cell, \"FOlDZ5V4DEZHV3x0jfMJ8HeV7i0=\", false, function() {\n    return [\n        useRovingTabIndex\n    ];\n});\n_c14 = Cell;\nconst Cell$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(Cell);\n_c15 = Cell$1;\nfunction Row(param, ref) {\n    let { className, rowIdx, gridRowStart, selectedCellIdx, isRowSelected, copiedCellIdx, draggedOverCellIdx, lastFrozenColumnIndex, row, viewportColumns, selectedCellEditor, onCellClick, onCellDoubleClick, onCellContextMenu, rowClass, setDraggedOverRowIdx, onMouseEnter, onRowChange, selectCell, ...props } = param;\n    _s19();\n    const handleRowChange = useLatestFunc((column, newRow)=>{\n        onRowChange(column, rowIdx, newRow);\n    });\n    function handleDragEnter(event) {\n        setDraggedOverRowIdx === null || setDraggedOverRowIdx === void 0 ? void 0 : setDraggedOverRowIdx(rowIdx);\n        onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter(event);\n    }\n    className = (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(rowClassname, \"rdg-row-\".concat(rowIdx % 2 === 0 ? \"even\" : \"odd\"), rowClass === null || rowClass === void 0 ? void 0 : rowClass(row, rowIdx), className, selectedCellIdx === -1 && rowSelectedClassname);\n    const cells = [];\n    for(let index = 0; index < viewportColumns.length; index++){\n        const column = viewportColumns[index];\n        const { idx } = column;\n        const colSpan = getColSpan(column, lastFrozenColumnIndex, {\n            type: \"ROW\",\n            row\n        });\n        if (colSpan !== undefined) {\n            index += colSpan - 1;\n        }\n        const isCellSelected = selectedCellIdx === idx;\n        if (isCellSelected && selectedCellEditor) {\n            cells.push(selectedCellEditor);\n        } else {\n            cells.push(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(Cell$1, {\n                column: column,\n                colSpan: colSpan,\n                row: row,\n                rowIdx: rowIdx,\n                isCopied: copiedCellIdx === idx,\n                isDraggedOver: draggedOverCellIdx === idx,\n                isCellSelected: isCellSelected,\n                onClick: onCellClick,\n                onDoubleClick: onCellDoubleClick,\n                onContextMenu: onCellContextMenu,\n                onRowChange: handleRowChange,\n                selectCell: selectCell\n            }, column.key));\n        }\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(RowSelectionProvider, {\n        value: isRowSelected,\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n            role: \"row\",\n            ref: ref,\n            className: className,\n            onMouseEnter: handleDragEnter,\n            style: getRowStyle(gridRowStart),\n            ...props,\n            children: cells\n        })\n    });\n}\n_s19(Row, \"rbqJVGgVrLkvbE5YBy2IUhNqueM=\", false, function() {\n    return [\n        useLatestFunc\n    ];\n});\n_c16 = Row;\nconst RowComponent = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(Row));\n_c17 = RowComponent;\nconst RowComponent$1 = RowComponent;\nfunction defaultRenderRow(key, props) {\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(RowComponent, {\n        ...props\n    }, key);\n}\nfunction ScrollToCell(param) {\n    let { scrollToPosition: { idx, rowIdx }, gridElement, setScrollToCellPosition } = param;\n    _s20();\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    useLayoutEffect(()=>{\n        scrollIntoView(ref.current);\n    });\n    useLayoutEffect(()=>{\n        function removeScrollToCell() {\n            setScrollToCellPosition(null);\n        }\n        const observer = new IntersectionObserver(removeScrollToCell, {\n            root: gridElement,\n            threshold: 1.0\n        });\n        observer.observe(ref.current);\n        return ()=>{\n            observer.disconnect();\n        };\n    }, [\n        gridElement,\n        setScrollToCellPosition\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        ref: ref,\n        style: {\n            gridColumn: idx === undefined ? \"1/-1\" : idx + 1,\n            gridRow: rowIdx === undefined ? \"1/-1\" : rowIdx + 2\n        }\n    });\n}\n_s20(ScrollToCell, \"+ypmq7+0U88RCNXgpCENqaHpRy0=\");\n_c18 = ScrollToCell;\nconst arrow = \"a3ejtar7-0-0-beta-46\";\nconst arrowClassname = \"rdg-sort-arrow \".concat(arrow);\nfunction renderSortStatus(param) {\n    let { sortDirection, priority } = param;\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, {\n        children: [\n            renderSortIcon({\n                sortDirection\n            }),\n            renderSortPriority({\n                priority\n            })\n        ]\n    });\n}\nfunction renderSortIcon(param) {\n    let { sortDirection } = param;\n    if (sortDirection === undefined) return null;\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"svg\", {\n        viewBox: \"0 0 12 8\",\n        width: \"12\",\n        height: \"8\",\n        className: arrowClassname,\n        \"aria-hidden\": true,\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"path\", {\n            d: sortDirection === \"ASC\" ? \"M0 8 6 0 12 8\" : \"M0 0 6 8 12 0\"\n        })\n    });\n}\nfunction renderSortPriority(param) {\n    let { priority } = param;\n    return priority;\n}\nconst root = \"rnvodz57-0-0-beta-46\";\nconst rootClassname = \"rdg \".concat(root);\nconst viewportDragging = \"vlqv91k7-0-0-beta-46\";\nconst viewportDraggingClassname = \"rdg-viewport-dragging \".concat(viewportDragging);\nconst focusSinkClassname = \"f1lsfrzw7-0-0-beta-46\";\nconst focusSinkHeaderAndSummaryClassname = \"f1cte0lg7-0-0-beta-46\";\nconst summaryCellClassname = \"s8wc6fl7-0-0-beta-46\";\nfunction SummaryCell(param) {\n    let { column, colSpan, row, rowIdx, isCellSelected, selectCell } = param;\n    var _column_renderSummaryCell;\n    _s21();\n    const { tabIndex, childTabIndex, onFocus } = useRovingTabIndex(isCellSelected);\n    const { summaryCellClass } = column;\n    const className = getCellClassname(column, summaryCellClassname, typeof summaryCellClass === \"function\" ? summaryCellClass(row) : summaryCellClass);\n    function onClick() {\n        selectCell({\n            rowIdx,\n            idx: column.idx\n        });\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        role: \"gridcell\",\n        \"aria-colindex\": column.idx + 1,\n        \"aria-colspan\": colSpan,\n        \"aria-selected\": isCellSelected,\n        tabIndex: tabIndex,\n        className: className,\n        style: getCellStyle(column, colSpan),\n        onClick: onClick,\n        onFocus: onFocus,\n        children: (_column_renderSummaryCell = column.renderSummaryCell) === null || _column_renderSummaryCell === void 0 ? void 0 : _column_renderSummaryCell.call(column, {\n            column,\n            row,\n            tabIndex: childTabIndex\n        })\n    });\n}\n_s21(SummaryCell, \"FOlDZ5V4DEZHV3x0jfMJ8HeV7i0=\", false, function() {\n    return [\n        useRovingTabIndex\n    ];\n});\n_c19 = SummaryCell;\nconst SummaryCell$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(SummaryCell);\n_c20 = SummaryCell$1;\nconst summaryRow = \"skuhp557-0-0-beta-46\";\nconst topSummaryRow = \"tf8l5ub7-0-0-beta-46\";\nconst summaryRowClassname = \"rdg-summary-row \".concat(summaryRow);\nfunction SummaryRow(param) {\n    let { rowIdx, gridRowStart, row, viewportColumns, top, bottom, lastFrozenColumnIndex, selectedCellIdx, isTop, selectCell, \"aria-rowindex\": ariaRowIndex } = param;\n    const cells = [];\n    for(let index = 0; index < viewportColumns.length; index++){\n        const column = viewportColumns[index];\n        const colSpan = getColSpan(column, lastFrozenColumnIndex, {\n            type: \"SUMMARY\",\n            row\n        });\n        if (colSpan !== undefined) {\n            index += colSpan - 1;\n        }\n        const isCellSelected = selectedCellIdx === column.idx;\n        cells.push(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(SummaryCell$1, {\n            column: column,\n            colSpan: colSpan,\n            row: row,\n            rowIdx: rowIdx,\n            isCellSelected: isCellSelected,\n            selectCell: selectCell\n        }, column.key));\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        role: \"row\",\n        \"aria-rowindex\": ariaRowIndex,\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(rowClassname, \"rdg-row-\".concat(rowIdx % 2 === 0 ? \"even\" : \"odd\"), summaryRowClassname, isTop ? \"\".concat(topSummaryRowClassname, \" \").concat(topSummaryRow) : bottomSummaryRowClassname, selectedCellIdx === -1 && rowSelectedClassname),\n        style: {\n            ...getRowStyle(gridRowStart),\n            \"--rdg-summary-row-top\": top !== undefined ? \"\".concat(top, \"px\") : undefined,\n            \"--rdg-summary-row-bottom\": bottom !== undefined ? \"\".concat(bottom, \"px\") : undefined\n        },\n        children: cells\n    });\n}\n_c21 = SummaryRow;\nconst SummaryRow$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(SummaryRow);\n_c22 = SummaryRow$1;\nfunction DataGrid(props, ref) {\n    _s22();\n    const { columns: rawColumns, rows, topSummaryRows, bottomSummaryRows, rowKeyGetter, onRowsChange, rowHeight: rawRowHeight, headerRowHeight: rawHeaderRowHeight, summaryRowHeight: rawSummaryRowHeight, selectedRows, onSelectedRowsChange, sortColumns, onSortColumnsChange, defaultColumnOptions, onCellClick, onCellDoubleClick, onCellContextMenu, onCellKeyDown, onSelectedCellChange, onScroll, onColumnResize, onColumnsReorder, onFill, onCopy, onPaste, enableVirtualization: rawEnableVirtualization, renderers, className, style, rowClass, direction: rawDirection, role: rawRole, \"aria-label\": ariaLabel, \"aria-labelledby\": ariaLabelledBy, \"aria-describedby\": ariaDescribedBy, \"aria-rowcount\": rawAriaRowCount, \"data-testid\": testId } = props;\n    const defaultRenderers = useDefaultRenderers();\n    const role = rawRole !== null && rawRole !== void 0 ? rawRole : \"grid\";\n    const rowHeight = rawRowHeight !== null && rawRowHeight !== void 0 ? rawRowHeight : 35;\n    const headerRowHeight = rawHeaderRowHeight !== null && rawHeaderRowHeight !== void 0 ? rawHeaderRowHeight : typeof rowHeight === \"number\" ? rowHeight : 35;\n    const summaryRowHeight = rawSummaryRowHeight !== null && rawSummaryRowHeight !== void 0 ? rawSummaryRowHeight : typeof rowHeight === \"number\" ? rowHeight : 35;\n    var _renderers_renderRow, _ref;\n    const renderRow = (_ref = (_renderers_renderRow = renderers === null || renderers === void 0 ? void 0 : renderers.renderRow) !== null && _renderers_renderRow !== void 0 ? _renderers_renderRow : defaultRenderers === null || defaultRenderers === void 0 ? void 0 : defaultRenderers.renderRow) !== null && _ref !== void 0 ? _ref : defaultRenderRow;\n    var _renderers_renderSortStatus, _ref1;\n    const renderSortStatus$1 = (_ref1 = (_renderers_renderSortStatus = renderers === null || renderers === void 0 ? void 0 : renderers.renderSortStatus) !== null && _renderers_renderSortStatus !== void 0 ? _renderers_renderSortStatus : defaultRenderers === null || defaultRenderers === void 0 ? void 0 : defaultRenderers.renderSortStatus) !== null && _ref1 !== void 0 ? _ref1 : renderSortStatus;\n    var _renderers_renderCheckbox, _ref2;\n    const renderCheckbox$1 = (_ref2 = (_renderers_renderCheckbox = renderers === null || renderers === void 0 ? void 0 : renderers.renderCheckbox) !== null && _renderers_renderCheckbox !== void 0 ? _renderers_renderCheckbox : defaultRenderers === null || defaultRenderers === void 0 ? void 0 : defaultRenderers.renderCheckbox) !== null && _ref2 !== void 0 ? _ref2 : renderCheckbox;\n    var _renderers_noRowsFallback;\n    const noRowsFallback = (_renderers_noRowsFallback = renderers === null || renderers === void 0 ? void 0 : renderers.noRowsFallback) !== null && _renderers_noRowsFallback !== void 0 ? _renderers_noRowsFallback : defaultRenderers === null || defaultRenderers === void 0 ? void 0 : defaultRenderers.noRowsFallback;\n    const enableVirtualization = rawEnableVirtualization !== null && rawEnableVirtualization !== void 0 ? rawEnableVirtualization : true;\n    const direction = rawDirection !== null && rawDirection !== void 0 ? rawDirection : \"ltr\";\n    const [scrollTop, setScrollTop] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [scrollLeft, setScrollLeft] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [resizedColumnWidths, setResizedColumnWidths] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>new Map());\n    const [measuredColumnWidths, setMeasuredColumnWidths] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>new Map());\n    const [copiedCell, setCopiedCell] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isDragging, setDragging] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [draggedOverRowIdx, setOverRowIdx] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(undefined);\n    const [scrollToPosition, setScrollToPosition] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const getColumnWidth = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((column)=>{\n        var _resizedColumnWidths_get, _ref;\n        return (_ref = (_resizedColumnWidths_get = resizedColumnWidths.get(column.key)) !== null && _resizedColumnWidths_get !== void 0 ? _resizedColumnWidths_get : measuredColumnWidths.get(column.key)) !== null && _ref !== void 0 ? _ref : column.width;\n    }, [\n        measuredColumnWidths,\n        resizedColumnWidths\n    ]);\n    const [gridRef, gridWidth, gridHeight, horizontalScrollbarHeight] = useGridDimensions();\n    const { columns, colSpanColumns, lastFrozenColumnIndex, headerRowsCount, colOverscanStartIdx, colOverscanEndIdx, templateColumns, layoutCssVars, totalFrozenColumnWidth } = useCalculatedColumns({\n        rawColumns,\n        defaultColumnOptions,\n        getColumnWidth,\n        scrollLeft,\n        viewportWidth: gridWidth,\n        enableVirtualization\n    });\n    var _topSummaryRows_length;\n    const topSummaryRowsCount = (_topSummaryRows_length = topSummaryRows === null || topSummaryRows === void 0 ? void 0 : topSummaryRows.length) !== null && _topSummaryRows_length !== void 0 ? _topSummaryRows_length : 0;\n    var _bottomSummaryRows_length;\n    const bottomSummaryRowsCount = (_bottomSummaryRows_length = bottomSummaryRows === null || bottomSummaryRows === void 0 ? void 0 : bottomSummaryRows.length) !== null && _bottomSummaryRows_length !== void 0 ? _bottomSummaryRows_length : 0;\n    const summaryRowsCount = topSummaryRowsCount + bottomSummaryRowsCount;\n    const headerAndTopSummaryRowsCount = headerRowsCount + topSummaryRowsCount;\n    const groupedColumnHeaderRowsCount = headerRowsCount - 1;\n    const minRowIdx = -headerAndTopSummaryRowsCount;\n    const mainHeaderRowIdx = minRowIdx + groupedColumnHeaderRowsCount;\n    const maxRowIdx = rows.length + bottomSummaryRowsCount - 1;\n    const [selectedPosition, setSelectedPosition] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>({\n            idx: -1,\n            rowIdx: minRowIdx - 1,\n            mode: \"SELECT\"\n        }));\n    const prevSelectedPosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(selectedPosition);\n    const latestDraggedOverRowIdx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(draggedOverRowIdx);\n    const lastSelectedRowIdx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(-1);\n    const focusSinkRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const shouldFocusCellRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const isTreeGrid = role === \"treegrid\";\n    const headerRowsHeight = headerRowsCount * headerRowHeight;\n    const summaryRowsHeight = summaryRowsCount * summaryRowHeight;\n    const clientHeight = gridHeight - headerRowsHeight - summaryRowsHeight;\n    const isSelectable = selectedRows != null && onSelectedRowsChange != null;\n    const isRtl = direction === \"rtl\";\n    const leftKey = isRtl ? \"ArrowRight\" : \"ArrowLeft\";\n    const rightKey = isRtl ? \"ArrowLeft\" : \"ArrowRight\";\n    const ariaRowCount = rawAriaRowCount !== null && rawAriaRowCount !== void 0 ? rawAriaRowCount : headerRowsCount + rows.length + summaryRowsCount;\n    const defaultGridComponents = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            renderCheckbox: renderCheckbox$1,\n            renderSortStatus: renderSortStatus$1\n        }), [\n        renderCheckbox$1,\n        renderSortStatus$1\n    ]);\n    const allRowsSelected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const { length } = rows;\n        return length !== 0 && selectedRows != null && rowKeyGetter != null && selectedRows.size >= length && rows.every((row)=>selectedRows.has(rowKeyGetter(row)));\n    }, [\n        rows,\n        selectedRows,\n        rowKeyGetter\n    ]);\n    const { rowOverscanStartIdx, rowOverscanEndIdx, totalRowHeight, gridTemplateRows, getRowTop, getRowHeight, findRowIdx } = useViewportRows({\n        rows,\n        rowHeight,\n        clientHeight,\n        scrollTop,\n        enableVirtualization\n    });\n    const viewportColumns = useViewportColumns({\n        columns,\n        colSpanColumns,\n        colOverscanStartIdx,\n        colOverscanEndIdx,\n        lastFrozenColumnIndex,\n        rowOverscanStartIdx,\n        rowOverscanEndIdx,\n        rows,\n        topSummaryRows,\n        bottomSummaryRows\n    });\n    const { gridTemplateColumns, handleColumnResize } = useColumnWidths(columns, viewportColumns, templateColumns, gridRef, gridWidth, resizedColumnWidths, measuredColumnWidths, setResizedColumnWidths, setMeasuredColumnWidths, onColumnResize);\n    const minColIdx = isTreeGrid ? -1 : 0;\n    const maxColIdx = columns.length - 1;\n    const selectedCellIsWithinSelectionBounds = isCellWithinSelectionBounds(selectedPosition);\n    const selectedCellIsWithinViewportBounds = isCellWithinViewportBounds(selectedPosition);\n    const scrollHeight = headerRowHeight + totalRowHeight + summaryRowsHeight + horizontalScrollbarHeight;\n    const handleColumnResizeLatest = useLatestFunc(handleColumnResize);\n    const onColumnsReorderLastest = useLatestFunc(onColumnsReorder);\n    const onSortColumnsChangeLatest = useLatestFunc(onSortColumnsChange);\n    const onCellClickLatest = useLatestFunc(onCellClick);\n    const onCellDoubleClickLatest = useLatestFunc(onCellDoubleClick);\n    const onCellContextMenuLatest = useLatestFunc(onCellContextMenu);\n    const selectRowLatest = useLatestFunc(selectRow);\n    const handleFormatterRowChangeLatest = useLatestFunc(updateRow);\n    const selectCellLatest = useLatestFunc(selectCell);\n    const selectHeaderCellLatest = useLatestFunc((param)=>{\n        let { idx, rowIdx } = param;\n        selectCell({\n            rowIdx: minRowIdx + rowIdx - 1,\n            idx\n        });\n    });\n    useLayoutEffect(()=>{\n        if (!selectedCellIsWithinSelectionBounds || isSamePosition(selectedPosition, prevSelectedPosition.current)) {\n            prevSelectedPosition.current = selectedPosition;\n            return;\n        }\n        prevSelectedPosition.current = selectedPosition;\n        if (selectedPosition.idx === -1) {\n            focusSinkRef.current.focus({\n                preventScroll: true\n            });\n            scrollIntoView(focusSinkRef.current);\n        }\n    });\n    useLayoutEffect(()=>{\n        if (!shouldFocusCellRef.current) return;\n        shouldFocusCellRef.current = false;\n        focusCellOrCellContent();\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>({\n            element: gridRef.current,\n            scrollToCell (param) {\n                let { idx, rowIdx } = param;\n                const scrollToIdx = idx !== undefined && idx > lastFrozenColumnIndex && idx < columns.length ? idx : undefined;\n                const scrollToRowIdx = rowIdx !== undefined && isRowIdxWithinViewportBounds(rowIdx) ? rowIdx : undefined;\n                if (scrollToIdx !== undefined || scrollToRowIdx !== undefined) {\n                    setScrollToPosition({\n                        idx: scrollToIdx,\n                        rowIdx: scrollToRowIdx\n                    });\n                }\n            },\n            selectCell\n        }));\n    const setDraggedOverRowIdx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((rowIdx)=>{\n        setOverRowIdx(rowIdx);\n        latestDraggedOverRowIdx.current = rowIdx;\n    }, []);\n    function selectRow(args) {\n        if (!onSelectedRowsChange) return;\n        assertIsValidKeyGetter(rowKeyGetter);\n        if (args.type === \"HEADER\") {\n            const newSelectedRows = new Set(selectedRows);\n            for (const row of rows){\n                const rowKey = rowKeyGetter(row);\n                if (args.checked) {\n                    newSelectedRows.add(rowKey);\n                } else {\n                    newSelectedRows.delete(rowKey);\n                }\n            }\n            onSelectedRowsChange(newSelectedRows);\n            return;\n        }\n        const { row, checked, isShiftClick } = args;\n        const newSelectedRows = new Set(selectedRows);\n        const rowKey = rowKeyGetter(row);\n        const previousRowIdx = lastSelectedRowIdx.current;\n        const rowIdx = rows.indexOf(row);\n        lastSelectedRowIdx.current = rowIdx;\n        if (checked) {\n            newSelectedRows.add(rowKey);\n        } else {\n            newSelectedRows.delete(rowKey);\n        }\n        if (isShiftClick && previousRowIdx !== -1 && previousRowIdx !== rowIdx && previousRowIdx < rows.length) {\n            const step = sign(rowIdx - previousRowIdx);\n            for(let i = previousRowIdx + step; i !== rowIdx; i += step){\n                const row = rows[i];\n                if (checked) {\n                    newSelectedRows.add(rowKeyGetter(row));\n                } else {\n                    newSelectedRows.delete(rowKeyGetter(row));\n                }\n            }\n        }\n        onSelectedRowsChange(newSelectedRows);\n    }\n    function handleKeyDown(event) {\n        const { idx, rowIdx, mode } = selectedPosition;\n        if (mode === \"EDIT\") return;\n        if (onCellKeyDown && isRowIdxWithinViewportBounds(rowIdx)) {\n            const row = rows[rowIdx];\n            const cellEvent = createCellEvent(event);\n            onCellKeyDown({\n                mode: \"SELECT\",\n                row,\n                column: columns[idx],\n                rowIdx,\n                selectCell\n            }, cellEvent);\n            if (cellEvent.isGridDefaultPrevented()) return;\n        }\n        if (!(event.target instanceof Element)) return;\n        const isCellEvent = event.target.closest(\".rdg-cell\") !== null;\n        const isRowEvent = isTreeGrid && event.target === focusSinkRef.current;\n        if (!isCellEvent && !isRowEvent) return;\n        const { keyCode } = event;\n        if (selectedCellIsWithinViewportBounds && (onPaste != null || onCopy != null) && isCtrlKeyHeldDown(event)) {\n            const cKey = 67;\n            const vKey = 86;\n            if (keyCode === cKey) {\n                var _window_getSelection;\n                if (((_window_getSelection = window.getSelection()) === null || _window_getSelection === void 0 ? void 0 : _window_getSelection.isCollapsed) === false) return;\n                handleCopy();\n                return;\n            }\n            if (keyCode === vKey) {\n                handlePaste();\n                return;\n            }\n        }\n        switch(event.key){\n            case \"Escape\":\n                setCopiedCell(null);\n                return;\n            case \"ArrowUp\":\n            case \"ArrowDown\":\n            case \"ArrowLeft\":\n            case \"ArrowRight\":\n            case \"Tab\":\n            case \"Home\":\n            case \"End\":\n            case \"PageUp\":\n            case \"PageDown\":\n                navigate(event);\n                break;\n            default:\n                handleCellInput(event);\n                break;\n        }\n    }\n    function handleScroll(event) {\n        const { scrollTop, scrollLeft } = event.currentTarget;\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>{\n            setScrollTop(scrollTop);\n            setScrollLeft(abs(scrollLeft));\n        });\n        onScroll === null || onScroll === void 0 ? void 0 : onScroll(event);\n    }\n    function updateRow(column, rowIdx, row) {\n        if (typeof onRowsChange !== \"function\") return;\n        if (row === rows[rowIdx]) return;\n        const updatedRows = [\n            ...rows\n        ];\n        updatedRows[rowIdx] = row;\n        onRowsChange(updatedRows, {\n            indexes: [\n                rowIdx\n            ],\n            column\n        });\n    }\n    function commitEditorChanges() {\n        if (selectedPosition.mode !== \"EDIT\") return;\n        updateRow(columns[selectedPosition.idx], selectedPosition.rowIdx, selectedPosition.row);\n    }\n    function handleCopy() {\n        const { idx, rowIdx } = selectedPosition;\n        const sourceRow = rows[rowIdx];\n        const sourceColumnKey = columns[idx].key;\n        setCopiedCell({\n            row: sourceRow,\n            columnKey: sourceColumnKey\n        });\n        onCopy === null || onCopy === void 0 ? void 0 : onCopy({\n            sourceRow,\n            sourceColumnKey\n        });\n    }\n    function handlePaste() {\n        if (!onPaste || !onRowsChange || copiedCell === null || !isCellEditable(selectedPosition)) {\n            return;\n        }\n        const { idx, rowIdx } = selectedPosition;\n        const targetColumn = columns[idx];\n        const targetRow = rows[rowIdx];\n        const updatedTargetRow = onPaste({\n            sourceRow: copiedCell.row,\n            sourceColumnKey: copiedCell.columnKey,\n            targetRow,\n            targetColumnKey: targetColumn.key\n        });\n        updateRow(targetColumn, rowIdx, updatedTargetRow);\n    }\n    function handleCellInput(event) {\n        if (!selectedCellIsWithinViewportBounds) return;\n        const row = rows[selectedPosition.rowIdx];\n        const { key, shiftKey } = event;\n        if (isSelectable && shiftKey && key === \" \") {\n            assertIsValidKeyGetter(rowKeyGetter);\n            const rowKey = rowKeyGetter(row);\n            selectRow({\n                type: \"ROW\",\n                row,\n                checked: !selectedRows.has(rowKey),\n                isShiftClick: false\n            });\n            event.preventDefault();\n            return;\n        }\n        if (isCellEditable(selectedPosition) && isDefaultCellInput(event)) {\n            setSelectedPosition((param)=>{\n                let { idx, rowIdx } = param;\n                return {\n                    idx,\n                    rowIdx,\n                    mode: \"EDIT\",\n                    row,\n                    originalRow: row\n                };\n            });\n        }\n    }\n    function isColIdxWithinSelectionBounds(idx) {\n        return idx >= minColIdx && idx <= maxColIdx;\n    }\n    function isRowIdxWithinViewportBounds(rowIdx) {\n        return rowIdx >= 0 && rowIdx < rows.length;\n    }\n    function isCellWithinSelectionBounds(param) {\n        let { idx, rowIdx } = param;\n        return rowIdx >= minRowIdx && rowIdx <= maxRowIdx && isColIdxWithinSelectionBounds(idx);\n    }\n    function isCellWithinEditBounds(param) {\n        let { idx, rowIdx } = param;\n        return isRowIdxWithinViewportBounds(rowIdx) && idx >= 0 && idx <= maxColIdx;\n    }\n    function isCellWithinViewportBounds(param) {\n        let { idx, rowIdx } = param;\n        return isRowIdxWithinViewportBounds(rowIdx) && isColIdxWithinSelectionBounds(idx);\n    }\n    function isCellEditable(position) {\n        return isCellWithinEditBounds(position) && isSelectedCellEditable({\n            columns,\n            rows,\n            selectedPosition: position\n        });\n    }\n    function selectCell(position, enableEditor) {\n        if (!isCellWithinSelectionBounds(position)) return;\n        commitEditorChanges();\n        const row = rows[position.rowIdx];\n        const samePosition = isSamePosition(selectedPosition, position);\n        if (enableEditor && isCellEditable(position)) {\n            setSelectedPosition({\n                ...position,\n                mode: \"EDIT\",\n                row,\n                originalRow: row\n            });\n        } else if (samePosition) {\n            scrollIntoView(getCellToScroll(gridRef.current));\n        } else {\n            shouldFocusCellRef.current = true;\n            setSelectedPosition({\n                ...position,\n                mode: \"SELECT\"\n            });\n        }\n        if (onSelectedCellChange && !samePosition) {\n            onSelectedCellChange({\n                rowIdx: position.rowIdx,\n                row,\n                column: columns[position.idx]\n            });\n        }\n    }\n    function getNextPosition(key, ctrlKey, shiftKey) {\n        const { idx, rowIdx } = selectedPosition;\n        const isRowSelected = selectedCellIsWithinSelectionBounds && idx === -1;\n        switch(key){\n            case \"ArrowUp\":\n                return {\n                    idx,\n                    rowIdx: rowIdx - 1\n                };\n            case \"ArrowDown\":\n                return {\n                    idx,\n                    rowIdx: rowIdx + 1\n                };\n            case leftKey:\n                return {\n                    idx: idx - 1,\n                    rowIdx\n                };\n            case rightKey:\n                return {\n                    idx: idx + 1,\n                    rowIdx\n                };\n            case \"Tab\":\n                return {\n                    idx: idx + (shiftKey ? -1 : 1),\n                    rowIdx\n                };\n            case \"Home\":\n                if (isRowSelected) return {\n                    idx,\n                    rowIdx: minRowIdx\n                };\n                return {\n                    idx: 0,\n                    rowIdx: ctrlKey ? minRowIdx : rowIdx\n                };\n            case \"End\":\n                if (isRowSelected) return {\n                    idx,\n                    rowIdx: maxRowIdx\n                };\n                return {\n                    idx: maxColIdx,\n                    rowIdx: ctrlKey ? maxRowIdx : rowIdx\n                };\n            case \"PageUp\":\n                {\n                    if (selectedPosition.rowIdx === minRowIdx) return selectedPosition;\n                    const nextRowY = getRowTop(rowIdx) + getRowHeight(rowIdx) - clientHeight;\n                    return {\n                        idx,\n                        rowIdx: nextRowY > 0 ? findRowIdx(nextRowY) : 0\n                    };\n                }\n            case \"PageDown\":\n                {\n                    if (selectedPosition.rowIdx >= rows.length) return selectedPosition;\n                    const nextRowY = getRowTop(rowIdx) + clientHeight;\n                    return {\n                        idx,\n                        rowIdx: nextRowY < totalRowHeight ? findRowIdx(nextRowY) : rows.length - 1\n                    };\n                }\n            default:\n                return selectedPosition;\n        }\n    }\n    function navigate(event) {\n        const { key, shiftKey } = event;\n        let cellNavigationMode = \"NONE\";\n        if (key === \"Tab\") {\n            if (canExitGrid({\n                shiftKey,\n                maxColIdx,\n                minRowIdx,\n                maxRowIdx,\n                selectedPosition\n            })) {\n                commitEditorChanges();\n                return;\n            }\n            cellNavigationMode = \"CHANGE_ROW\";\n        }\n        event.preventDefault();\n        const ctrlKey = isCtrlKeyHeldDown(event);\n        const nextPosition = getNextPosition(key, ctrlKey, shiftKey);\n        if (isSamePosition(selectedPosition, nextPosition)) return;\n        const nextSelectedCellPosition = getNextSelectedCellPosition({\n            moveUp: key === \"ArrowUp\",\n            moveNext: key === rightKey || key === \"Tab\" && !shiftKey,\n            columns,\n            colSpanColumns,\n            rows,\n            topSummaryRows,\n            bottomSummaryRows,\n            minRowIdx,\n            mainHeaderRowIdx,\n            maxRowIdx,\n            lastFrozenColumnIndex,\n            cellNavigationMode,\n            currentPosition: selectedPosition,\n            nextPosition,\n            isCellWithinBounds: isCellWithinSelectionBounds\n        });\n        selectCell(nextSelectedCellPosition);\n    }\n    function getDraggedOverCellIdx(currentRowIdx) {\n        if (draggedOverRowIdx === undefined) return;\n        const { rowIdx } = selectedPosition;\n        const isDraggedOver = rowIdx < draggedOverRowIdx ? rowIdx < currentRowIdx && currentRowIdx <= draggedOverRowIdx : rowIdx > currentRowIdx && currentRowIdx >= draggedOverRowIdx;\n        return isDraggedOver ? selectedPosition.idx : undefined;\n    }\n    function focusCellOrCellContent() {\n        const cell = getCellToScroll(gridRef.current);\n        if (cell === null) return;\n        scrollIntoView(cell);\n        var _cell_querySelector;\n        const elementToFocus = (_cell_querySelector = cell.querySelector('[tabindex=\"0\"]')) !== null && _cell_querySelector !== void 0 ? _cell_querySelector : cell;\n        elementToFocus.focus({\n            preventScroll: true\n        });\n    }\n    function renderDragHandle() {\n        if (onFill == null || selectedPosition.mode === \"EDIT\" || !isCellWithinViewportBounds(selectedPosition)) {\n            return;\n        }\n        const { idx, rowIdx } = selectedPosition;\n        const column = columns[idx];\n        if (column.renderEditCell == null || column.editable === false) {\n            return;\n        }\n        const columnWidth = getColumnWidth(column);\n        return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(DragHandle, {\n            gridRowStart: headerAndTopSummaryRowsCount + rowIdx + 1,\n            rows: rows,\n            column: column,\n            columnWidth: columnWidth,\n            maxColIdx: maxColIdx,\n            isLastRow: rowIdx === maxRowIdx,\n            selectedPosition: selectedPosition,\n            isCellEditable: isCellEditable,\n            latestDraggedOverRowIdx: latestDraggedOverRowIdx,\n            onRowsChange: onRowsChange,\n            onClick: focusCellOrCellContent,\n            onFill: onFill,\n            setDragging: setDragging,\n            setDraggedOverRowIdx: setDraggedOverRowIdx\n        });\n    }\n    function getCellEditor(rowIdx) {\n        if (selectedPosition.rowIdx !== rowIdx || selectedPosition.mode === \"SELECT\") return;\n        const { idx, row } = selectedPosition;\n        const column = columns[idx];\n        const colSpan = getColSpan(column, lastFrozenColumnIndex, {\n            type: \"ROW\",\n            row\n        });\n        const closeEditor = (shouldFocusCell)=>{\n            shouldFocusCellRef.current = shouldFocusCell;\n            setSelectedPosition((param)=>{\n                let { idx, rowIdx } = param;\n                return {\n                    idx,\n                    rowIdx,\n                    mode: \"SELECT\"\n                };\n            });\n        };\n        const onRowChange = (row, commitChanges, shouldFocusCell)=>{\n            if (commitChanges) {\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>{\n                    updateRow(column, selectedPosition.rowIdx, row);\n                    closeEditor(shouldFocusCell);\n                });\n            } else {\n                setSelectedPosition((position)=>({\n                        ...position,\n                        row\n                    }));\n            }\n        };\n        if (rows[selectedPosition.rowIdx] !== selectedPosition.originalRow) {\n            closeEditor(false);\n        }\n        return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(EditCell, {\n            column: column,\n            colSpan: colSpan,\n            row: row,\n            rowIdx: rowIdx,\n            onRowChange: onRowChange,\n            closeEditor: closeEditor,\n            onKeyDown: onCellKeyDown,\n            navigate: navigate\n        }, column.key);\n    }\n    function getRowViewportColumns(rowIdx) {\n        const selectedColumn = selectedPosition.idx === -1 ? undefined : columns[selectedPosition.idx];\n        if (selectedColumn !== undefined && selectedPosition.rowIdx === rowIdx && !viewportColumns.includes(selectedColumn)) {\n            return selectedPosition.idx > colOverscanEndIdx ? [\n                ...viewportColumns,\n                selectedColumn\n            ] : [\n                ...viewportColumns.slice(0, lastFrozenColumnIndex + 1),\n                selectedColumn,\n                ...viewportColumns.slice(lastFrozenColumnIndex + 1)\n            ];\n        }\n        return viewportColumns;\n    }\n    function getViewportRows() {\n        const rowElements = [];\n        const { idx: selectedIdx, rowIdx: selectedRowIdx } = selectedPosition;\n        const startRowIdx = selectedCellIsWithinViewportBounds && selectedRowIdx < rowOverscanStartIdx ? rowOverscanStartIdx - 1 : rowOverscanStartIdx;\n        const endRowIdx = selectedCellIsWithinViewportBounds && selectedRowIdx > rowOverscanEndIdx ? rowOverscanEndIdx + 1 : rowOverscanEndIdx;\n        for(let viewportRowIdx = startRowIdx; viewportRowIdx <= endRowIdx; viewportRowIdx++){\n            const isRowOutsideViewport = viewportRowIdx === rowOverscanStartIdx - 1 || viewportRowIdx === rowOverscanEndIdx + 1;\n            const rowIdx = isRowOutsideViewport ? selectedRowIdx : viewportRowIdx;\n            let rowColumns = viewportColumns;\n            const selectedColumn = selectedIdx === -1 ? undefined : columns[selectedIdx];\n            if (selectedColumn !== undefined) {\n                if (isRowOutsideViewport) {\n                    rowColumns = [\n                        selectedColumn\n                    ];\n                } else {\n                    rowColumns = getRowViewportColumns(rowIdx);\n                }\n            }\n            const row = rows[rowIdx];\n            const gridRowStart = headerAndTopSummaryRowsCount + rowIdx + 1;\n            let key = rowIdx;\n            let isRowSelected = false;\n            if (typeof rowKeyGetter === \"function\") {\n                key = rowKeyGetter(row);\n                var _selectedRows_has;\n                isRowSelected = (_selectedRows_has = selectedRows === null || selectedRows === void 0 ? void 0 : selectedRows.has(key)) !== null && _selectedRows_has !== void 0 ? _selectedRows_has : false;\n            }\n            rowElements.push(renderRow(key, {\n                \"aria-rowindex\": headerAndTopSummaryRowsCount + rowIdx + 1,\n                \"aria-selected\": isSelectable ? isRowSelected : undefined,\n                rowIdx,\n                row,\n                viewportColumns: rowColumns,\n                isRowSelected,\n                onCellClick: onCellClickLatest,\n                onCellDoubleClick: onCellDoubleClickLatest,\n                onCellContextMenu: onCellContextMenuLatest,\n                rowClass,\n                gridRowStart,\n                copiedCellIdx: copiedCell !== null && copiedCell.row === row ? columns.findIndex((c)=>c.key === copiedCell.columnKey) : undefined,\n                selectedCellIdx: selectedRowIdx === rowIdx ? selectedIdx : undefined,\n                draggedOverCellIdx: getDraggedOverCellIdx(rowIdx),\n                setDraggedOverRowIdx: isDragging ? setDraggedOverRowIdx : undefined,\n                lastFrozenColumnIndex,\n                onRowChange: handleFormatterRowChangeLatest,\n                selectCell: selectCellLatest,\n                selectedCellEditor: getCellEditor(rowIdx)\n            }));\n        }\n        return rowElements;\n    }\n    if (selectedPosition.idx > maxColIdx || selectedPosition.rowIdx > maxRowIdx) {\n        setSelectedPosition({\n            idx: -1,\n            rowIdx: minRowIdx - 1,\n            mode: \"SELECT\"\n        });\n        setDraggedOverRowIdx(undefined);\n    }\n    let templateRows = \"repeat(\".concat(headerRowsCount, \", \").concat(headerRowHeight, \"px)\");\n    if (topSummaryRowsCount > 0) {\n        templateRows += \" repeat(\".concat(topSummaryRowsCount, \", \").concat(summaryRowHeight, \"px)\");\n    }\n    if (rows.length > 0) {\n        templateRows += gridTemplateRows;\n    }\n    if (bottomSummaryRowsCount > 0) {\n        templateRows += \" repeat(\".concat(bottomSummaryRowsCount, \", \").concat(summaryRowHeight, \"px)\");\n    }\n    const isGroupRowFocused = selectedPosition.idx === -1 && selectedPosition.rowIdx !== minRowIdx - 1;\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(\"div\", {\n        role: role,\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": ariaLabelledBy,\n        \"aria-describedby\": ariaDescribedBy,\n        \"aria-multiselectable\": isSelectable ? true : undefined,\n        \"aria-colcount\": columns.length,\n        \"aria-rowcount\": ariaRowCount,\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(rootClassname, className, isDragging && viewportDraggingClassname),\n        style: {\n            ...style,\n            scrollPaddingInlineStart: selectedPosition.idx > lastFrozenColumnIndex || (scrollToPosition === null || scrollToPosition === void 0 ? void 0 : scrollToPosition.idx) !== undefined ? \"\".concat(totalFrozenColumnWidth, \"px\") : undefined,\n            scrollPaddingBlock: isRowIdxWithinViewportBounds(selectedPosition.rowIdx) || (scrollToPosition === null || scrollToPosition === void 0 ? void 0 : scrollToPosition.rowIdx) !== undefined ? \"\".concat(headerRowsHeight + topSummaryRowsCount * summaryRowHeight, \"px \").concat(bottomSummaryRowsCount * summaryRowHeight, \"px\") : undefined,\n            gridTemplateColumns,\n            gridTemplateRows: templateRows,\n            \"--rdg-header-row-height\": \"\".concat(headerRowHeight, \"px\"),\n            \"--rdg-scroll-height\": \"\".concat(scrollHeight, \"px\"),\n            ...layoutCssVars\n        },\n        dir: direction,\n        ref: gridRef,\n        onScroll: handleScroll,\n        onKeyDown: handleKeyDown,\n        \"data-testid\": testId,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(DataGridDefaultRenderersProvider, {\n                value: defaultGridComponents,\n                children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(RowSelectionChangeProvider, {\n                    value: selectRowLatest,\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(RowSelectionProvider, {\n                            value: allRowsSelected,\n                            children: [\n                                Array.from({\n                                    length: groupedColumnHeaderRowsCount\n                                }, (_, index)=>/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(GroupedColumnHeaderRow$1, {\n                                        rowIdx: index + 1,\n                                        level: -groupedColumnHeaderRowsCount + index,\n                                        columns: getRowViewportColumns(minRowIdx + index),\n                                        selectedCellIdx: selectedPosition.rowIdx === minRowIdx + index ? selectedPosition.idx : undefined,\n                                        selectCell: selectHeaderCellLatest\n                                    }, index)),\n                                /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(HeaderRow$1, {\n                                    rowIdx: headerRowsCount,\n                                    columns: getRowViewportColumns(mainHeaderRowIdx),\n                                    onColumnResize: handleColumnResizeLatest,\n                                    onColumnsReorder: onColumnsReorderLastest,\n                                    sortColumns: sortColumns,\n                                    onSortColumnsChange: onSortColumnsChangeLatest,\n                                    lastFrozenColumnIndex: lastFrozenColumnIndex,\n                                    selectedCellIdx: selectedPosition.rowIdx === mainHeaderRowIdx ? selectedPosition.idx : undefined,\n                                    selectCell: selectHeaderCellLatest,\n                                    shouldFocusGrid: !selectedCellIsWithinSelectionBounds,\n                                    direction: direction\n                                })\n                            ]\n                        }),\n                        rows.length === 0 && noRowsFallback ? noRowsFallback : /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, {\n                            children: [\n                                topSummaryRows === null || topSummaryRows === void 0 ? void 0 : topSummaryRows.map((row, rowIdx)=>{\n                                    const gridRowStart = headerRowsCount + 1 + rowIdx;\n                                    const summaryRowIdx = mainHeaderRowIdx + 1 + rowIdx;\n                                    const isSummaryRowSelected = selectedPosition.rowIdx === summaryRowIdx;\n                                    const top = headerRowsHeight + summaryRowHeight * rowIdx;\n                                    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(SummaryRow$1, {\n                                        \"aria-rowindex\": gridRowStart,\n                                        rowIdx: summaryRowIdx,\n                                        gridRowStart: gridRowStart,\n                                        row: row,\n                                        top: top,\n                                        bottom: undefined,\n                                        viewportColumns: getRowViewportColumns(summaryRowIdx),\n                                        lastFrozenColumnIndex: lastFrozenColumnIndex,\n                                        selectedCellIdx: isSummaryRowSelected ? selectedPosition.idx : undefined,\n                                        isTop: true,\n                                        selectCell: selectCellLatest\n                                    }, rowIdx);\n                                }),\n                                getViewportRows(),\n                                bottomSummaryRows === null || bottomSummaryRows === void 0 ? void 0 : bottomSummaryRows.map((row, rowIdx)=>{\n                                    const gridRowStart = headerAndTopSummaryRowsCount + rows.length + rowIdx + 1;\n                                    const summaryRowIdx = rows.length + rowIdx;\n                                    const isSummaryRowSelected = selectedPosition.rowIdx === summaryRowIdx;\n                                    const top = clientHeight > totalRowHeight ? gridHeight - summaryRowHeight * (bottomSummaryRows.length - rowIdx) : undefined;\n                                    const bottom = top === undefined ? summaryRowHeight * (bottomSummaryRows.length - 1 - rowIdx) : undefined;\n                                    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(SummaryRow$1, {\n                                        \"aria-rowindex\": ariaRowCount - bottomSummaryRowsCount + rowIdx + 1,\n                                        rowIdx: summaryRowIdx,\n                                        gridRowStart: gridRowStart,\n                                        row: row,\n                                        top: top,\n                                        bottom: bottom,\n                                        viewportColumns: getRowViewportColumns(summaryRowIdx),\n                                        lastFrozenColumnIndex: lastFrozenColumnIndex,\n                                        selectedCellIdx: isSummaryRowSelected ? selectedPosition.idx : undefined,\n                                        isTop: false,\n                                        selectCell: selectCellLatest\n                                    }, rowIdx);\n                                })\n                            ]\n                        })\n                    ]\n                })\n            }),\n            renderDragHandle(),\n            renderMeasuringCells(viewportColumns),\n            isTreeGrid && /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n                ref: focusSinkRef,\n                tabIndex: isGroupRowFocused ? 0 : -1,\n                className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(focusSinkClassname, isGroupRowFocused && [\n                    rowSelected,\n                    lastFrozenColumnIndex !== -1 && rowSelectedWithFrozenCell\n                ], !isRowIdxWithinViewportBounds(selectedPosition.rowIdx) && focusSinkHeaderAndSummaryClassname),\n                style: {\n                    gridRowStart: selectedPosition.rowIdx + headerAndTopSummaryRowsCount + 1\n                }\n            }),\n            scrollToPosition !== null && /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(ScrollToCell, {\n                scrollToPosition: scrollToPosition,\n                setScrollToCellPosition: setScrollToPosition,\n                gridElement: gridRef.current\n            })\n        ]\n    });\n}\n_s22(DataGrid, \"TMIZZDED2s6IeHucuQK1JFZwzmk=\", false, function() {\n    return [\n        useDefaultRenderers,\n        useGridDimensions,\n        useCalculatedColumns,\n        useViewportRows,\n        useViewportColumns,\n        useColumnWidths,\n        useLatestFunc,\n        useLatestFunc,\n        useLatestFunc,\n        useLatestFunc,\n        useLatestFunc,\n        useLatestFunc,\n        useLatestFunc,\n        useLatestFunc,\n        useLatestFunc,\n        useLatestFunc\n    ];\n});\n_c23 = DataGrid;\nfunction getCellToScroll(gridEl) {\n    return gridEl.querySelector(':scope > [role=\"row\"] > [tabindex=\"0\"]');\n}\nfunction isSamePosition(p1, p2) {\n    return p1.idx === p2.idx && p1.rowIdx === p2.rowIdx;\n}\nconst DataGrid$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(DataGrid);\n_c24 = DataGrid$1;\nfunction GroupCell(param) {\n    let { id, groupKey, childRows, isExpanded, isCellSelected, column, row, groupColumnIndex, isGroupByColumn, toggleGroup: toggleGroupWrapper } = param;\n    var _column_renderGroupCell;\n    _s23();\n    const { tabIndex, childTabIndex, onFocus } = useRovingTabIndex(isCellSelected);\n    function toggleGroup() {\n        toggleGroupWrapper(id);\n    }\n    const isLevelMatching = isGroupByColumn && groupColumnIndex === column.idx;\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        role: \"gridcell\",\n        \"aria-colindex\": column.idx + 1,\n        \"aria-selected\": isCellSelected,\n        tabIndex: tabIndex,\n        className: getCellClassname(column),\n        style: {\n            ...getCellStyle(column),\n            cursor: isLevelMatching ? \"pointer\" : \"default\"\n        },\n        onClick: isLevelMatching ? toggleGroup : undefined,\n        onFocus: onFocus,\n        children: (!isGroupByColumn || isLevelMatching) && ((_column_renderGroupCell = column.renderGroupCell) === null || _column_renderGroupCell === void 0 ? void 0 : _column_renderGroupCell.call(column, {\n            groupKey,\n            childRows,\n            column,\n            row,\n            isExpanded,\n            tabIndex: childTabIndex,\n            toggleGroup\n        }))\n    }, column.key);\n}\n_s23(GroupCell, \"FOlDZ5V4DEZHV3x0jfMJ8HeV7i0=\", false, function() {\n    return [\n        useRovingTabIndex\n    ];\n});\n_c25 = GroupCell;\nconst GroupCell$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(GroupCell);\n_c26 = GroupCell$1;\nconst groupRow = \"g1yxluv37-0-0-beta-46\";\nconst groupRowClassname = \"rdg-group-row \".concat(groupRow);\nfunction GroupedRow(param) {\n    let { className, row, rowIdx, viewportColumns, selectedCellIdx, isRowSelected, selectCell, gridRowStart, groupBy, toggleGroup, ...props } = param;\n    const idx = viewportColumns[0].key === SELECT_COLUMN_KEY ? row.level + 1 : row.level;\n    function handleSelectGroup() {\n        selectCell({\n            rowIdx,\n            idx: -1\n        });\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(RowSelectionProvider, {\n        value: isRowSelected,\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n            role: \"row\",\n            \"aria-level\": row.level + 1,\n            \"aria-setsize\": row.setSize,\n            \"aria-posinset\": row.posInSet + 1,\n            \"aria-expanded\": row.isExpanded,\n            className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(rowClassname, groupRowClassname, \"rdg-row-\".concat(rowIdx % 2 === 0 ? \"even\" : \"odd\"), className, selectedCellIdx === -1 && rowSelectedClassname),\n            onClick: handleSelectGroup,\n            style: getRowStyle(gridRowStart),\n            ...props,\n            children: viewportColumns.map((column)=>/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(GroupCell$1, {\n                    id: row.id,\n                    groupKey: row.groupKey,\n                    childRows: row.childRows,\n                    isExpanded: row.isExpanded,\n                    isCellSelected: selectedCellIdx === column.idx,\n                    column: column,\n                    row: row,\n                    groupColumnIndex: idx,\n                    toggleGroup: toggleGroup,\n                    isGroupByColumn: groupBy.includes(column.key)\n                }, column.key))\n        })\n    });\n}\n_c27 = GroupedRow;\nconst GroupedRow$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(GroupedRow);\n_c28 = GroupedRow$1;\nfunction TreeDataGrid(param, ref) {\n    let { columns: rawColumns, rows: rawRows, rowHeight: rawRowHeight, rowKeyGetter: rawRowKeyGetter, onCellKeyDown: rawOnCellKeyDown, onRowsChange, selectedRows: rawSelectedRows, onSelectedRowsChange: rawOnSelectedRowsChange, renderers, groupBy: rawGroupBy, rowGrouper, expandedGroupIds, onExpandedGroupIdsChange, ...props } = param;\n    var _props_topSummaryRows, _props_topSummaryRows1, _props_bottomSummaryRows;\n    _s24();\n    const defaultRenderers = useDefaultRenderers();\n    var _renderers_renderRow, _ref;\n    const rawRenderRow = (_ref = (_renderers_renderRow = renderers === null || renderers === void 0 ? void 0 : renderers.renderRow) !== null && _renderers_renderRow !== void 0 ? _renderers_renderRow : defaultRenderers === null || defaultRenderers === void 0 ? void 0 : defaultRenderers.renderRow) !== null && _ref !== void 0 ? _ref : defaultRenderRow;\n    var _props_topSummaryRows_length;\n    const headerAndTopSummaryRowsCount = 1 + ((_props_topSummaryRows_length = (_props_topSummaryRows = props.topSummaryRows) === null || _props_topSummaryRows === void 0 ? void 0 : _props_topSummaryRows.length) !== null && _props_topSummaryRows_length !== void 0 ? _props_topSummaryRows_length : 0);\n    const isRtl = props.direction === \"rtl\";\n    const leftKey = isRtl ? \"ArrowRight\" : \"ArrowLeft\";\n    const rightKey = isRtl ? \"ArrowLeft\" : \"ArrowRight\";\n    const toggleGroupLatest = useLatestFunc(toggleGroup);\n    const { columns, groupBy } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const columns = [\n            ...rawColumns\n        ].sort((param, param1)=>{\n            let { key: aKey } = param, { key: bKey } = param1;\n            if (aKey === SELECT_COLUMN_KEY) return -1;\n            if (bKey === SELECT_COLUMN_KEY) return 1;\n            if (rawGroupBy.includes(aKey)) {\n                if (rawGroupBy.includes(bKey)) {\n                    return rawGroupBy.indexOf(aKey) - rawGroupBy.indexOf(bKey);\n                }\n                return -1;\n            }\n            if (rawGroupBy.includes(bKey)) return 1;\n            return 0;\n        });\n        const groupBy = [];\n        for (const [index, column] of columns.entries()){\n            if (rawGroupBy.includes(column.key)) {\n                groupBy.push(column.key);\n                var _column_renderGroupCell;\n                columns[index] = {\n                    ...column,\n                    frozen: true,\n                    renderCell: ()=>null,\n                    renderGroupCell: (_column_renderGroupCell = column.renderGroupCell) !== null && _column_renderGroupCell !== void 0 ? _column_renderGroupCell : renderToggleGroup,\n                    editable: false\n                };\n            }\n        }\n        return {\n            columns,\n            groupBy\n        };\n    }, [\n        rawColumns,\n        rawGroupBy\n    ]);\n    const [groupedRows, rowsCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (groupBy.length === 0) return [\n            undefined,\n            rawRows.length\n        ];\n        const groupRows = (rows, param, startRowIndex)=>{\n            let [groupByKey, ...remainingGroupByKeys] = param;\n            let groupRowsCount = 0;\n            const groups = {};\n            for (const [key, childRows] of Object.entries(rowGrouper(rows, groupByKey))){\n                const [childGroups, childRowsCount] = remainingGroupByKeys.length === 0 ? [\n                    childRows,\n                    childRows.length\n                ] : groupRows(childRows, remainingGroupByKeys, startRowIndex + groupRowsCount + 1);\n                groups[key] = {\n                    childRows,\n                    childGroups,\n                    startRowIndex: startRowIndex + groupRowsCount\n                };\n                groupRowsCount += childRowsCount + 1;\n            }\n            return [\n                groups,\n                groupRowsCount\n            ];\n        };\n        return groupRows(rawRows, groupBy, 0);\n    }, [\n        groupBy,\n        rowGrouper,\n        rawRows\n    ]);\n    const [rows, isGroupRow] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const allGroupRows = new Set();\n        if (!groupedRows) return [\n            rawRows,\n            isGroupRow\n        ];\n        const flattenedRows = [];\n        const expandGroup = (rows, parentId, level)=>{\n            if (isReadonlyArray(rows)) {\n                flattenedRows.push(...rows);\n                return;\n            }\n            Object.keys(rows).forEach((groupKey, posInSet, keys)=>{\n                const id = parentId !== undefined ? \"\".concat(parentId, \"__\").concat(groupKey) : groupKey;\n                const isExpanded = expandedGroupIds.has(id);\n                const { childRows, childGroups, startRowIndex } = rows[groupKey];\n                const groupRow = {\n                    id,\n                    parentId,\n                    groupKey,\n                    isExpanded,\n                    childRows,\n                    level,\n                    posInSet,\n                    startRowIndex,\n                    setSize: keys.length\n                };\n                flattenedRows.push(groupRow);\n                allGroupRows.add(groupRow);\n                if (isExpanded) {\n                    expandGroup(childGroups, id, level + 1);\n                }\n            });\n        };\n        expandGroup(groupedRows, undefined, 0);\n        return [\n            flattenedRows,\n            isGroupRow\n        ];\n        function isGroupRow(row) {\n            return allGroupRows.has(row);\n        }\n    }, [\n        expandedGroupIds,\n        groupedRows,\n        rawRows\n    ]);\n    const rowHeight = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (typeof rawRowHeight === \"function\") {\n            return (row)=>{\n                if (isGroupRow(row)) {\n                    return rawRowHeight({\n                        type: \"GROUP\",\n                        row\n                    });\n                }\n                return rawRowHeight({\n                    type: \"ROW\",\n                    row\n                });\n            };\n        }\n        return rawRowHeight;\n    }, [\n        isGroupRow,\n        rawRowHeight\n    ]);\n    const getParentRowAndIndex = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((row)=>{\n        const rowIdx = rows.indexOf(row);\n        for(let i = rowIdx - 1; i >= 0; i--){\n            const parentRow = rows[i];\n            if (isGroupRow(parentRow) && (!isGroupRow(row) || row.parentId === parentRow.id)) {\n                return [\n                    parentRow,\n                    i\n                ];\n            }\n        }\n        return undefined;\n    }, [\n        isGroupRow,\n        rows\n    ]);\n    const rowKeyGetter = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((row)=>{\n        if (isGroupRow(row)) {\n            return row.id;\n        }\n        if (typeof rawRowKeyGetter === \"function\") {\n            return rawRowKeyGetter(row);\n        }\n        const parentRowAndIndex = getParentRowAndIndex(row);\n        if (parentRowAndIndex !== undefined) {\n            const { startRowIndex, childRows } = parentRowAndIndex[0];\n            const groupIndex = childRows.indexOf(row);\n            return startRowIndex + groupIndex + 1;\n        }\n        return rows.indexOf(row);\n    }, [\n        getParentRowAndIndex,\n        isGroupRow,\n        rawRowKeyGetter,\n        rows\n    ]);\n    const selectedRows = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (rawSelectedRows == null) return null;\n        assertIsValidKeyGetter(rawRowKeyGetter);\n        const selectedRows = new Set(rawSelectedRows);\n        for (const row of rows){\n            if (isGroupRow(row)) {\n                const isGroupRowSelected = row.childRows.every((cr)=>rawSelectedRows.has(rawRowKeyGetter(cr)));\n                if (isGroupRowSelected) {\n                    selectedRows.add(row.id);\n                }\n            }\n        }\n        return selectedRows;\n    }, [\n        isGroupRow,\n        rawRowKeyGetter,\n        rawSelectedRows,\n        rows\n    ]);\n    function onSelectedRowsChange(newSelectedRows) {\n        if (!rawOnSelectedRowsChange) return;\n        assertIsValidKeyGetter(rawRowKeyGetter);\n        const newRawSelectedRows = new Set(rawSelectedRows);\n        for (const row of rows){\n            const key = rowKeyGetter(row);\n            if ((selectedRows === null || selectedRows === void 0 ? void 0 : selectedRows.has(key)) && !newSelectedRows.has(key)) {\n                if (isGroupRow(row)) {\n                    for (const cr of row.childRows){\n                        newRawSelectedRows.delete(rawRowKeyGetter(cr));\n                    }\n                } else {\n                    newRawSelectedRows.delete(key);\n                }\n            } else if (!(selectedRows === null || selectedRows === void 0 ? void 0 : selectedRows.has(key)) && newSelectedRows.has(key)) {\n                if (isGroupRow(row)) {\n                    for (const cr of row.childRows){\n                        newRawSelectedRows.add(rawRowKeyGetter(cr));\n                    }\n                } else {\n                    newRawSelectedRows.add(key);\n                }\n            }\n        }\n        rawOnSelectedRowsChange(newRawSelectedRows);\n    }\n    function handleKeyDown(args, event) {\n        rawOnCellKeyDown === null || rawOnCellKeyDown === void 0 ? void 0 : rawOnCellKeyDown(args, event);\n        if (event.isGridDefaultPrevented()) return;\n        if (args.mode === \"EDIT\") return;\n        const { column, rowIdx, selectCell } = args;\n        var _column_idx;\n        const idx = (_column_idx = column === null || column === void 0 ? void 0 : column.idx) !== null && _column_idx !== void 0 ? _column_idx : -1;\n        const row = rows[rowIdx];\n        if (!isGroupRow(row)) return;\n        if (idx === -1 && (event.key === leftKey && row.isExpanded || event.key === rightKey && !row.isExpanded)) {\n            event.preventDefault();\n            event.preventGridDefault();\n            toggleGroup(row.id);\n        }\n        if (idx === -1 && event.key === leftKey && !row.isExpanded && row.level !== 0) {\n            const parentRowAndIndex = getParentRowAndIndex(row);\n            if (parentRowAndIndex !== undefined) {\n                event.preventGridDefault();\n                selectCell({\n                    idx,\n                    rowIdx: parentRowAndIndex[1]\n                });\n            }\n        }\n        if (isCtrlKeyHeldDown(event) && (event.keyCode === 67 || event.keyCode === 86)) {\n            event.preventGridDefault();\n        }\n    }\n    function handleRowsChange(updatedRows, param) {\n        let { indexes, column } = param;\n        if (!onRowsChange) return;\n        const updatedRawRows = [\n            ...rawRows\n        ];\n        const rawIndexes = [];\n        for (const index of indexes){\n            const rawIndex = rawRows.indexOf(rows[index]);\n            updatedRawRows[rawIndex] = updatedRows[index];\n            rawIndexes.push(rawIndex);\n        }\n        onRowsChange(updatedRawRows, {\n            indexes: rawIndexes,\n            column\n        });\n    }\n    function toggleGroup(groupId) {\n        const newExpandedGroupIds = new Set(expandedGroupIds);\n        if (newExpandedGroupIds.has(groupId)) {\n            newExpandedGroupIds.delete(groupId);\n        } else {\n            newExpandedGroupIds.add(groupId);\n        }\n        onExpandedGroupIdsChange(newExpandedGroupIds);\n    }\n    function renderRow(key, param) {\n        let { row, rowClass, onCellClick, onCellDoubleClick, onCellContextMenu, onRowChange, lastFrozenColumnIndex, copiedCellIdx, draggedOverCellIdx, setDraggedOverRowIdx, selectedCellEditor, ...rowProps } = param;\n        if (isGroupRow(row)) {\n            const { startRowIndex } = row;\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(GroupedRow$1, {\n                ...rowProps,\n                \"aria-rowindex\": headerAndTopSummaryRowsCount + startRowIndex + 1,\n                row: row,\n                groupBy: groupBy,\n                toggleGroup: toggleGroupLatest\n            }, key);\n        }\n        let ariaRowIndex = rowProps[\"aria-rowindex\"];\n        const parentRowAndIndex = getParentRowAndIndex(row);\n        if (parentRowAndIndex !== undefined) {\n            const { startRowIndex, childRows } = parentRowAndIndex[0];\n            const groupIndex = childRows.indexOf(row);\n            ariaRowIndex = startRowIndex + headerAndTopSummaryRowsCount + groupIndex + 2;\n        }\n        return rawRenderRow(key, {\n            ...rowProps,\n            \"aria-rowindex\": ariaRowIndex,\n            row,\n            rowClass,\n            onCellClick,\n            onCellDoubleClick,\n            onCellContextMenu,\n            onRowChange,\n            lastFrozenColumnIndex,\n            copiedCellIdx,\n            draggedOverCellIdx,\n            setDraggedOverRowIdx,\n            selectedCellEditor\n        });\n    }\n    var _props_topSummaryRows_length1, _props_bottomSummaryRows_length;\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(DataGrid$1, {\n        ...props,\n        role: \"treegrid\",\n        \"aria-rowcount\": rowsCount + 1 + ((_props_topSummaryRows_length1 = (_props_topSummaryRows1 = props.topSummaryRows) === null || _props_topSummaryRows1 === void 0 ? void 0 : _props_topSummaryRows1.length) !== null && _props_topSummaryRows_length1 !== void 0 ? _props_topSummaryRows_length1 : 0) + ((_props_bottomSummaryRows_length = (_props_bottomSummaryRows = props.bottomSummaryRows) === null || _props_bottomSummaryRows === void 0 ? void 0 : _props_bottomSummaryRows.length) !== null && _props_bottomSummaryRows_length !== void 0 ? _props_bottomSummaryRows_length : 0),\n        ref: ref,\n        columns: columns,\n        rows: rows,\n        rowHeight: rowHeight,\n        rowKeyGetter: rowKeyGetter,\n        onRowsChange: handleRowsChange,\n        selectedRows: selectedRows,\n        onSelectedRowsChange: onSelectedRowsChange,\n        onCellKeyDown: handleKeyDown,\n        renderers: {\n            ...renderers,\n            renderRow\n        }\n    });\n}\n_s24(TreeDataGrid, \"zMf2CkbO7zfxaphCMGYcaDeSJY4=\", false, function() {\n    return [\n        useDefaultRenderers,\n        useLatestFunc\n    ];\n});\n_c29 = TreeDataGrid;\nfunction isReadonlyArray(arr) {\n    return Array.isArray(arr);\n}\nconst TreeDataGrid$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(TreeDataGrid);\n_c30 = TreeDataGrid$1;\nconst textEditorInternalClassname = \"t7vyx3i7-0-0-beta-46\";\nconst textEditorClassname = \"rdg-text-editor \".concat(textEditorInternalClassname);\nfunction autoFocusAndSelect(input) {\n    input === null || input === void 0 ? void 0 : input.focus();\n    input === null || input === void 0 ? void 0 : input.select();\n}\nfunction textEditor(param) {\n    let { row, column, onRowChange, onClose } = param;\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"input\", {\n        className: textEditorClassname,\n        ref: autoFocusAndSelect,\n        value: row[column.key],\n        onChange: (event)=>onRowChange({\n                ...row,\n                [column.key]: event.target.value\n            }),\n        onBlur: ()=>onClose(true, false)\n    });\n}\n //# sourceMappingURL=bundle.js.map\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11, _c12, _c13, _c14, _c15, _c16, _c17, _c18, _c19, _c20, _c21, _c22, _c23, _c24, _c25, _c26, _c27, _c28, _c29, _c30;\n$RefreshReg$(_c, \"ToggleGroup\");\n$RefreshReg$(_c1, \"SelectCellFormatter\");\n$RefreshReg$(_c2, \"HeaderRenderer\");\n$RefreshReg$(_c3, \"SelectFormatter\");\n$RefreshReg$(_c4, \"SelectGroupFormatter\");\n$RefreshReg$(_c5, \"DragHandle\");\n$RefreshReg$(_c6, \"EditCell\");\n$RefreshReg$(_c7, \"GroupedColumnHeaderCell\");\n$RefreshReg$(_c8, \"SortableHeaderCell\");\n$RefreshReg$(_c9, \"HeaderCell\");\n$RefreshReg$(_c10, \"HeaderRow\");\n$RefreshReg$(_c11, \"HeaderRow$1\");\n$RefreshReg$(_c12, \"GroupedColumnHeaderRow\");\n$RefreshReg$(_c13, \"GroupedColumnHeaderRow$1\");\n$RefreshReg$(_c14, \"Cell\");\n$RefreshReg$(_c15, \"Cell$1\");\n$RefreshReg$(_c16, \"Row\");\n$RefreshReg$(_c17, \"RowComponent\");\n$RefreshReg$(_c18, \"ScrollToCell\");\n$RefreshReg$(_c19, \"SummaryCell\");\n$RefreshReg$(_c20, \"SummaryCell$1\");\n$RefreshReg$(_c21, \"SummaryRow\");\n$RefreshReg$(_c22, \"SummaryRow$1\");\n$RefreshReg$(_c23, \"DataGrid\");\n$RefreshReg$(_c24, \"DataGrid$1\");\n$RefreshReg$(_c25, \"GroupCell\");\n$RefreshReg$(_c26, \"GroupCell$1\");\n$RefreshReg$(_c27, \"GroupedRow\");\n$RefreshReg$(_c28, \"GroupedRow$1\");\n$RefreshReg$(_c29, \"TreeDataGrid\");\n$RefreshReg$(_c30, \"TreeDataGrid$1\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1kYXRhLWdyaWQvbGliL2J1bmRsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBeUw7QUFDbko7QUFDZDtBQUNnQztBQUV4RCxTQUFTa0IsV0FBV0MsTUFBTSxFQUFFQyxxQkFBcUIsRUFBRUMsSUFBSTtJQUNyRCxNQUFNQyxVQUFVLE9BQU9ILE9BQU9HLE9BQU8sS0FBSyxhQUFhSCxPQUFPRyxPQUFPLENBQUNELFFBQVE7SUFDOUUsSUFBSUUsT0FBT0MsU0FBUyxDQUFDRixZQUFZQSxVQUFVLEtBQU0sRUFBQ0gsT0FBT00sTUFBTSxJQUFJTixPQUFPTyxHQUFHLEdBQUdKLFVBQVUsS0FBS0YscUJBQW9CLEdBQUk7UUFDckgsT0FBT0U7SUFDVDtJQUNBLE9BQU9LO0FBQ1Q7QUFFQSxTQUFTQyxnQkFBZ0JDLEtBQUs7SUFDNUJBLE1BQU1ELGVBQWU7QUFDdkI7QUFDQSxTQUFTRSxlQUFlQyxPQUFPO0lBQzdCQSxvQkFBQUEsOEJBQUFBLFFBQVNELGNBQWMsQ0FBQztRQUN0QkUsUUFBUTtRQUNSQyxPQUFPO0lBQ1Q7QUFDRjtBQUVBLFNBQVNDLGdCQUFnQkwsS0FBSztJQUM1QixJQUFJTSxtQkFBbUI7SUFDdkIsTUFBTUMsWUFBWTtRQUNoQixHQUFHUCxLQUFLO1FBQ1JRO1lBQ0VGLG1CQUFtQjtRQUNyQjtRQUNBRztZQUNFLE9BQU9IO1FBQ1Q7SUFDRjtJQUNBSSxPQUFPQyxjQUFjLENBQUNKLFdBQVdHLE9BQU9FLGNBQWMsQ0FBQ1o7SUFDdkQsT0FBT087QUFDVDtBQUVBLE1BQU1NLGVBQWUsSUFBSUMsSUFBSTtJQUFDO0lBQWdCO0lBQU87SUFBWTtJQUFZO0lBQVc7SUFBTTtJQUFVO0lBQVE7SUFBVztJQUFjO0lBQVM7SUFBTztJQUFhO0lBQWE7SUFBYztJQUFXO0lBQU87SUFBUTtJQUFZO0lBQVU7SUFBVTtJQUFlO0lBQVU7SUFBUztJQUFRO0lBQWU7SUFB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LEVBQ05pWCxXQUFXLEVBQ1hPLE9BQU8sRUFDUixHQUxtQjtJQU1sQixPQUFPLFdBQVcsR0FBRTVYLHNEQUFHQSxDQUFDLFNBQVM7UUFDL0JvRCxXQUFXb3JCO1FBQ1hqYyxLQUFLa2M7UUFDTG5rQixPQUFPM0csR0FBRyxDQUFDdkQsT0FBTzZCLEdBQUcsQ0FBQztRQUN0QjBHLFVBQVU3SCxDQUFBQSxRQUFTdVcsWUFBWTtnQkFDN0IsR0FBRzFULEdBQUc7Z0JBQ04sQ0FBQ3ZELE9BQU82QixHQUFHLENBQUMsRUFBRW5CLE1BQU15QixNQUFNLENBQUMrSCxLQUFLO1lBQ2xDO1FBQ0F1a0IsUUFBUSxJQUFNalgsUUFBUSxNQUFNO0lBQzlCO0FBQ0Y7QUFFZ1UsQ0FDaFUsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1kYXRhLWdyaWQvbGliL2J1bmRsZS5qcz8wMzZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZU1lbW8sIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdCQxLCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgbWVtbywgdXNlSWQsIGZvcndhcmRSZWYsIHVzZUltcGVyYXRpdmVIYW5kbGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmbHVzaFN5bmMgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgeyBqc3gsIGpzeHMsIEZyYWdtZW50IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuXG5mdW5jdGlvbiBnZXRDb2xTcGFuKGNvbHVtbiwgbGFzdEZyb3plbkNvbHVtbkluZGV4LCBhcmdzKSB7XG4gIGNvbnN0IGNvbFNwYW4gPSB0eXBlb2YgY29sdW1uLmNvbFNwYW4gPT09ICdmdW5jdGlvbicgPyBjb2x1bW4uY29sU3BhbihhcmdzKSA6IDE7XG4gIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGNvbFNwYW4pICYmIGNvbFNwYW4gPiAxICYmICghY29sdW1uLmZyb3plbiB8fCBjb2x1bW4uaWR4ICsgY29sU3BhbiAtIDEgPD0gbGFzdEZyb3plbkNvbHVtbkluZGV4KSkge1xuICAgIHJldHVybiBjb2xTcGFuO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihldmVudCkge1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cbmZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KGVsZW1lbnQpIHtcbiAgZWxlbWVudD8uc2Nyb2xsSW50b1ZpZXcoe1xuICAgIGlubGluZTogJ25lYXJlc3QnLFxuICAgIGJsb2NrOiAnbmVhcmVzdCdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNlbGxFdmVudChldmVudCkge1xuICBsZXQgZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuICBjb25zdCBjZWxsRXZlbnQgPSB7XG4gICAgLi4uZXZlbnQsXG4gICAgcHJldmVudEdyaWREZWZhdWx0KCkge1xuICAgICAgZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgfSxcbiAgICBpc0dyaWREZWZhdWx0UHJldmVudGVkKCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgfVxuICB9O1xuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY2VsbEV2ZW50LCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZXZlbnQpKTtcbiAgcmV0dXJuIGNlbGxFdmVudDtcbn1cblxuY29uc3Qgbm9uSW5wdXRLZXlzID0gbmV3IFNldChbJ1VuaWRlbnRpZmllZCcsICdBbHQnLCAnQWx0R3JhcGgnLCAnQ2Fwc0xvY2snLCAnQ29udHJvbCcsICdGbicsICdGbkxvY2snLCAnTWV0YScsICdOdW1Mb2NrJywgJ1Njcm9sbExvY2snLCAnU2hpZnQnLCAnVGFiJywgJ0Fycm93RG93bicsICdBcnJvd0xlZnQnLCAnQXJyb3dSaWdodCcsICdBcnJvd1VwJywgJ0VuZCcsICdIb21lJywgJ1BhZ2VEb3duJywgJ1BhZ2VVcCcsICdJbnNlcnQnLCAnQ29udGV4dE1lbnUnLCAnRXNjYXBlJywgJ1BhdXNlJywgJ1BsYXknLCAnUHJpbnRTY3JlZW4nLCAnRjEnLCAnRjMnLCAnRjQnLCAnRjUnLCAnRjYnLCAnRjcnLCAnRjgnLCAnRjknLCAnRjEwJywgJ0YxMScsICdGMTInXSk7XG5mdW5jdGlvbiBpc0N0cmxLZXlIZWxkRG93bihlKSB7XG4gIHJldHVybiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgJiYgZS5rZXkgIT09ICdDb250cm9sJztcbn1cbmZ1bmN0aW9uIGlzRGVmYXVsdENlbGxJbnB1dChldmVudCkge1xuICBjb25zdCB2S2V5ID0gODY7XG4gIGlmIChpc0N0cmxLZXlIZWxkRG93bihldmVudCkgJiYgZXZlbnQua2V5Q29kZSAhPT0gdktleSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gIW5vbklucHV0S2V5cy5oYXMoZXZlbnQua2V5KTtcbn1cbmZ1bmN0aW9uIG9uRWRpdG9yTmF2aWdhdGlvbih7XG4gIGtleSxcbiAgdGFyZ2V0XG59KSB7XG4gIGlmIChrZXkgPT09ICdUYWInICYmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50IHx8IHRhcmdldCBpbnN0YW5jZW9mIEhUTUxUZXh0QXJlYUVsZW1lbnQgfHwgdGFyZ2V0IGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHRhcmdldC5jbG9zZXN0KCcucmRnLWVkaXRvci1jb250YWluZXInKT8ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQsIHRleHRhcmVhLCBzZWxlY3QnKS5sZW5ndGggPT09IDE7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jb25zdCBtZWFzdXJpbmdDZWxsQ2xhc3NuYW1lID0gXCJtbGxuNnpnNy0wLTAtYmV0YS00NlwiO1xuZnVuY3Rpb24gcmVuZGVyTWVhc3VyaW5nQ2VsbHModmlld3BvcnRDb2x1bW5zKSB7XG4gIHJldHVybiB2aWV3cG9ydENvbHVtbnMubWFwKCh7XG4gICAga2V5LFxuICAgIGlkeCxcbiAgICBtaW5XaWR0aCxcbiAgICBtYXhXaWR0aFxuICB9KSA9PiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IG1lYXN1cmluZ0NlbGxDbGFzc25hbWUsXG4gICAgc3R5bGU6IHtcbiAgICAgIGdyaWRDb2x1bW5TdGFydDogaWR4ICsgMSxcbiAgICAgIG1pbldpZHRoLFxuICAgICAgbWF4V2lkdGhcbiAgICB9LFxuICAgIFwiZGF0YS1tZWFzdXJpbmctY2VsbC1rZXlcIjoga2V5XG4gIH0sIGtleSkpO1xufVxuXG5mdW5jdGlvbiBpc1NlbGVjdGVkQ2VsbEVkaXRhYmxlKHtcbiAgc2VsZWN0ZWRQb3NpdGlvbixcbiAgY29sdW1ucyxcbiAgcm93c1xufSkge1xuICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zW3NlbGVjdGVkUG9zaXRpb24uaWR4XTtcbiAgY29uc3Qgcm93ID0gcm93c1tzZWxlY3RlZFBvc2l0aW9uLnJvd0lkeF07XG4gIHJldHVybiBpc0NlbGxFZGl0YWJsZVV0aWwoY29sdW1uLCByb3cpO1xufVxuZnVuY3Rpb24gaXNDZWxsRWRpdGFibGVVdGlsKGNvbHVtbiwgcm93KSB7XG4gIHJldHVybiBjb2x1bW4ucmVuZGVyRWRpdENlbGwgIT0gbnVsbCAmJiAodHlwZW9mIGNvbHVtbi5lZGl0YWJsZSA9PT0gJ2Z1bmN0aW9uJyA/IGNvbHVtbi5lZGl0YWJsZShyb3cpIDogY29sdW1uLmVkaXRhYmxlKSAhPT0gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRTZWxlY3RlZENlbGxDb2xTcGFuKHtcbiAgcm93cyxcbiAgdG9wU3VtbWFyeVJvd3MsXG4gIGJvdHRvbVN1bW1hcnlSb3dzLFxuICByb3dJZHgsXG4gIG1haW5IZWFkZXJSb3dJZHgsXG4gIGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgY29sdW1uXG59KSB7XG4gIGNvbnN0IHRvcFN1bW1hcnlSb3dzQ291bnQgPSB0b3BTdW1tYXJ5Um93cz8ubGVuZ3RoID8/IDA7XG4gIGlmIChyb3dJZHggPT09IG1haW5IZWFkZXJSb3dJZHgpIHtcbiAgICByZXR1cm4gZ2V0Q29sU3Bhbihjb2x1bW4sIGxhc3RGcm96ZW5Db2x1bW5JbmRleCwge1xuICAgICAgdHlwZTogJ0hFQURFUidcbiAgICB9KTtcbiAgfVxuICBpZiAodG9wU3VtbWFyeVJvd3MgJiYgcm93SWR4ID4gbWFpbkhlYWRlclJvd0lkeCAmJiByb3dJZHggPD0gdG9wU3VtbWFyeVJvd3NDb3VudCArIG1haW5IZWFkZXJSb3dJZHgpIHtcbiAgICByZXR1cm4gZ2V0Q29sU3Bhbihjb2x1bW4sIGxhc3RGcm96ZW5Db2x1bW5JbmRleCwge1xuICAgICAgdHlwZTogJ1NVTU1BUlknLFxuICAgICAgcm93OiB0b3BTdW1tYXJ5Um93c1tyb3dJZHggKyB0b3BTdW1tYXJ5Um93c0NvdW50XVxuICAgIH0pO1xuICB9XG4gIGlmIChyb3dJZHggPj0gMCAmJiByb3dJZHggPCByb3dzLmxlbmd0aCkge1xuICAgIGNvbnN0IHJvdyA9IHJvd3Nbcm93SWR4XTtcbiAgICByZXR1cm4gZ2V0Q29sU3Bhbihjb2x1bW4sIGxhc3RGcm96ZW5Db2x1bW5JbmRleCwge1xuICAgICAgdHlwZTogJ1JPVycsXG4gICAgICByb3dcbiAgICB9KTtcbiAgfVxuICBpZiAoYm90dG9tU3VtbWFyeVJvd3MpIHtcbiAgICByZXR1cm4gZ2V0Q29sU3Bhbihjb2x1bW4sIGxhc3RGcm96ZW5Db2x1bW5JbmRleCwge1xuICAgICAgdHlwZTogJ1NVTU1BUlknLFxuICAgICAgcm93OiBib3R0b21TdW1tYXJ5Um93c1tyb3dJZHggLSByb3dzLmxlbmd0aF1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0TmV4dFNlbGVjdGVkQ2VsbFBvc2l0aW9uKHtcbiAgbW92ZVVwLFxuICBtb3ZlTmV4dCxcbiAgY2VsbE5hdmlnYXRpb25Nb2RlLFxuICBjb2x1bW5zLFxuICBjb2xTcGFuQ29sdW1ucyxcbiAgcm93cyxcbiAgdG9wU3VtbWFyeVJvd3MsXG4gIGJvdHRvbVN1bW1hcnlSb3dzLFxuICBtaW5Sb3dJZHgsXG4gIG1haW5IZWFkZXJSb3dJZHgsXG4gIG1heFJvd0lkeCxcbiAgY3VycmVudFBvc2l0aW9uOiB7XG4gICAgaWR4OiBjdXJyZW50SWR4LFxuICAgIHJvd0lkeDogY3VycmVudFJvd0lkeFxuICB9LFxuICBuZXh0UG9zaXRpb24sXG4gIGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgaXNDZWxsV2l0aGluQm91bmRzXG59KSB7XG4gIGxldCB7XG4gICAgaWR4OiBuZXh0SWR4LFxuICAgIHJvd0lkeDogbmV4dFJvd0lkeFxuICB9ID0gbmV4dFBvc2l0aW9uO1xuICBjb25zdCBjb2x1bW5zQ291bnQgPSBjb2x1bW5zLmxlbmd0aDtcbiAgY29uc3Qgc2V0Q29sU3BhbiA9IG1vdmVOZXh0ID0+IHtcbiAgICBmb3IgKGNvbnN0IGNvbHVtbiBvZiBjb2xTcGFuQ29sdW1ucykge1xuICAgICAgY29uc3QgY29sSWR4ID0gY29sdW1uLmlkeDtcbiAgICAgIGlmIChjb2xJZHggPiBuZXh0SWR4KSBicmVhaztcbiAgICAgIGNvbnN0IGNvbFNwYW4gPSBnZXRTZWxlY3RlZENlbGxDb2xTcGFuKHtcbiAgICAgICAgcm93cyxcbiAgICAgICAgdG9wU3VtbWFyeVJvd3MsXG4gICAgICAgIGJvdHRvbVN1bW1hcnlSb3dzLFxuICAgICAgICByb3dJZHg6IG5leHRSb3dJZHgsXG4gICAgICAgIG1haW5IZWFkZXJSb3dJZHgsXG4gICAgICAgIGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgICAgICAgY29sdW1uXG4gICAgICB9KTtcbiAgICAgIGlmIChjb2xTcGFuICYmIG5leHRJZHggPiBjb2xJZHggJiYgbmV4dElkeCA8IGNvbFNwYW4gKyBjb2xJZHgpIHtcbiAgICAgICAgbmV4dElkeCA9IGNvbElkeCArIChtb3ZlTmV4dCA/IGNvbFNwYW4gOiAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBnZXRQYXJlbnRSb3dJZHggPSBwYXJlbnQgPT4ge1xuICAgIHJldHVybiBwYXJlbnQubGV2ZWwgKyBtYWluSGVhZGVyUm93SWR4O1xuICB9O1xuICBjb25zdCBzZXRIZWFkZXJHcm91cENvbEFuZFJvd1NwYW4gPSAoKSA9PiB7XG4gICAgaWYgKG1vdmVOZXh0KSB7XG4gICAgICBjb25zdCBuZXh0Q29sdW1uID0gY29sdW1uc1tuZXh0SWR4XTtcbiAgICAgIGxldCBwYXJlbnQgPSBuZXh0Q29sdW1uLnBhcmVudDtcbiAgICAgIHdoaWxlIChwYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBwYXJlbnRSb3dJZHggPSBnZXRQYXJlbnRSb3dJZHgocGFyZW50KTtcbiAgICAgICAgaWYgKG5leHRSb3dJZHggPT09IHBhcmVudFJvd0lkeCkge1xuICAgICAgICAgIG5leHRJZHggPSBwYXJlbnQuaWR4ICsgcGFyZW50LmNvbFNwYW47XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1vdmVVcCkge1xuICAgICAgY29uc3QgbmV4dENvbHVtbiA9IGNvbHVtbnNbbmV4dElkeF07XG4gICAgICBsZXQgcGFyZW50ID0gbmV4dENvbHVtbi5wYXJlbnQ7XG4gICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChwYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBwYXJlbnRSb3dJZHggPSBnZXRQYXJlbnRSb3dJZHgocGFyZW50KTtcbiAgICAgICAgaWYgKG5leHRSb3dJZHggPj0gcGFyZW50Um93SWR4KSB7XG4gICAgICAgICAgbmV4dElkeCA9IHBhcmVudC5pZHg7XG4gICAgICAgICAgbmV4dFJvd0lkeCA9IHBhcmVudFJvd0lkeDtcbiAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgbmV4dElkeCA9IGN1cnJlbnRJZHg7XG4gICAgICAgIG5leHRSb3dJZHggPSBjdXJyZW50Um93SWR4O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgaWYgKGlzQ2VsbFdpdGhpbkJvdW5kcyhuZXh0UG9zaXRpb24pKSB7XG4gICAgc2V0Q29sU3Bhbihtb3ZlTmV4dCk7XG4gICAgaWYgKG5leHRSb3dJZHggPCBtYWluSGVhZGVyUm93SWR4KSB7XG4gICAgICBzZXRIZWFkZXJHcm91cENvbEFuZFJvd1NwYW4oKTtcbiAgICB9XG4gIH1cbiAgaWYgKGNlbGxOYXZpZ2F0aW9uTW9kZSA9PT0gJ0NIQU5HRV9ST1cnKSB7XG4gICAgY29uc3QgaXNBZnRlckxhc3RDb2x1bW4gPSBuZXh0SWR4ID09PSBjb2x1bW5zQ291bnQ7XG4gICAgY29uc3QgaXNCZWZvcmVGaXJzdENvbHVtbiA9IG5leHRJZHggPT09IC0xO1xuICAgIGlmIChpc0FmdGVyTGFzdENvbHVtbikge1xuICAgICAgY29uc3QgaXNMYXN0Um93ID0gbmV4dFJvd0lkeCA9PT0gbWF4Um93SWR4O1xuICAgICAgaWYgKCFpc0xhc3RSb3cpIHtcbiAgICAgICAgbmV4dElkeCA9IDA7XG4gICAgICAgIG5leHRSb3dJZHggKz0gMTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQmVmb3JlRmlyc3RDb2x1bW4pIHtcbiAgICAgIGNvbnN0IGlzRmlyc3RSb3cgPSBuZXh0Um93SWR4ID09PSBtaW5Sb3dJZHg7XG4gICAgICBpZiAoIWlzRmlyc3RSb3cpIHtcbiAgICAgICAgbmV4dFJvd0lkeCAtPSAxO1xuICAgICAgICBuZXh0SWR4ID0gY29sdW1uc0NvdW50IC0gMTtcbiAgICAgIH1cbiAgICAgIHNldENvbFNwYW4oZmFsc2UpO1xuICAgIH1cbiAgfVxuICBpZiAobmV4dFJvd0lkeCA8IG1haW5IZWFkZXJSb3dJZHgpIHtcbiAgICBjb25zdCBuZXh0Q29sdW1uID0gY29sdW1uc1tuZXh0SWR4XTtcbiAgICBsZXQgcGFyZW50ID0gbmV4dENvbHVtbi5wYXJlbnQ7XG4gICAgY29uc3QgbmV4dFBhcmVudFJvd0lkeCA9IG5leHRSb3dJZHg7XG4gICAgbmV4dFJvd0lkeCA9IG1haW5IZWFkZXJSb3dJZHg7XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBwYXJlbnRSb3dJZHggPSBnZXRQYXJlbnRSb3dJZHgocGFyZW50KTtcbiAgICAgIGlmIChwYXJlbnRSb3dJZHggPj0gbmV4dFBhcmVudFJvd0lkeCkge1xuICAgICAgICBuZXh0Um93SWR4ID0gcGFyZW50Um93SWR4O1xuICAgICAgICBuZXh0SWR4ID0gcGFyZW50LmlkeDtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgaWR4OiBuZXh0SWR4LFxuICAgIHJvd0lkeDogbmV4dFJvd0lkeFxuICB9O1xufVxuZnVuY3Rpb24gY2FuRXhpdEdyaWQoe1xuICBtYXhDb2xJZHgsXG4gIG1pblJvd0lkeCxcbiAgbWF4Um93SWR4LFxuICBzZWxlY3RlZFBvc2l0aW9uOiB7XG4gICAgcm93SWR4LFxuICAgIGlkeFxuICB9LFxuICBzaGlmdEtleVxufSkge1xuICBjb25zdCBhdExhc3RDZWxsSW5Sb3cgPSBpZHggPT09IG1heENvbElkeDtcbiAgY29uc3QgYXRGaXJzdENlbGxJblJvdyA9IGlkeCA9PT0gMDtcbiAgY29uc3QgYXRMYXN0Um93ID0gcm93SWR4ID09PSBtYXhSb3dJZHg7XG4gIGNvbnN0IGF0Rmlyc3RSb3cgPSByb3dJZHggPT09IG1pblJvd0lkeDtcbiAgcmV0dXJuIHNoaWZ0S2V5ID8gYXRGaXJzdENlbGxJblJvdyAmJiBhdEZpcnN0Um93IDogYXRMYXN0Q2VsbEluUm93ICYmIGF0TGFzdFJvdztcbn1cblxuY29uc3QgY2VsbCA9IFwiY2ozNDN4MDctMC0wLWJldGEtNDZcIjtcbmNvbnN0IGNlbGxDbGFzc25hbWUgPSBgcmRnLWNlbGwgJHtjZWxsfWA7XG5jb25zdCBjZWxsRnJvemVuID0gXCJjc29majdyNy0wLTAtYmV0YS00NlwiO1xuY29uc3QgY2VsbEZyb3plbkNsYXNzbmFtZSA9IGByZGctY2VsbC1mcm96ZW4gJHtjZWxsRnJvemVufWA7XG5cbmZ1bmN0aW9uIGdldFJvd1N0eWxlKHJvd0lkeCkge1xuICByZXR1cm4ge1xuICAgICctLXJkZy1ncmlkLXJvdy1zdGFydCc6IHJvd0lkeFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0SGVhZGVyQ2VsbFN0eWxlKGNvbHVtbiwgcm93SWR4LCByb3dTcGFuKSB7XG4gIGNvbnN0IGdyaWRSb3dFbmQgPSByb3dJZHggKyAxO1xuICBjb25zdCBwYWRkaW5nQmxvY2tTdGFydCA9IGBjYWxjKCR7cm93U3BhbiAtIDF9ICogdmFyKC0tcmRnLWhlYWRlci1yb3ctaGVpZ2h0KSlgO1xuICBpZiAoY29sdW1uLnBhcmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluc2V0QmxvY2tTdGFydDogMCxcbiAgICAgIGdyaWRSb3dTdGFydDogMSxcbiAgICAgIGdyaWRSb3dFbmQsXG4gICAgICBwYWRkaW5nQmxvY2tTdGFydFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpbnNldEJsb2NrU3RhcnQ6IGBjYWxjKCR7cm93SWR4IC0gcm93U3Bhbn0gKiB2YXIoLS1yZGctaGVhZGVyLXJvdy1oZWlnaHQpKWAsXG4gICAgZ3JpZFJvd1N0YXJ0OiBncmlkUm93RW5kIC0gcm93U3BhbixcbiAgICBncmlkUm93RW5kLFxuICAgIHBhZGRpbmdCbG9ja1N0YXJ0XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDZWxsU3R5bGUoY29sdW1uLCBjb2xTcGFuID0gMSkge1xuICBjb25zdCBpbmRleCA9IGNvbHVtbi5pZHggKyAxO1xuICByZXR1cm4ge1xuICAgIGdyaWRDb2x1bW5TdGFydDogaW5kZXgsXG4gICAgZ3JpZENvbHVtbkVuZDogaW5kZXggKyBjb2xTcGFuLFxuICAgIGluc2V0SW5saW5lU3RhcnQ6IGNvbHVtbi5mcm96ZW4gPyBgdmFyKC0tcmRnLWZyb3plbi1sZWZ0LSR7Y29sdW1uLmlkeH0pYCA6IHVuZGVmaW5lZFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2VsbENsYXNzbmFtZShjb2x1bW4sIC4uLmV4dHJhQ2xhc3Nlcykge1xuICByZXR1cm4gY2xzeChjZWxsQ2xhc3NuYW1lLCAuLi5leHRyYUNsYXNzZXMsIGNvbHVtbi5mcm96ZW4gJiYgY2VsbEZyb3plbkNsYXNzbmFtZSk7XG59XG5cbmNvbnN0IHtcbiAgbWluLFxuICBtYXgsXG4gIGZsb29yLFxuICBzaWduLFxuICBhYnNcbn0gPSBNYXRoO1xuZnVuY3Rpb24gYXNzZXJ0SXNWYWxpZEtleUdldHRlcihrZXlHZXR0ZXIpIHtcbiAgaWYgKHR5cGVvZiBrZXlHZXR0ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBzcGVjaWZ5IHRoZSByb3dLZXlHZXR0ZXIgcHJvcCB0byB1c2Ugc2VsZWN0aW9uJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsYW1wQ29sdW1uV2lkdGgod2lkdGgsIHtcbiAgbWluV2lkdGgsXG4gIG1heFdpZHRoXG59KSB7XG4gIHdpZHRoID0gbWF4KHdpZHRoLCBtaW5XaWR0aCk7XG4gIGlmICh0eXBlb2YgbWF4V2lkdGggPT09ICdudW1iZXInICYmIG1heFdpZHRoID49IG1pbldpZHRoKSB7XG4gICAgcmV0dXJuIG1pbih3aWR0aCwgbWF4V2lkdGgpO1xuICB9XG4gIHJldHVybiB3aWR0aDtcbn1cbmZ1bmN0aW9uIGdldEhlYWRlckNlbGxSb3dTcGFuKGNvbHVtbiwgcm93SWR4KSB7XG4gIHJldHVybiBjb2x1bW4ucGFyZW50ID09PSB1bmRlZmluZWQgPyByb3dJZHggOiBjb2x1bW4ubGV2ZWwgLSBjb2x1bW4ucGFyZW50LmxldmVsO1xufVxuXG5jb25zdCBjaGVja2JveENvbnRhaW5lciA9IFwiYzFibjg4dnY3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCBjaGVja2JveCA9IFwiYzFxdDA3M2w3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCBjaGVja2JveENsYXNzbmFtZSA9IGByZGctY2hlY2tib3gtaW5wdXQgJHtjaGVja2JveH1gO1xuZnVuY3Rpb24gcmVuZGVyQ2hlY2tib3goe1xuICBvbkNoYW5nZSxcbiAgLi4ucHJvcHNcbn0pIHtcbiAgZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKGUpIHtcbiAgICBvbkNoYW5nZShlLnRhcmdldC5jaGVja2VkLCBlLm5hdGl2ZUV2ZW50LnNoaWZ0S2V5KTtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBjaGVja2JveENvbnRhaW5lcixcbiAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChcImlucHV0XCIsIHtcbiAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgIC4uLnByb3BzLFxuICAgICAgY2xhc3NOYW1lOiBjaGVja2JveENsYXNzbmFtZSxcbiAgICAgIG9uQ2hhbmdlOiBoYW5kbGVDaGFuZ2VcbiAgICB9KVxuICB9KTtcbn1cblxuY29uc3QgZ3JvdXBDZWxsQ29udGVudCA9IFwiZzFzOXlsZ3A3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCBncm91cENlbGxDb250ZW50Q2xhc3NuYW1lID0gYHJkZy1ncm91cC1jZWxsLWNvbnRlbnQgJHtncm91cENlbGxDb250ZW50fWA7XG5jb25zdCBjYXJldCA9IFwiY3o1NGU0eTctMC0wLWJldGEtNDZcIjtcbmNvbnN0IGNhcmV0Q2xhc3NuYW1lID0gYHJkZy1jYXJldCAke2NhcmV0fWA7XG5mdW5jdGlvbiByZW5kZXJUb2dnbGVHcm91cChwcm9wcykge1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChUb2dnbGVHcm91cCwge1xuICAgIC4uLnByb3BzXG4gIH0pO1xufVxuZnVuY3Rpb24gVG9nZ2xlR3JvdXAoe1xuICBncm91cEtleSxcbiAgaXNFeHBhbmRlZCxcbiAgdGFiSW5kZXgsXG4gIHRvZ2dsZUdyb3VwXG59KSB7XG4gIGZ1bmN0aW9uIGhhbmRsZUtleURvd24oe1xuICAgIGtleVxuICB9KSB7XG4gICAgaWYgKGtleSA9PT0gJ0VudGVyJykge1xuICAgICAgdG9nZ2xlR3JvdXAoKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZCA9IGlzRXhwYW5kZWQgPyAnTTEgMSBMIDcgNyBMIDEzIDEnIDogJ00xIDcgTCA3IDEgTCAxMyA3JztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3hzKFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBncm91cENlbGxDb250ZW50Q2xhc3NuYW1lLFxuICAgIHRhYkluZGV4OiB0YWJJbmRleCxcbiAgICBvbktleURvd246IGhhbmRsZUtleURvd24sXG4gICAgY2hpbGRyZW46IFtncm91cEtleSwgLyojX19QVVJFX18qL2pzeChcInN2Z1wiLCB7XG4gICAgICB2aWV3Qm94OiBcIjAgMCAxNCA4XCIsXG4gICAgICB3aWR0aDogXCIxNFwiLFxuICAgICAgaGVpZ2h0OiBcIjhcIixcbiAgICAgIGNsYXNzTmFtZTogY2FyZXRDbGFzc25hbWUsXG4gICAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChcInBhdGhcIiwge1xuICAgICAgICBkOiBkXG4gICAgICB9KVxuICAgIH0pXVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVmFsdWUocHJvcHMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvcHMucm93W3Byb3BzLmNvbHVtbi5rZXldO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5jb25zdCBEYXRhR3JpZERlZmF1bHRSZW5kZXJlcnNDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbmNvbnN0IERhdGFHcmlkRGVmYXVsdFJlbmRlcmVyc1Byb3ZpZGVyID0gRGF0YUdyaWREZWZhdWx0UmVuZGVyZXJzQ29udGV4dC5Qcm92aWRlcjtcbmZ1bmN0aW9uIHVzZURlZmF1bHRSZW5kZXJlcnMoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KERhdGFHcmlkRGVmYXVsdFJlbmRlcmVyc0NvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBTZWxlY3RDZWxsRm9ybWF0dGVyKHtcbiAgdmFsdWUsXG4gIHRhYkluZGV4LFxuICBkaXNhYmxlZCxcbiAgb25DaGFuZ2UsXG4gICdhcmlhLWxhYmVsJzogYXJpYUxhYmVsLFxuICAnYXJpYS1sYWJlbGxlZGJ5JzogYXJpYUxhYmVsbGVkQnlcbn0pIHtcbiAgY29uc3QgcmVuZGVyQ2hlY2tib3ggPSB1c2VEZWZhdWx0UmVuZGVyZXJzKCkucmVuZGVyQ2hlY2tib3g7XG4gIHJldHVybiByZW5kZXJDaGVja2JveCh7XG4gICAgJ2FyaWEtbGFiZWwnOiBhcmlhTGFiZWwsXG4gICAgJ2FyaWEtbGFiZWxsZWRieSc6IGFyaWFMYWJlbGxlZEJ5LFxuICAgIHRhYkluZGV4LFxuICAgIGRpc2FibGVkLFxuICAgIGNoZWNrZWQ6IHZhbHVlLFxuICAgIG9uQ2hhbmdlXG4gIH0pO1xufVxuXG5jb25zdCBSb3dTZWxlY3Rpb25Db250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbmNvbnN0IFJvd1NlbGVjdGlvblByb3ZpZGVyID0gUm93U2VsZWN0aW9uQ29udGV4dC5Qcm92aWRlcjtcbmNvbnN0IFJvd1NlbGVjdGlvbkNoYW5nZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuY29uc3QgUm93U2VsZWN0aW9uQ2hhbmdlUHJvdmlkZXIgPSBSb3dTZWxlY3Rpb25DaGFuZ2VDb250ZXh0LlByb3ZpZGVyO1xuZnVuY3Rpb24gdXNlUm93U2VsZWN0aW9uKCkge1xuICBjb25zdCByb3dTZWxlY3Rpb25Db250ZXh0ID0gdXNlQ29udGV4dChSb3dTZWxlY3Rpb25Db250ZXh0KTtcbiAgY29uc3Qgcm93U2VsZWN0aW9uQ2hhbmdlQ29udGV4dCA9IHVzZUNvbnRleHQoUm93U2VsZWN0aW9uQ2hhbmdlQ29udGV4dCk7XG4gIGlmIChyb3dTZWxlY3Rpb25Db250ZXh0ID09PSB1bmRlZmluZWQgfHwgcm93U2VsZWN0aW9uQ2hhbmdlQ29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VSb3dTZWxlY3Rpb24gbXVzdCBiZSB1c2VkIHdpdGhpbiBEYXRhR3JpZCBjZWxscycpO1xuICB9XG4gIHJldHVybiBbcm93U2VsZWN0aW9uQ29udGV4dCwgcm93U2VsZWN0aW9uQ2hhbmdlQ29udGV4dF07XG59XG5cbmNvbnN0IFNFTEVDVF9DT0xVTU5fS0VZID0gJ3NlbGVjdC1yb3cnO1xuZnVuY3Rpb24gSGVhZGVyUmVuZGVyZXIocHJvcHMpIHtcbiAgY29uc3QgW2lzUm93U2VsZWN0ZWQsIG9uUm93U2VsZWN0aW9uQ2hhbmdlXSA9IHVzZVJvd1NlbGVjdGlvbigpO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChTZWxlY3RDZWxsRm9ybWF0dGVyLCB7XG4gICAgXCJhcmlhLWxhYmVsXCI6IFwiU2VsZWN0IEFsbFwiLFxuICAgIHRhYkluZGV4OiBwcm9wcy50YWJJbmRleCxcbiAgICB2YWx1ZTogaXNSb3dTZWxlY3RlZCxcbiAgICBvbkNoYW5nZTogY2hlY2tlZCA9PiB7XG4gICAgICBvblJvd1NlbGVjdGlvbkNoYW5nZSh7XG4gICAgICAgIHR5cGU6ICdIRUFERVInLFxuICAgICAgICBjaGVja2VkXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gU2VsZWN0Rm9ybWF0dGVyKHByb3BzKSB7XG4gIGNvbnN0IFtpc1Jvd1NlbGVjdGVkLCBvblJvd1NlbGVjdGlvbkNoYW5nZV0gPSB1c2VSb3dTZWxlY3Rpb24oKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goU2VsZWN0Q2VsbEZvcm1hdHRlciwge1xuICAgIFwiYXJpYS1sYWJlbFwiOiBcIlNlbGVjdFwiLFxuICAgIHRhYkluZGV4OiBwcm9wcy50YWJJbmRleCxcbiAgICB2YWx1ZTogaXNSb3dTZWxlY3RlZCxcbiAgICBvbkNoYW5nZTogKGNoZWNrZWQsIGlzU2hpZnRDbGljaykgPT4ge1xuICAgICAgb25Sb3dTZWxlY3Rpb25DaGFuZ2Uoe1xuICAgICAgICB0eXBlOiAnUk9XJyxcbiAgICAgICAgcm93OiBwcm9wcy5yb3csXG4gICAgICAgIGNoZWNrZWQsXG4gICAgICAgIGlzU2hpZnRDbGlja1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIFNlbGVjdEdyb3VwRm9ybWF0dGVyKHByb3BzKSB7XG4gIGNvbnN0IFtpc1Jvd1NlbGVjdGVkLCBvblJvd1NlbGVjdGlvbkNoYW5nZV0gPSB1c2VSb3dTZWxlY3Rpb24oKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goU2VsZWN0Q2VsbEZvcm1hdHRlciwge1xuICAgIFwiYXJpYS1sYWJlbFwiOiBcIlNlbGVjdCBHcm91cFwiLFxuICAgIHRhYkluZGV4OiBwcm9wcy50YWJJbmRleCxcbiAgICB2YWx1ZTogaXNSb3dTZWxlY3RlZCxcbiAgICBvbkNoYW5nZTogY2hlY2tlZCA9PiB7XG4gICAgICBvblJvd1NlbGVjdGlvbkNoYW5nZSh7XG4gICAgICAgIHR5cGU6ICdST1cnLFxuICAgICAgICByb3c6IHByb3BzLnJvdyxcbiAgICAgICAgY2hlY2tlZCxcbiAgICAgICAgaXNTaGlmdENsaWNrOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbmNvbnN0IFNlbGVjdENvbHVtbiA9IHtcbiAga2V5OiBTRUxFQ1RfQ09MVU1OX0tFWSxcbiAgbmFtZTogJycsXG4gIHdpZHRoOiAzNSxcbiAgbWluV2lkdGg6IDM1LFxuICBtYXhXaWR0aDogMzUsXG4gIHJlc2l6YWJsZTogZmFsc2UsXG4gIHNvcnRhYmxlOiBmYWxzZSxcbiAgZnJvemVuOiB0cnVlLFxuICByZW5kZXJIZWFkZXJDZWxsKHByb3BzKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goSGVhZGVyUmVuZGVyZXIsIHtcbiAgICAgIC4uLnByb3BzXG4gICAgfSk7XG4gIH0sXG4gIHJlbmRlckNlbGwocHJvcHMpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL2pzeChTZWxlY3RGb3JtYXR0ZXIsIHtcbiAgICAgIC4uLnByb3BzXG4gICAgfSk7XG4gIH0sXG4gIHJlbmRlckdyb3VwQ2VsbChwcm9wcykge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFNlbGVjdEdyb3VwRm9ybWF0dGVyLCB7XG4gICAgICAuLi5wcm9wc1xuICAgIH0pO1xuICB9XG59O1xuXG5jb25zdCBERUZBVUxUX0NPTFVNTl9XSURUSCA9ICdhdXRvJztcbmNvbnN0IERFRkFVTFRfQ09MVU1OX01JTl9XSURUSCA9IDUwO1xuZnVuY3Rpb24gdXNlQ2FsY3VsYXRlZENvbHVtbnMoe1xuICByYXdDb2x1bW5zLFxuICBkZWZhdWx0Q29sdW1uT3B0aW9ucyxcbiAgZ2V0Q29sdW1uV2lkdGgsXG4gIHZpZXdwb3J0V2lkdGgsXG4gIHNjcm9sbExlZnQsXG4gIGVuYWJsZVZpcnR1YWxpemF0aW9uXG59KSB7XG4gIGNvbnN0IGRlZmF1bHRXaWR0aCA9IGRlZmF1bHRDb2x1bW5PcHRpb25zPy53aWR0aCA/PyBERUZBVUxUX0NPTFVNTl9XSURUSDtcbiAgY29uc3QgZGVmYXVsdE1pbldpZHRoID0gZGVmYXVsdENvbHVtbk9wdGlvbnM/Lm1pbldpZHRoID8/IERFRkFVTFRfQ09MVU1OX01JTl9XSURUSDtcbiAgY29uc3QgZGVmYXVsdE1heFdpZHRoID0gZGVmYXVsdENvbHVtbk9wdGlvbnM/Lm1heFdpZHRoID8/IHVuZGVmaW5lZDtcbiAgY29uc3QgZGVmYXVsdENlbGxSZW5kZXJlciA9IGRlZmF1bHRDb2x1bW5PcHRpb25zPy5yZW5kZXJDZWxsID8/IHJlbmRlclZhbHVlO1xuICBjb25zdCBkZWZhdWx0U29ydGFibGUgPSBkZWZhdWx0Q29sdW1uT3B0aW9ucz8uc29ydGFibGUgPz8gZmFsc2U7XG4gIGNvbnN0IGRlZmF1bHRSZXNpemFibGUgPSBkZWZhdWx0Q29sdW1uT3B0aW9ucz8ucmVzaXphYmxlID8/IGZhbHNlO1xuICBjb25zdCBkZWZhdWx0RHJhZ2dhYmxlID0gZGVmYXVsdENvbHVtbk9wdGlvbnM/LmRyYWdnYWJsZSA/PyBmYWxzZTtcbiAgY29uc3Qge1xuICAgIGNvbHVtbnMsXG4gICAgY29sU3BhbkNvbHVtbnMsXG4gICAgbGFzdEZyb3plbkNvbHVtbkluZGV4LFxuICAgIGhlYWRlclJvd3NDb3VudFxuICB9ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IGxhc3RGcm96ZW5Db2x1bW5JbmRleCA9IC0xO1xuICAgIGxldCBoZWFkZXJSb3dzQ291bnQgPSAxO1xuICAgIGNvbnN0IGNvbHVtbnMgPSBbXTtcbiAgICBjb2xsZWN0Q29sdW1ucyhyYXdDb2x1bW5zLCAxKTtcbiAgICBmdW5jdGlvbiBjb2xsZWN0Q29sdW1ucyhyYXdDb2x1bW5zLCBsZXZlbCwgcGFyZW50KSB7XG4gICAgICBmb3IgKGNvbnN0IHJhd0NvbHVtbiBvZiByYXdDb2x1bW5zKSB7XG4gICAgICAgIGlmICgnY2hpbGRyZW4nIGluIHJhd0NvbHVtbikge1xuICAgICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRDb2x1bW5QYXJlbnQgPSB7XG4gICAgICAgICAgICBuYW1lOiByYXdDb2x1bW4ubmFtZSxcbiAgICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICAgIGlkeDogLTEsXG4gICAgICAgICAgICBjb2xTcGFuOiAwLFxuICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICBoZWFkZXJDZWxsQ2xhc3M6IHJhd0NvbHVtbi5oZWFkZXJDZWxsQ2xhc3NcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbGxlY3RDb2x1bW5zKHJhd0NvbHVtbi5jaGlsZHJlbiwgbGV2ZWwgKyAxLCBjYWxjdWxhdGVkQ29sdW1uUGFyZW50KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcm96ZW4gPSByYXdDb2x1bW4uZnJvemVuID8/IGZhbHNlO1xuICAgICAgICBjb25zdCBjb2x1bW4gPSB7XG4gICAgICAgICAgLi4ucmF3Q29sdW1uLFxuICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICBpZHg6IDAsXG4gICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgZnJvemVuLFxuICAgICAgICAgIHdpZHRoOiByYXdDb2x1bW4ud2lkdGggPz8gZGVmYXVsdFdpZHRoLFxuICAgICAgICAgIG1pbldpZHRoOiByYXdDb2x1bW4ubWluV2lkdGggPz8gZGVmYXVsdE1pbldpZHRoLFxuICAgICAgICAgIG1heFdpZHRoOiByYXdDb2x1bW4ubWF4V2lkdGggPz8gZGVmYXVsdE1heFdpZHRoLFxuICAgICAgICAgIHNvcnRhYmxlOiByYXdDb2x1bW4uc29ydGFibGUgPz8gZGVmYXVsdFNvcnRhYmxlLFxuICAgICAgICAgIHJlc2l6YWJsZTogcmF3Q29sdW1uLnJlc2l6YWJsZSA/PyBkZWZhdWx0UmVzaXphYmxlLFxuICAgICAgICAgIGRyYWdnYWJsZTogcmF3Q29sdW1uLmRyYWdnYWJsZSA/PyBkZWZhdWx0RHJhZ2dhYmxlLFxuICAgICAgICAgIHJlbmRlckNlbGw6IHJhd0NvbHVtbi5yZW5kZXJDZWxsID8/IGRlZmF1bHRDZWxsUmVuZGVyZXJcbiAgICAgICAgfTtcbiAgICAgICAgY29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgIGlmIChmcm96ZW4pIHtcbiAgICAgICAgICBsYXN0RnJvemVuQ29sdW1uSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGV2ZWwgPiBoZWFkZXJSb3dzQ291bnQpIHtcbiAgICAgICAgICBoZWFkZXJSb3dzQ291bnQgPSBsZXZlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb2x1bW5zLnNvcnQoKHtcbiAgICAgIGtleTogYUtleSxcbiAgICAgIGZyb3plbjogZnJvemVuQVxuICAgIH0sIHtcbiAgICAgIGtleTogYktleSxcbiAgICAgIGZyb3plbjogZnJvemVuQlxuICAgIH0pID0+IHtcbiAgICAgIGlmIChhS2V5ID09PSBTRUxFQ1RfQ09MVU1OX0tFWSkgcmV0dXJuIC0xO1xuICAgICAgaWYgKGJLZXkgPT09IFNFTEVDVF9DT0xVTU5fS0VZKSByZXR1cm4gMTtcbiAgICAgIGlmIChmcm96ZW5BKSB7XG4gICAgICAgIGlmIChmcm96ZW5CKSByZXR1cm4gMDtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKGZyb3plbkIpIHJldHVybiAxO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG4gICAgY29uc3QgY29sU3BhbkNvbHVtbnMgPSBbXTtcbiAgICBjb2x1bW5zLmZvckVhY2goKGNvbHVtbiwgaWR4KSA9PiB7XG4gICAgICBjb2x1bW4uaWR4ID0gaWR4O1xuICAgICAgdXBkYXRlQ29sdW1uUGFyZW50KGNvbHVtbiwgaWR4LCAwKTtcbiAgICAgIGlmIChjb2x1bW4uY29sU3BhbiAhPSBudWxsKSB7XG4gICAgICAgIGNvbFNwYW5Db2x1bW5zLnB1c2goY29sdW1uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1ucyxcbiAgICAgIGNvbFNwYW5Db2x1bW5zLFxuICAgICAgbGFzdEZyb3plbkNvbHVtbkluZGV4LFxuICAgICAgaGVhZGVyUm93c0NvdW50XG4gICAgfTtcbiAgfSwgW3Jhd0NvbHVtbnMsIGRlZmF1bHRXaWR0aCwgZGVmYXVsdE1pbldpZHRoLCBkZWZhdWx0TWF4V2lkdGgsIGRlZmF1bHRDZWxsUmVuZGVyZXIsIGRlZmF1bHRSZXNpemFibGUsIGRlZmF1bHRTb3J0YWJsZSwgZGVmYXVsdERyYWdnYWJsZV0pO1xuICBjb25zdCB7XG4gICAgdGVtcGxhdGVDb2x1bW5zLFxuICAgIGxheW91dENzc1ZhcnMsXG4gICAgdG90YWxGcm96ZW5Db2x1bW5XaWR0aCxcbiAgICBjb2x1bW5NZXRyaWNzXG4gIH0gPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBjb2x1bW5NZXRyaWNzID0gbmV3IE1hcCgpO1xuICAgIGxldCBsZWZ0ID0gMDtcbiAgICBsZXQgdG90YWxGcm96ZW5Db2x1bW5XaWR0aCA9IDA7XG4gICAgY29uc3QgdGVtcGxhdGVDb2x1bW5zID0gW107XG4gICAgZm9yIChjb25zdCBjb2x1bW4gb2YgY29sdW1ucykge1xuICAgICAgbGV0IHdpZHRoID0gZ2V0Q29sdW1uV2lkdGgoY29sdW1uKTtcbiAgICAgIGlmICh0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgIHdpZHRoID0gY2xhbXBDb2x1bW5XaWR0aCh3aWR0aCwgY29sdW1uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoID0gY29sdW1uLm1pbldpZHRoO1xuICAgICAgfVxuICAgICAgdGVtcGxhdGVDb2x1bW5zLnB1c2goYCR7d2lkdGh9cHhgKTtcbiAgICAgIGNvbHVtbk1ldHJpY3Muc2V0KGNvbHVtbiwge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgbGVmdFxuICAgICAgfSk7XG4gICAgICBsZWZ0ICs9IHdpZHRoO1xuICAgIH1cbiAgICBpZiAobGFzdEZyb3plbkNvbHVtbkluZGV4ICE9PSAtMSkge1xuICAgICAgY29uc3QgY29sdW1uTWV0cmljID0gY29sdW1uTWV0cmljcy5nZXQoY29sdW1uc1tsYXN0RnJvemVuQ29sdW1uSW5kZXhdKTtcbiAgICAgIHRvdGFsRnJvemVuQ29sdW1uV2lkdGggPSBjb2x1bW5NZXRyaWMubGVmdCArIGNvbHVtbk1ldHJpYy53aWR0aDtcbiAgICB9XG4gICAgY29uc3QgbGF5b3V0Q3NzVmFycyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGxhc3RGcm96ZW5Db2x1bW5JbmRleDsgaSsrKSB7XG4gICAgICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zW2ldO1xuICAgICAgbGF5b3V0Q3NzVmFyc1tgLS1yZGctZnJvemVuLWxlZnQtJHtjb2x1bW4uaWR4fWBdID0gYCR7Y29sdW1uTWV0cmljcy5nZXQoY29sdW1uKS5sZWZ0fXB4YDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRlbXBsYXRlQ29sdW1ucyxcbiAgICAgIGxheW91dENzc1ZhcnMsXG4gICAgICB0b3RhbEZyb3plbkNvbHVtbldpZHRoLFxuICAgICAgY29sdW1uTWV0cmljc1xuICAgIH07XG4gIH0sIFtnZXRDb2x1bW5XaWR0aCwgY29sdW1ucywgbGFzdEZyb3plbkNvbHVtbkluZGV4XSk7XG4gIGNvbnN0IFtjb2xPdmVyc2NhblN0YXJ0SWR4LCBjb2xPdmVyc2NhbkVuZElkeF0gPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZVZpcnR1YWxpemF0aW9uKSB7XG4gICAgICByZXR1cm4gWzAsIGNvbHVtbnMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGNvbnN0IHZpZXdwb3J0TGVmdCA9IHNjcm9sbExlZnQgKyB0b3RhbEZyb3plbkNvbHVtbldpZHRoO1xuICAgIGNvbnN0IHZpZXdwb3J0UmlnaHQgPSBzY3JvbGxMZWZ0ICsgdmlld3BvcnRXaWR0aDtcbiAgICBjb25zdCBsYXN0Q29sSWR4ID0gY29sdW1ucy5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGZpcnN0VW5mcm96ZW5Db2x1bW5JZHggPSBtaW4obGFzdEZyb3plbkNvbHVtbkluZGV4ICsgMSwgbGFzdENvbElkeCk7XG4gICAgaWYgKHZpZXdwb3J0TGVmdCA+PSB2aWV3cG9ydFJpZ2h0KSB7XG4gICAgICByZXR1cm4gW2ZpcnN0VW5mcm96ZW5Db2x1bW5JZHgsIGZpcnN0VW5mcm96ZW5Db2x1bW5JZHhdO1xuICAgIH1cbiAgICBsZXQgY29sVmlzaWJsZVN0YXJ0SWR4ID0gZmlyc3RVbmZyb3plbkNvbHVtbklkeDtcbiAgICB3aGlsZSAoY29sVmlzaWJsZVN0YXJ0SWR4IDwgbGFzdENvbElkeCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsZWZ0LFxuICAgICAgICB3aWR0aFxuICAgICAgfSA9IGNvbHVtbk1ldHJpY3MuZ2V0KGNvbHVtbnNbY29sVmlzaWJsZVN0YXJ0SWR4XSk7XG4gICAgICBpZiAobGVmdCArIHdpZHRoID4gdmlld3BvcnRMZWZ0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29sVmlzaWJsZVN0YXJ0SWR4Kys7XG4gICAgfVxuICAgIGxldCBjb2xWaXNpYmxlRW5kSWR4ID0gY29sVmlzaWJsZVN0YXJ0SWR4O1xuICAgIHdoaWxlIChjb2xWaXNpYmxlRW5kSWR4IDwgbGFzdENvbElkeCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsZWZ0LFxuICAgICAgICB3aWR0aFxuICAgICAgfSA9IGNvbHVtbk1ldHJpY3MuZ2V0KGNvbHVtbnNbY29sVmlzaWJsZUVuZElkeF0pO1xuICAgICAgaWYgKGxlZnQgKyB3aWR0aCA+PSB2aWV3cG9ydFJpZ2h0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29sVmlzaWJsZUVuZElkeCsrO1xuICAgIH1cbiAgICBjb25zdCBjb2xPdmVyc2NhblN0YXJ0SWR4ID0gbWF4KGZpcnN0VW5mcm96ZW5Db2x1bW5JZHgsIGNvbFZpc2libGVTdGFydElkeCAtIDEpO1xuICAgIGNvbnN0IGNvbE92ZXJzY2FuRW5kSWR4ID0gbWluKGxhc3RDb2xJZHgsIGNvbFZpc2libGVFbmRJZHggKyAxKTtcbiAgICByZXR1cm4gW2NvbE92ZXJzY2FuU3RhcnRJZHgsIGNvbE92ZXJzY2FuRW5kSWR4XTtcbiAgfSwgW2NvbHVtbk1ldHJpY3MsIGNvbHVtbnMsIGxhc3RGcm96ZW5Db2x1bW5JbmRleCwgc2Nyb2xsTGVmdCwgdG90YWxGcm96ZW5Db2x1bW5XaWR0aCwgdmlld3BvcnRXaWR0aCwgZW5hYmxlVmlydHVhbGl6YXRpb25dKTtcbiAgcmV0dXJuIHtcbiAgICBjb2x1bW5zLFxuICAgIGNvbFNwYW5Db2x1bW5zLFxuICAgIGNvbE92ZXJzY2FuU3RhcnRJZHgsXG4gICAgY29sT3ZlcnNjYW5FbmRJZHgsXG4gICAgdGVtcGxhdGVDb2x1bW5zLFxuICAgIGxheW91dENzc1ZhcnMsXG4gICAgaGVhZGVyUm93c0NvdW50LFxuICAgIGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgICB0b3RhbEZyb3plbkNvbHVtbldpZHRoXG4gIH07XG59XG5mdW5jdGlvbiB1cGRhdGVDb2x1bW5QYXJlbnQoY29sdW1uLCBpbmRleCwgbGV2ZWwpIHtcbiAgaWYgKGxldmVsIDwgY29sdW1uLmxldmVsKSB7XG4gICAgY29sdW1uLmxldmVsID0gbGV2ZWw7XG4gIH1cbiAgaWYgKGNvbHVtbi5wYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmVudFxuICAgIH0gPSBjb2x1bW47XG4gICAgaWYgKHBhcmVudC5pZHggPT09IC0xKSB7XG4gICAgICBwYXJlbnQuaWR4ID0gaW5kZXg7XG4gICAgfVxuICAgIHBhcmVudC5jb2xTcGFuICs9IDE7XG4gICAgdXBkYXRlQ29sdW1uUGFyZW50KHBhcmVudCwgaW5kZXgsIGxldmVsIC0gMSk7XG4gIH1cbn1cblxuY29uc3QgdXNlTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyB1c2VFZmZlY3QgOiB1c2VMYXlvdXRFZmZlY3QkMTtcblxuZnVuY3Rpb24gdXNlQ29sdW1uV2lkdGhzKGNvbHVtbnMsIHZpZXdwb3J0Q29sdW1ucywgdGVtcGxhdGVDb2x1bW5zLCBncmlkUmVmLCBncmlkV2lkdGgsIHJlc2l6ZWRDb2x1bW5XaWR0aHMsIG1lYXN1cmVkQ29sdW1uV2lkdGhzLCBzZXRSZXNpemVkQ29sdW1uV2lkdGhzLCBzZXRNZWFzdXJlZENvbHVtbldpZHRocywgb25Db2x1bW5SZXNpemUpIHtcbiAgY29uc3QgcHJldkdyaWRXaWR0aFJlZiA9IHVzZVJlZihncmlkV2lkdGgpO1xuICBjb25zdCBjb2x1bW5zQ2FuRmxleCA9IGNvbHVtbnMubGVuZ3RoID09PSB2aWV3cG9ydENvbHVtbnMubGVuZ3RoO1xuICBjb25zdCBpZ25vcmVQcmV2aW91c2x5TWVhc3VyZWRDb2x1bW5zID0gY29sdW1uc0NhbkZsZXggJiYgZ3JpZFdpZHRoICE9PSBwcmV2R3JpZFdpZHRoUmVmLmN1cnJlbnQ7XG4gIGNvbnN0IG5ld1RlbXBsYXRlQ29sdW1ucyA9IFsuLi50ZW1wbGF0ZUNvbHVtbnNdO1xuICBjb25zdCBjb2x1bW5zVG9NZWFzdXJlID0gW107XG4gIGZvciAoY29uc3Qge1xuICAgIGtleSxcbiAgICBpZHgsXG4gICAgd2lkdGhcbiAgfSBvZiB2aWV3cG9ydENvbHVtbnMpIHtcbiAgICBpZiAodHlwZW9mIHdpZHRoID09PSAnc3RyaW5nJyAmJiAoaWdub3JlUHJldmlvdXNseU1lYXN1cmVkQ29sdW1ucyB8fCAhbWVhc3VyZWRDb2x1bW5XaWR0aHMuaGFzKGtleSkpICYmICFyZXNpemVkQ29sdW1uV2lkdGhzLmhhcyhrZXkpKSB7XG4gICAgICBuZXdUZW1wbGF0ZUNvbHVtbnNbaWR4XSA9IHdpZHRoO1xuICAgICAgY29sdW1uc1RvTWVhc3VyZS5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGdyaWRUZW1wbGF0ZUNvbHVtbnMgPSBuZXdUZW1wbGF0ZUNvbHVtbnMuam9pbignICcpO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHByZXZHcmlkV2lkdGhSZWYuY3VycmVudCA9IGdyaWRXaWR0aDtcbiAgICB1cGRhdGVNZWFzdXJlZFdpZHRocyhjb2x1bW5zVG9NZWFzdXJlKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIHVwZGF0ZU1lYXN1cmVkV2lkdGhzKGNvbHVtbnNUb01lYXN1cmUpIHtcbiAgICBpZiAoY29sdW1uc1RvTWVhc3VyZS5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBzZXRNZWFzdXJlZENvbHVtbldpZHRocyhtZWFzdXJlZENvbHVtbldpZHRocyA9PiB7XG4gICAgICBjb25zdCBuZXdNZWFzdXJlZENvbHVtbldpZHRocyA9IG5ldyBNYXAobWVhc3VyZWRDb2x1bW5XaWR0aHMpO1xuICAgICAgbGV0IGhhc0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGNvbHVtbnNUb01lYXN1cmUpIHtcbiAgICAgICAgY29uc3QgbWVhc3VyZWRXaWR0aCA9IG1lYXN1cmVDb2x1bW5XaWR0aChncmlkUmVmLCBrZXkpO1xuICAgICAgICBoYXNDaGFuZ2VzIHx8PSBtZWFzdXJlZFdpZHRoICE9PSBtZWFzdXJlZENvbHVtbldpZHRocy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKG1lYXN1cmVkV2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5ld01lYXN1cmVkQ29sdW1uV2lkdGhzLmRlbGV0ZShrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld01lYXN1cmVkQ29sdW1uV2lkdGhzLnNldChrZXksIG1lYXN1cmVkV2lkdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzQ2hhbmdlcyA/IG5ld01lYXN1cmVkQ29sdW1uV2lkdGhzIDogbWVhc3VyZWRDb2x1bW5XaWR0aHM7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlQ29sdW1uUmVzaXplKGNvbHVtbiwgbmV4dFdpZHRoKSB7XG4gICAgY29uc3Qge1xuICAgICAga2V5OiByZXNpemluZ0tleVxuICAgIH0gPSBjb2x1bW47XG4gICAgY29uc3QgbmV3VGVtcGxhdGVDb2x1bW5zID0gWy4uLnRlbXBsYXRlQ29sdW1uc107XG4gICAgY29uc3QgY29sdW1uc1RvTWVhc3VyZSA9IFtdO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAga2V5LFxuICAgICAgaWR4LFxuICAgICAgd2lkdGhcbiAgICB9IG9mIHZpZXdwb3J0Q29sdW1ucykge1xuICAgICAgaWYgKHJlc2l6aW5nS2V5ID09PSBrZXkpIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0eXBlb2YgbmV4dFdpZHRoID09PSAnbnVtYmVyJyA/IGAke25leHRXaWR0aH1weGAgOiBuZXh0V2lkdGg7XG4gICAgICAgIG5ld1RlbXBsYXRlQ29sdW1uc1tpZHhdID0gd2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKGNvbHVtbnNDYW5GbGV4ICYmIHR5cGVvZiB3aWR0aCA9PT0gJ3N0cmluZycgJiYgIXJlc2l6ZWRDb2x1bW5XaWR0aHMuaGFzKGtleSkpIHtcbiAgICAgICAgbmV3VGVtcGxhdGVDb2x1bW5zW2lkeF0gPSB3aWR0aDtcbiAgICAgICAgY29sdW1uc1RvTWVhc3VyZS5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGdyaWRSZWYuY3VycmVudC5zdHlsZS5ncmlkVGVtcGxhdGVDb2x1bW5zID0gbmV3VGVtcGxhdGVDb2x1bW5zLmpvaW4oJyAnKTtcbiAgICBjb25zdCBtZWFzdXJlZFdpZHRoID0gdHlwZW9mIG5leHRXaWR0aCA9PT0gJ251bWJlcicgPyBuZXh0V2lkdGggOiBtZWFzdXJlQ29sdW1uV2lkdGgoZ3JpZFJlZiwgcmVzaXppbmdLZXkpO1xuICAgIGZsdXNoU3luYygoKSA9PiB7XG4gICAgICBzZXRSZXNpemVkQ29sdW1uV2lkdGhzKHJlc2l6ZWRDb2x1bW5XaWR0aHMgPT4ge1xuICAgICAgICBjb25zdCBuZXdSZXNpemVkQ29sdW1uV2lkdGhzID0gbmV3IE1hcChyZXNpemVkQ29sdW1uV2lkdGhzKTtcbiAgICAgICAgbmV3UmVzaXplZENvbHVtbldpZHRocy5zZXQocmVzaXppbmdLZXksIG1lYXN1cmVkV2lkdGgpO1xuICAgICAgICByZXR1cm4gbmV3UmVzaXplZENvbHVtbldpZHRocztcbiAgICAgIH0pO1xuICAgICAgdXBkYXRlTWVhc3VyZWRXaWR0aHMoY29sdW1uc1RvTWVhc3VyZSk7XG4gICAgfSk7XG4gICAgb25Db2x1bW5SZXNpemU/Lihjb2x1bW4uaWR4LCBtZWFzdXJlZFdpZHRoKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdyaWRUZW1wbGF0ZUNvbHVtbnMsXG4gICAgaGFuZGxlQ29sdW1uUmVzaXplXG4gIH07XG59XG5mdW5jdGlvbiBtZWFzdXJlQ29sdW1uV2lkdGgoZ3JpZFJlZiwga2V5KSB7XG4gIGNvbnN0IHNlbGVjdG9yID0gYFtkYXRhLW1lYXN1cmluZy1jZWxsLWtleT1cIiR7Q1NTLmVzY2FwZShrZXkpfVwiXWA7XG4gIGNvbnN0IG1lYXN1cmluZ0NlbGwgPSBncmlkUmVmLmN1cnJlbnQ/LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICByZXR1cm4gbWVhc3VyaW5nQ2VsbD8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG59XG5cbmZ1bmN0aW9uIHVzZUdyaWREaW1lbnNpb25zKCkge1xuICBjb25zdCBncmlkUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbaW5saW5lU2l6ZSwgc2V0SW5saW5lU2l6ZV0gPSB1c2VTdGF0ZSgxKTtcbiAgY29uc3QgW2Jsb2NrU2l6ZSwgc2V0QmxvY2tTaXplXSA9IHVzZVN0YXRlKDEpO1xuICBjb25zdCBbaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCwgc2V0SG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodF0gPSB1c2VTdGF0ZSgwKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBSZXNpemVPYnNlcnZlclxuICAgIH0gPSB3aW5kb3c7XG4gICAgaWYgKFJlc2l6ZU9ic2VydmVyID09IG51bGwpIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBjbGllbnRXaWR0aCxcbiAgICAgIGNsaWVudEhlaWdodCxcbiAgICAgIG9mZnNldFdpZHRoLFxuICAgICAgb2Zmc2V0SGVpZ2h0XG4gICAgfSA9IGdyaWRSZWYuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBncmlkUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgaW5pdGlhbEhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQgPSBvZmZzZXRIZWlnaHQgLSBjbGllbnRIZWlnaHQ7XG4gICAgY29uc3QgaW5pdGlhbFdpZHRoID0gd2lkdGggLSBvZmZzZXRXaWR0aCArIGNsaWVudFdpZHRoO1xuICAgIGNvbnN0IGluaXRpYWxIZWlnaHQgPSBoZWlnaHQgLSBpbml0aWFsSG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodDtcbiAgICBzZXRJbmxpbmVTaXplKGluaXRpYWxXaWR0aCk7XG4gICAgc2V0QmxvY2tTaXplKGluaXRpYWxIZWlnaHQpO1xuICAgIHNldEhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQoaW5pdGlhbEhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQpO1xuICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgY29uc3Qgc2l6ZSA9IGVudHJpZXNbMF0uY29udGVudEJveFNpemVbMF07XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsaWVudEhlaWdodCxcbiAgICAgICAgb2Zmc2V0SGVpZ2h0XG4gICAgICB9ID0gZ3JpZFJlZi5jdXJyZW50O1xuICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgc2V0SW5saW5lU2l6ZShzaXplLmlubGluZVNpemUpO1xuICAgICAgICBzZXRCbG9ja1NpemUoc2l6ZS5ibG9ja1NpemUpO1xuICAgICAgICBzZXRIb3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0KG9mZnNldEhlaWdodCAtIGNsaWVudEhlaWdodCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGdyaWRSZWYuY3VycmVudCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBbZ3JpZFJlZiwgaW5saW5lU2l6ZSwgYmxvY2tTaXplLCBob3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0XTtcbn1cblxuZnVuY3Rpb24gdXNlTGF0ZXN0RnVuYyhmbikge1xuICBjb25zdCByZWYgPSB1c2VSZWYoZm4pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gZm47XG4gIH0pO1xuICBjb25zdCBjYWxsYmFja0ZuID0gdXNlQ2FsbGJhY2soKC4uLmFyZ3MpID0+IHtcbiAgICByZWYuY3VycmVudCguLi5hcmdzKTtcbiAgfSwgW10pO1xuICByZXR1cm4gZm4gPyBjYWxsYmFja0ZuIDogZm47XG59XG5cbmZ1bmN0aW9uIHVzZVJvdmluZ1RhYkluZGV4KGlzU2VsZWN0ZWQpIHtcbiAgY29uc3QgW2lzQ2hpbGRGb2N1c2VkLCBzZXRJc0NoaWxkRm9jdXNlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGlmIChpc0NoaWxkRm9jdXNlZCAmJiAhaXNTZWxlY3RlZCkge1xuICAgIHNldElzQ2hpbGRGb2N1c2VkKGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBvbkZvY3VzKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gZXZlbnQuY3VycmVudFRhcmdldCkge1xuICAgICAgc2V0SXNDaGlsZEZvY3VzZWQodHJ1ZSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGlzRm9jdXNhYmxlID0gaXNTZWxlY3RlZCAmJiAhaXNDaGlsZEZvY3VzZWQ7XG4gIHJldHVybiB7XG4gICAgdGFiSW5kZXg6IGlzRm9jdXNhYmxlID8gMCA6IC0xLFxuICAgIGNoaWxkVGFiSW5kZXg6IGlzU2VsZWN0ZWQgPyAwIDogLTEsXG4gICAgb25Gb2N1czogaXNTZWxlY3RlZCA/IG9uRm9jdXMgOiB1bmRlZmluZWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlVmlld3BvcnRDb2x1bW5zKHtcbiAgY29sdW1ucyxcbiAgY29sU3BhbkNvbHVtbnMsXG4gIHJvd3MsXG4gIHRvcFN1bW1hcnlSb3dzLFxuICBib3R0b21TdW1tYXJ5Um93cyxcbiAgY29sT3ZlcnNjYW5TdGFydElkeCxcbiAgY29sT3ZlcnNjYW5FbmRJZHgsXG4gIGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgcm93T3ZlcnNjYW5TdGFydElkeCxcbiAgcm93T3ZlcnNjYW5FbmRJZHhcbn0pIHtcbiAgY29uc3Qgc3RhcnRJZHggPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoY29sT3ZlcnNjYW5TdGFydElkeCA9PT0gMCkgcmV0dXJuIDA7XG4gICAgbGV0IHN0YXJ0SWR4ID0gY29sT3ZlcnNjYW5TdGFydElkeDtcbiAgICBjb25zdCB1cGRhdGVTdGFydElkeCA9IChjb2xJZHgsIGNvbFNwYW4pID0+IHtcbiAgICAgIGlmIChjb2xTcGFuICE9PSB1bmRlZmluZWQgJiYgY29sSWR4ICsgY29sU3BhbiA+IGNvbE92ZXJzY2FuU3RhcnRJZHgpIHtcbiAgICAgICAgc3RhcnRJZHggPSBjb2xJZHg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgZm9yIChjb25zdCBjb2x1bW4gb2YgY29sU3BhbkNvbHVtbnMpIHtcbiAgICAgIGNvbnN0IGNvbElkeCA9IGNvbHVtbi5pZHg7XG4gICAgICBpZiAoY29sSWR4ID49IHN0YXJ0SWR4KSBicmVhaztcbiAgICAgIGlmICh1cGRhdGVTdGFydElkeChjb2xJZHgsIGdldENvbFNwYW4oY29sdW1uLCBsYXN0RnJvemVuQ29sdW1uSW5kZXgsIHtcbiAgICAgICAgdHlwZTogJ0hFQURFUidcbiAgICAgIH0pKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHJvd0lkeCA9IHJvd092ZXJzY2FuU3RhcnRJZHg7IHJvd0lkeCA8PSByb3dPdmVyc2NhbkVuZElkeDsgcm93SWR4KyspIHtcbiAgICAgICAgY29uc3Qgcm93ID0gcm93c1tyb3dJZHhdO1xuICAgICAgICBpZiAodXBkYXRlU3RhcnRJZHgoY29sSWR4LCBnZXRDb2xTcGFuKGNvbHVtbiwgbGFzdEZyb3plbkNvbHVtbkluZGV4LCB7XG4gICAgICAgICAgdHlwZTogJ1JPVycsXG4gICAgICAgICAgcm93XG4gICAgICAgIH0pKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodG9wU3VtbWFyeVJvd3MgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0b3BTdW1tYXJ5Um93cykge1xuICAgICAgICAgIGlmICh1cGRhdGVTdGFydElkeChjb2xJZHgsIGdldENvbFNwYW4oY29sdW1uLCBsYXN0RnJvemVuQ29sdW1uSW5kZXgsIHtcbiAgICAgICAgICAgIHR5cGU6ICdTVU1NQVJZJyxcbiAgICAgICAgICAgIHJvd1xuICAgICAgICAgIH0pKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYm90dG9tU3VtbWFyeVJvd3MgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiBib3R0b21TdW1tYXJ5Um93cykge1xuICAgICAgICAgIGlmICh1cGRhdGVTdGFydElkeChjb2xJZHgsIGdldENvbFNwYW4oY29sdW1uLCBsYXN0RnJvemVuQ29sdW1uSW5kZXgsIHtcbiAgICAgICAgICAgIHR5cGU6ICdTVU1NQVJZJyxcbiAgICAgICAgICAgIHJvd1xuICAgICAgICAgIH0pKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGFydElkeDtcbiAgfSwgW3Jvd092ZXJzY2FuU3RhcnRJZHgsIHJvd092ZXJzY2FuRW5kSWR4LCByb3dzLCB0b3BTdW1tYXJ5Um93cywgYm90dG9tU3VtbWFyeVJvd3MsIGNvbE92ZXJzY2FuU3RhcnRJZHgsIGxhc3RGcm96ZW5Db2x1bW5JbmRleCwgY29sU3BhbkNvbHVtbnNdKTtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHZpZXdwb3J0Q29sdW1ucyA9IFtdO1xuICAgIGZvciAobGV0IGNvbElkeCA9IDA7IGNvbElkeCA8PSBjb2xPdmVyc2NhbkVuZElkeDsgY29sSWR4KyspIHtcbiAgICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnNbY29sSWR4XTtcbiAgICAgIGlmIChjb2xJZHggPCBzdGFydElkeCAmJiAhY29sdW1uLmZyb3plbikgY29udGludWU7XG4gICAgICB2aWV3cG9ydENvbHVtbnMucHVzaChjb2x1bW4pO1xuICAgIH1cbiAgICByZXR1cm4gdmlld3BvcnRDb2x1bW5zO1xuICB9LCBbc3RhcnRJZHgsIGNvbE92ZXJzY2FuRW5kSWR4LCBjb2x1bW5zXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVZpZXdwb3J0Um93cyh7XG4gIHJvd3MsXG4gIHJvd0hlaWdodCxcbiAgY2xpZW50SGVpZ2h0LFxuICBzY3JvbGxUb3AsXG4gIGVuYWJsZVZpcnR1YWxpemF0aW9uXG59KSB7XG4gIGNvbnN0IHtcbiAgICB0b3RhbFJvd0hlaWdodCxcbiAgICBncmlkVGVtcGxhdGVSb3dzLFxuICAgIGdldFJvd1RvcCxcbiAgICBnZXRSb3dIZWlnaHQsXG4gICAgZmluZFJvd0lkeFxuICB9ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiByb3dIZWlnaHQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3RhbFJvd0hlaWdodDogcm93SGVpZ2h0ICogcm93cy5sZW5ndGgsXG4gICAgICAgIGdyaWRUZW1wbGF0ZVJvd3M6IGAgcmVwZWF0KCR7cm93cy5sZW5ndGh9LCAke3Jvd0hlaWdodH1weClgLFxuICAgICAgICBnZXRSb3dUb3A6IHJvd0lkeCA9PiByb3dJZHggKiByb3dIZWlnaHQsXG4gICAgICAgIGdldFJvd0hlaWdodDogKCkgPT4gcm93SGVpZ2h0LFxuICAgICAgICBmaW5kUm93SWR4OiBvZmZzZXQgPT4gZmxvb3Iob2Zmc2V0IC8gcm93SGVpZ2h0KVxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHRvdGFsUm93SGVpZ2h0ID0gMDtcbiAgICBsZXQgZ3JpZFRlbXBsYXRlUm93cyA9ICcgJztcbiAgICBjb25zdCByb3dQb3NpdGlvbnMgPSByb3dzLm1hcChyb3cgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFJvd0hlaWdodCA9IHJvd0hlaWdodChyb3cpO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSB7XG4gICAgICAgIHRvcDogdG90YWxSb3dIZWlnaHQsXG4gICAgICAgIGhlaWdodDogY3VycmVudFJvd0hlaWdodFxuICAgICAgfTtcbiAgICAgIGdyaWRUZW1wbGF0ZVJvd3MgKz0gYCR7Y3VycmVudFJvd0hlaWdodH1weCBgO1xuICAgICAgdG90YWxSb3dIZWlnaHQgKz0gY3VycmVudFJvd0hlaWdodDtcbiAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9KTtcbiAgICBjb25zdCB2YWxpZGF0ZVJvd0lkeCA9IHJvd0lkeCA9PiB7XG4gICAgICByZXR1cm4gbWF4KDAsIG1pbihyb3dzLmxlbmd0aCAtIDEsIHJvd0lkeCkpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsUm93SGVpZ2h0LFxuICAgICAgZ3JpZFRlbXBsYXRlUm93cyxcbiAgICAgIGdldFJvd1RvcDogcm93SWR4ID0+IHJvd1Bvc2l0aW9uc1t2YWxpZGF0ZVJvd0lkeChyb3dJZHgpXS50b3AsXG4gICAgICBnZXRSb3dIZWlnaHQ6IHJvd0lkeCA9PiByb3dQb3NpdGlvbnNbdmFsaWRhdGVSb3dJZHgocm93SWR4KV0uaGVpZ2h0LFxuICAgICAgZmluZFJvd0lkeChvZmZzZXQpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IGVuZCA9IHJvd1Bvc2l0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgICAgICAgY29uc3QgbWlkZGxlID0gc3RhcnQgKyBmbG9vcigoZW5kIC0gc3RhcnQpIC8gMik7XG4gICAgICAgICAgY29uc3QgY3VycmVudE9mZnNldCA9IHJvd1Bvc2l0aW9uc1ttaWRkbGVdLnRvcDtcbiAgICAgICAgICBpZiAoY3VycmVudE9mZnNldCA9PT0gb2Zmc2V0KSByZXR1cm4gbWlkZGxlO1xuICAgICAgICAgIGlmIChjdXJyZW50T2Zmc2V0IDwgb2Zmc2V0KSB7XG4gICAgICAgICAgICBzdGFydCA9IG1pZGRsZSArIDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50T2Zmc2V0ID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICBlbmQgPSBtaWRkbGUgLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3Jvd0hlaWdodCwgcm93c10pO1xuICBsZXQgcm93T3ZlcnNjYW5TdGFydElkeCA9IDA7XG4gIGxldCByb3dPdmVyc2NhbkVuZElkeCA9IHJvd3MubGVuZ3RoIC0gMTtcbiAgaWYgKGVuYWJsZVZpcnR1YWxpemF0aW9uKSB7XG4gICAgY29uc3Qgb3ZlcnNjYW5UaHJlc2hvbGQgPSA0O1xuICAgIGNvbnN0IHJvd1Zpc2libGVTdGFydElkeCA9IGZpbmRSb3dJZHgoc2Nyb2xsVG9wKTtcbiAgICBjb25zdCByb3dWaXNpYmxlRW5kSWR4ID0gZmluZFJvd0lkeChzY3JvbGxUb3AgKyBjbGllbnRIZWlnaHQpO1xuICAgIHJvd092ZXJzY2FuU3RhcnRJZHggPSBtYXgoMCwgcm93VmlzaWJsZVN0YXJ0SWR4IC0gb3ZlcnNjYW5UaHJlc2hvbGQpO1xuICAgIHJvd092ZXJzY2FuRW5kSWR4ID0gbWluKHJvd3MubGVuZ3RoIC0gMSwgcm93VmlzaWJsZUVuZElkeCArIG92ZXJzY2FuVGhyZXNob2xkKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJvd092ZXJzY2FuU3RhcnRJZHgsXG4gICAgcm93T3ZlcnNjYW5FbmRJZHgsXG4gICAgdG90YWxSb3dIZWlnaHQsXG4gICAgZ3JpZFRlbXBsYXRlUm93cyxcbiAgICBnZXRSb3dUb3AsXG4gICAgZ2V0Um93SGVpZ2h0LFxuICAgIGZpbmRSb3dJZHhcbiAgfTtcbn1cblxuY29uc3QgY2VsbERyYWdIYW5kbGUgPSBcImMxdzliYmhyNy0wLTAtYmV0YS00NlwiO1xuY29uc3QgY2VsbERyYWdIYW5kbGVGcm96ZW5DbGFzc25hbWUgPSBcImMxY3Jlb3JjNy0wLTAtYmV0YS00NlwiO1xuY29uc3QgY2VsbERyYWdIYW5kbGVDbGFzc25hbWUgPSBgcmRnLWNlbGwtZHJhZy1oYW5kbGUgJHtjZWxsRHJhZ0hhbmRsZX1gO1xuZnVuY3Rpb24gRHJhZ0hhbmRsZSh7XG4gIGdyaWRSb3dTdGFydCxcbiAgcm93cyxcbiAgY29sdW1uLFxuICBjb2x1bW5XaWR0aCxcbiAgbWF4Q29sSWR4LFxuICBpc0xhc3RSb3csXG4gIHNlbGVjdGVkUG9zaXRpb24sXG4gIGxhdGVzdERyYWdnZWRPdmVyUm93SWR4LFxuICBpc0NlbGxFZGl0YWJsZSxcbiAgb25Sb3dzQ2hhbmdlLFxuICBvbkZpbGwsXG4gIG9uQ2xpY2ssXG4gIHNldERyYWdnaW5nLFxuICBzZXREcmFnZ2VkT3ZlclJvd0lkeFxufSkge1xuICBjb25zdCB7XG4gICAgaWR4LFxuICAgIHJvd0lkeFxuICB9ID0gc2VsZWN0ZWRQb3NpdGlvbjtcbiAgZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoZXZlbnQuYnV0dG9ucyAhPT0gMSkgcmV0dXJuO1xuICAgIHNldERyYWdnaW5nKHRydWUpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBvbk1vdXNlT3Zlcik7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgIGZ1bmN0aW9uIG9uTW91c2VPdmVyKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuYnV0dG9ucyAhPT0gMSkgb25Nb3VzZVVwKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VVcCgpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBvbk1vdXNlT3Zlcik7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICBzZXREcmFnZ2luZyhmYWxzZSk7XG4gICAgICBoYW5kbGVEcmFnRW5kKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZURyYWdFbmQoKSB7XG4gICAgY29uc3Qgb3ZlclJvd0lkeCA9IGxhdGVzdERyYWdnZWRPdmVyUm93SWR4LmN1cnJlbnQ7XG4gICAgaWYgKG92ZXJSb3dJZHggPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIGNvbnN0IHN0YXJ0Um93SW5kZXggPSByb3dJZHggPCBvdmVyUm93SWR4ID8gcm93SWR4ICsgMSA6IG92ZXJSb3dJZHg7XG4gICAgY29uc3QgZW5kUm93SW5kZXggPSByb3dJZHggPCBvdmVyUm93SWR4ID8gb3ZlclJvd0lkeCArIDEgOiByb3dJZHg7XG4gICAgdXBkYXRlUm93cyhzdGFydFJvd0luZGV4LCBlbmRSb3dJbmRleCk7XG4gICAgc2V0RHJhZ2dlZE92ZXJSb3dJZHgodW5kZWZpbmVkKTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVEb3VibGVDbGljayhldmVudCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHVwZGF0ZVJvd3Mocm93SWR4ICsgMSwgcm93cy5sZW5ndGgpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVJvd3Moc3RhcnRSb3dJZHgsIGVuZFJvd0lkeCkge1xuICAgIGNvbnN0IHNvdXJjZVJvdyA9IHJvd3Nbcm93SWR4XTtcbiAgICBjb25zdCB1cGRhdGVkUm93cyA9IFsuLi5yb3dzXTtcbiAgICBjb25zdCBpbmRleGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0Um93SWR4OyBpIDwgZW5kUm93SWR4OyBpKyspIHtcbiAgICAgIGlmIChpc0NlbGxFZGl0YWJsZSh7XG4gICAgICAgIHJvd0lkeDogaSxcbiAgICAgICAgaWR4XG4gICAgICB9KSkge1xuICAgICAgICBjb25zdCB1cGRhdGVkUm93ID0gb25GaWxsKHtcbiAgICAgICAgICBjb2x1bW5LZXk6IGNvbHVtbi5rZXksXG4gICAgICAgICAgc291cmNlUm93LFxuICAgICAgICAgIHRhcmdldFJvdzogcm93c1tpXVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHVwZGF0ZWRSb3cgIT09IHJvd3NbaV0pIHtcbiAgICAgICAgICB1cGRhdGVkUm93c1tpXSA9IHVwZGF0ZWRSb3c7XG4gICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbmRleGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIG9uUm93c0NoYW5nZT8uKHVwZGF0ZWRSb3dzLCB7XG4gICAgICAgIGluZGV4ZXMsXG4gICAgICAgIGNvbHVtblxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFN0eWxlKCkge1xuICAgIGNvbnN0IGNvbFNwYW4gPSBjb2x1bW4uY29sU3Bhbj8uKHtcbiAgICAgIHR5cGU6ICdST1cnLFxuICAgICAgcm93OiByb3dzW3Jvd0lkeF1cbiAgICB9KSA/PyAxO1xuICAgIGNvbnN0IHtcbiAgICAgIGluc2V0SW5saW5lU3RhcnQsXG4gICAgICAuLi5zdHlsZVxuICAgIH0gPSBnZXRDZWxsU3R5bGUoY29sdW1uLCBjb2xTcGFuKTtcbiAgICBjb25zdCBtYXJnaW5FbmQgPSAnY2FsYyh2YXIoLS1yZGctZHJhZy1oYW5kbGUtc2l6ZSkgKiAtMC41ICsgMXB4KSc7XG4gICAgY29uc3QgaXNMYXN0Q29sdW1uID0gY29sdW1uLmlkeCArIGNvbFNwYW4gLSAxID09PSBtYXhDb2xJZHg7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0eWxlLFxuICAgICAgZ3JpZFJvd1N0YXJ0LFxuICAgICAgbWFyZ2luSW5saW5lRW5kOiBpc0xhc3RDb2x1bW4gPyB1bmRlZmluZWQgOiBtYXJnaW5FbmQsXG4gICAgICBtYXJnaW5CbG9ja0VuZDogaXNMYXN0Um93ID8gdW5kZWZpbmVkIDogbWFyZ2luRW5kLFxuICAgICAgaW5zZXRJbmxpbmVTdGFydDogaW5zZXRJbmxpbmVTdGFydCA/IGBjYWxjKCR7aW5zZXRJbmxpbmVTdGFydH0gKyAke2NvbHVtbldpZHRofXB4ICsgdmFyKC0tcmRnLWRyYWctaGFuZGxlLXNpemUpICogLTAuNSAtIDFweClgIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChcImRpdlwiLCB7XG4gICAgc3R5bGU6IGdldFN0eWxlKCksXG4gICAgY2xhc3NOYW1lOiBjbHN4KGNlbGxEcmFnSGFuZGxlQ2xhc3NuYW1lLCBjb2x1bW4uZnJvemVuICYmIGNlbGxEcmFnSGFuZGxlRnJvemVuQ2xhc3NuYW1lKSxcbiAgICBvbkNsaWNrOiBvbkNsaWNrLFxuICAgIG9uTW91c2VEb3duOiBoYW5kbGVNb3VzZURvd24sXG4gICAgb25Eb3VibGVDbGljazogaGFuZGxlRG91YmxlQ2xpY2tcbiAgfSk7XG59XG5cbmNvbnN0IGNlbGxFZGl0aW5nID0gXCJjaXM1cnJtNy0wLTAtYmV0YS00NlwiO1xuZnVuY3Rpb24gRWRpdENlbGwoe1xuICBjb2x1bW4sXG4gIGNvbFNwYW4sXG4gIHJvdyxcbiAgcm93SWR4LFxuICBvblJvd0NoYW5nZSxcbiAgY2xvc2VFZGl0b3IsXG4gIG9uS2V5RG93bixcbiAgbmF2aWdhdGVcbn0pIHtcbiAgY29uc3QgZnJhbWVSZXF1ZXN0UmVmID0gdXNlUmVmKHVuZGVmaW5lZCk7XG4gIGNvbnN0IGNvbW1pdE9uT3V0c2lkZUNsaWNrID0gY29sdW1uLmVkaXRvck9wdGlvbnM/LmNvbW1pdE9uT3V0c2lkZUNsaWNrICE9PSBmYWxzZTtcbiAgY29uc3QgY29tbWl0T25PdXRzaWRlTW91c2VEb3duID0gdXNlTGF0ZXN0RnVuYygoKSA9PiB7XG4gICAgb25DbG9zZSh0cnVlLCBmYWxzZSk7XG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY29tbWl0T25PdXRzaWRlQ2xpY2spIHJldHVybjtcbiAgICBmdW5jdGlvbiBvbldpbmRvd0NhcHR1cmVNb3VzZURvd24oKSB7XG4gICAgICBmcmFtZVJlcXVlc3RSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShjb21taXRPbk91dHNpZGVNb3VzZURvd24pO1xuICAgIH1cbiAgICBhZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbldpbmRvd0NhcHR1cmVNb3VzZURvd24sIHtcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25XaW5kb3dDYXB0dXJlTW91c2VEb3duLCB7XG4gICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY2FuY2VsRnJhbWVSZXF1ZXN0KCk7XG4gICAgfTtcbiAgfSwgW2NvbW1pdE9uT3V0c2lkZUNsaWNrLCBjb21taXRPbk91dHNpZGVNb3VzZURvd25dKTtcbiAgZnVuY3Rpb24gY2FuY2VsRnJhbWVSZXF1ZXN0KCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lUmVxdWVzdFJlZi5jdXJyZW50KTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgaWYgKG9uS2V5RG93bikge1xuICAgICAgY29uc3QgY2VsbEV2ZW50ID0gY3JlYXRlQ2VsbEV2ZW50KGV2ZW50KTtcbiAgICAgIG9uS2V5RG93bih7XG4gICAgICAgIG1vZGU6ICdFRElUJyxcbiAgICAgICAgcm93LFxuICAgICAgICBjb2x1bW4sXG4gICAgICAgIHJvd0lkeCxcbiAgICAgICAgbmF2aWdhdGUoKSB7XG4gICAgICAgICAgbmF2aWdhdGUoZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBvbkNsb3NlXG4gICAgICB9LCBjZWxsRXZlbnQpO1xuICAgICAgaWYgKGNlbGxFdmVudC5pc0dyaWREZWZhdWx0UHJldmVudGVkKCkpIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgIG9uQ2xvc2UoKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgb25DbG9zZSh0cnVlKTtcbiAgICB9IGVsc2UgaWYgKG9uRWRpdG9yTmF2aWdhdGlvbihldmVudCkpIHtcbiAgICAgIG5hdmlnYXRlKGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25DbG9zZShjb21taXRDaGFuZ2VzID0gZmFsc2UsIHNob3VsZEZvY3VzQ2VsbCA9IHRydWUpIHtcbiAgICBpZiAoY29tbWl0Q2hhbmdlcykge1xuICAgICAgb25Sb3dDaGFuZ2Uocm93LCB0cnVlLCBzaG91bGRGb2N1c0NlbGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZUVkaXRvcihzaG91bGRGb2N1c0NlbGwpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvbkVkaXRvclJvd0NoYW5nZShyb3csIGNvbW1pdENoYW5nZXNBbmRGb2N1cyA9IGZhbHNlKSB7XG4gICAgb25Sb3dDaGFuZ2Uocm93LCBjb21taXRDaGFuZ2VzQW5kRm9jdXMsIGNvbW1pdENoYW5nZXNBbmRGb2N1cyk7XG4gIH1cbiAgY29uc3Qge1xuICAgIGNlbGxDbGFzc1xuICB9ID0gY29sdW1uO1xuICBjb25zdCBjbGFzc05hbWUgPSBnZXRDZWxsQ2xhc3NuYW1lKGNvbHVtbiwgJ3JkZy1lZGl0b3ItY29udGFpbmVyJywgdHlwZW9mIGNlbGxDbGFzcyA9PT0gJ2Z1bmN0aW9uJyA/IGNlbGxDbGFzcyhyb3cpIDogY2VsbENsYXNzLCAhY29sdW1uLmVkaXRvck9wdGlvbnM/LmRpc3BsYXlDZWxsQ29udGVudCAmJiBjZWxsRWRpdGluZyk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICByb2xlOiBcImdyaWRjZWxsXCIsXG4gICAgXCJhcmlhLWNvbGluZGV4XCI6IGNvbHVtbi5pZHggKyAxLFxuICAgIFwiYXJpYS1jb2xzcGFuXCI6IGNvbFNwYW4sXG4gICAgXCJhcmlhLXNlbGVjdGVkXCI6IHRydWUsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgc3R5bGU6IGdldENlbGxTdHlsZShjb2x1bW4sIGNvbFNwYW4pLFxuICAgIG9uS2V5RG93bjogaGFuZGxlS2V5RG93bixcbiAgICBvbk1vdXNlRG93bkNhcHR1cmU6IGNhbmNlbEZyYW1lUmVxdWVzdCxcbiAgICBjaGlsZHJlbjogY29sdW1uLnJlbmRlckVkaXRDZWxsICE9IG51bGwgJiYgLyojX19QVVJFX18qL2pzeHMoRnJhZ21lbnQsIHtcbiAgICAgIGNoaWxkcmVuOiBbY29sdW1uLnJlbmRlckVkaXRDZWxsKHtcbiAgICAgICAgY29sdW1uLFxuICAgICAgICByb3csXG4gICAgICAgIHJvd0lkeCxcbiAgICAgICAgb25Sb3dDaGFuZ2U6IG9uRWRpdG9yUm93Q2hhbmdlLFxuICAgICAgICBvbkNsb3NlXG4gICAgICB9KSwgY29sdW1uLmVkaXRvck9wdGlvbnM/LmRpc3BsYXlDZWxsQ29udGVudCAmJiBjb2x1bW4ucmVuZGVyQ2VsbCh7XG4gICAgICAgIGNvbHVtbixcbiAgICAgICAgcm93LFxuICAgICAgICByb3dJZHgsXG4gICAgICAgIGlzQ2VsbEVkaXRhYmxlOiB0cnVlLFxuICAgICAgICB0YWJJbmRleDogLTEsXG4gICAgICAgIG9uUm93Q2hhbmdlOiBvbkVkaXRvclJvd0NoYW5nZVxuICAgICAgfSldXG4gICAgfSlcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIEdyb3VwZWRDb2x1bW5IZWFkZXJDZWxsKHtcbiAgY29sdW1uLFxuICByb3dJZHgsXG4gIGlzQ2VsbFNlbGVjdGVkLFxuICBzZWxlY3RDZWxsXG59KSB7XG4gIGNvbnN0IHtcbiAgICB0YWJJbmRleCxcbiAgICBvbkZvY3VzXG4gIH0gPSB1c2VSb3ZpbmdUYWJJbmRleChpc0NlbGxTZWxlY3RlZCk7XG4gIGNvbnN0IHtcbiAgICBjb2xTcGFuXG4gIH0gPSBjb2x1bW47XG4gIGNvbnN0IHJvd1NwYW4gPSBnZXRIZWFkZXJDZWxsUm93U3Bhbihjb2x1bW4sIHJvd0lkeCk7XG4gIGNvbnN0IGluZGV4ID0gY29sdW1uLmlkeCArIDE7XG4gIGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgc2VsZWN0Q2VsbCh7XG4gICAgICBpZHg6IGNvbHVtbi5pZHgsXG4gICAgICByb3dJZHhcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChcImRpdlwiLCB7XG4gICAgcm9sZTogXCJjb2x1bW5oZWFkZXJcIixcbiAgICBcImFyaWEtY29saW5kZXhcIjogaW5kZXgsXG4gICAgXCJhcmlhLWNvbHNwYW5cIjogY29sU3BhbixcbiAgICBcImFyaWEtcm93c3BhblwiOiByb3dTcGFuLFxuICAgIFwiYXJpYS1zZWxlY3RlZFwiOiBpc0NlbGxTZWxlY3RlZCxcbiAgICB0YWJJbmRleDogdGFiSW5kZXgsXG4gICAgY2xhc3NOYW1lOiBjbHN4KGNlbGxDbGFzc25hbWUsIGNvbHVtbi5oZWFkZXJDZWxsQ2xhc3MpLFxuICAgIHN0eWxlOiB7XG4gICAgICAuLi5nZXRIZWFkZXJDZWxsU3R5bGUoY29sdW1uLCByb3dJZHgsIHJvd1NwYW4pLFxuICAgICAgZ3JpZENvbHVtblN0YXJ0OiBpbmRleCxcbiAgICAgIGdyaWRDb2x1bW5FbmQ6IGluZGV4ICsgY29sU3BhblxuICAgIH0sXG4gICAgb25Gb2N1czogb25Gb2N1cyxcbiAgICBvbkNsaWNrOiBvbkNsaWNrLFxuICAgIGNoaWxkcmVuOiBjb2x1bW4ubmFtZVxuICB9KTtcbn1cblxuY29uc3QgaGVhZGVyU29ydENlbGxDbGFzc25hbWUgPSBcImg0NGp0azY3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCBoZWFkZXJTb3J0TmFtZSA9IFwiaGNna2h4ejctMC0wLWJldGEtNDZcIjtcbmNvbnN0IGhlYWRlclNvcnROYW1lQ2xhc3NuYW1lID0gYHJkZy1oZWFkZXItc29ydC1uYW1lICR7aGVhZGVyU29ydE5hbWV9YDtcbmZ1bmN0aW9uIHJlbmRlckhlYWRlckNlbGwoe1xuICBjb2x1bW4sXG4gIHNvcnREaXJlY3Rpb24sXG4gIHByaW9yaXR5XG59KSB7XG4gIGlmICghY29sdW1uLnNvcnRhYmxlKSByZXR1cm4gY29sdW1uLm5hbWU7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFNvcnRhYmxlSGVhZGVyQ2VsbCwge1xuICAgIHNvcnREaXJlY3Rpb246IHNvcnREaXJlY3Rpb24sXG4gICAgcHJpb3JpdHk6IHByaW9yaXR5LFxuICAgIGNoaWxkcmVuOiBjb2x1bW4ubmFtZVxuICB9KTtcbn1cbmZ1bmN0aW9uIFNvcnRhYmxlSGVhZGVyQ2VsbCh7XG4gIHNvcnREaXJlY3Rpb24sXG4gIHByaW9yaXR5LFxuICBjaGlsZHJlblxufSkge1xuICBjb25zdCByZW5kZXJTb3J0U3RhdHVzID0gdXNlRGVmYXVsdFJlbmRlcmVycygpLnJlbmRlclNvcnRTdGF0dXM7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4cyhcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogaGVhZGVyU29ydENlbGxDbGFzc25hbWUsXG4gICAgY2hpbGRyZW46IFsvKiNfX1BVUkVfXyovanN4KFwic3BhblwiLCB7XG4gICAgICBjbGFzc05hbWU6IGhlYWRlclNvcnROYW1lQ2xhc3NuYW1lLFxuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgfSksIC8qI19fUFVSRV9fKi9qc3goXCJzcGFuXCIsIHtcbiAgICAgIGNoaWxkcmVuOiByZW5kZXJTb3J0U3RhdHVzKHtcbiAgICAgICAgc29ydERpcmVjdGlvbixcbiAgICAgICAgcHJpb3JpdHlcbiAgICAgIH0pXG4gICAgfSldXG4gIH0pO1xufVxuXG5jb25zdCBjZWxsU29ydGFibGVDbGFzc25hbWUgPSBcImM2bDJ3djE3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCBjZWxsUmVzaXphYmxlID0gXCJjMWtxZHc3eTctMC0wLWJldGEtNDZcIjtcbmNvbnN0IGNlbGxSZXNpemFibGVDbGFzc25hbWUgPSBgcmRnLWNlbGwtcmVzaXphYmxlICR7Y2VsbFJlc2l6YWJsZX1gO1xuY29uc3QgcmVzaXplSGFuZGxlQ2xhc3NuYW1lID0gXCJyMXk2eXdseDctMC0wLWJldGEtNDZcIjtcbmNvbnN0IGNlbGxEcmFnZ2FibGVDbGFzc25hbWUgPSAncmRnLWNlbGwtZHJhZ2dhYmxlJztcbmNvbnN0IGNlbGxEcmFnZ2luZyA9IFwiYzFiZXpnNW83LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCBjZWxsRHJhZ2dpbmdDbGFzc25hbWUgPSBgcmRnLWNlbGwtZHJhZ2dpbmcgJHtjZWxsRHJhZ2dpbmd9YDtcbmNvbnN0IGNlbGxPdmVyID0gXCJjMXZjOTYwMzctMC0wLWJldGEtNDZcIjtcbmNvbnN0IGNlbGxPdmVyQ2xhc3NuYW1lID0gYHJkZy1jZWxsLWRyYWctb3ZlciAke2NlbGxPdmVyfWA7XG5mdW5jdGlvbiBIZWFkZXJDZWxsKHtcbiAgY29sdW1uLFxuICBjb2xTcGFuLFxuICByb3dJZHgsXG4gIGlzQ2VsbFNlbGVjdGVkLFxuICBvbkNvbHVtblJlc2l6ZSxcbiAgb25Db2x1bW5zUmVvcmRlcixcbiAgc29ydENvbHVtbnMsXG4gIG9uU29ydENvbHVtbnNDaGFuZ2UsXG4gIHNlbGVjdENlbGwsXG4gIHNob3VsZEZvY3VzR3JpZCxcbiAgZGlyZWN0aW9uLFxuICBkcmFnRHJvcEtleVxufSkge1xuICBjb25zdCBbaXNEcmFnZ2luZywgc2V0SXNEcmFnZ2luZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc092ZXIsIHNldElzT3Zlcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IGlzUnRsID0gZGlyZWN0aW9uID09PSAncnRsJztcbiAgY29uc3Qgcm93U3BhbiA9IGdldEhlYWRlckNlbGxSb3dTcGFuKGNvbHVtbiwgcm93SWR4KTtcbiAgY29uc3Qge1xuICAgIHRhYkluZGV4LFxuICAgIGNoaWxkVGFiSW5kZXgsXG4gICAgb25Gb2N1c1xuICB9ID0gdXNlUm92aW5nVGFiSW5kZXgoaXNDZWxsU2VsZWN0ZWQpO1xuICBjb25zdCBzb3J0SW5kZXggPSBzb3J0Q29sdW1ucz8uZmluZEluZGV4KHNvcnQgPT4gc29ydC5jb2x1bW5LZXkgPT09IGNvbHVtbi5rZXkpO1xuICBjb25zdCBzb3J0Q29sdW1uID0gc29ydEluZGV4ICE9PSB1bmRlZmluZWQgJiYgc29ydEluZGV4ID4gLTEgPyBzb3J0Q29sdW1uc1tzb3J0SW5kZXhdIDogdW5kZWZpbmVkO1xuICBjb25zdCBzb3J0RGlyZWN0aW9uID0gc29ydENvbHVtbj8uZGlyZWN0aW9uO1xuICBjb25zdCBwcmlvcml0eSA9IHNvcnRDb2x1bW4gIT09IHVuZGVmaW5lZCAmJiBzb3J0Q29sdW1ucy5sZW5ndGggPiAxID8gc29ydEluZGV4ICsgMSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgYXJpYVNvcnQgPSBzb3J0RGlyZWN0aW9uICYmICFwcmlvcml0eSA/IHNvcnREaXJlY3Rpb24gPT09ICdBU0MnID8gJ2FzY2VuZGluZycgOiAnZGVzY2VuZGluZycgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHtcbiAgICBzb3J0YWJsZSxcbiAgICByZXNpemFibGUsXG4gICAgZHJhZ2dhYmxlXG4gIH0gPSBjb2x1bW47XG4gIGNvbnN0IGNsYXNzTmFtZSA9IGdldENlbGxDbGFzc25hbWUoY29sdW1uLCBjb2x1bW4uaGVhZGVyQ2VsbENsYXNzLCBzb3J0YWJsZSAmJiBjZWxsU29ydGFibGVDbGFzc25hbWUsIHJlc2l6YWJsZSAmJiBjZWxsUmVzaXphYmxlQ2xhc3NuYW1lLCBkcmFnZ2FibGUgJiYgY2VsbERyYWdnYWJsZUNsYXNzbmFtZSwgaXNEcmFnZ2luZyAmJiBjZWxsRHJhZ2dpbmdDbGFzc25hbWUsIGlzT3ZlciAmJiBjZWxsT3ZlckNsYXNzbmFtZSk7XG4gIGNvbnN0IHJlbmRlckhlYWRlckNlbGwkMSA9IGNvbHVtbi5yZW5kZXJIZWFkZXJDZWxsID8/IHJlbmRlckhlYWRlckNlbGw7XG4gIGZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScgJiYgZXZlbnQuYnV0dG9ucyAhPT0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRUYXJnZXQsXG4gICAgICBwb2ludGVySWRcbiAgICB9ID0gZXZlbnQ7XG4gICAgY29uc3QgaGVhZGVyQ2VsbCA9IGN1cnJlbnRUYXJnZXQucGFyZW50RWxlbWVudDtcbiAgICBjb25zdCB7XG4gICAgICByaWdodCxcbiAgICAgIGxlZnRcbiAgICB9ID0gaGVhZGVyQ2VsbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBvZmZzZXQgPSBpc1J0bCA/IGV2ZW50LmNsaWVudFggLSBsZWZ0IDogcmlnaHQgLSBldmVudC5jbGllbnRYO1xuICAgIGZ1bmN0aW9uIG9uUG9pbnRlck1vdmUoZXZlbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmlnaHQsXG4gICAgICAgIGxlZnRcbiAgICAgIH0gPSBoZWFkZXJDZWxsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3Qgd2lkdGggPSBpc1J0bCA/IHJpZ2h0ICsgb2Zmc2V0IC0gZXZlbnQuY2xpZW50WCA6IGV2ZW50LmNsaWVudFggKyBvZmZzZXQgLSBsZWZ0O1xuICAgICAgaWYgKHdpZHRoID4gMCkge1xuICAgICAgICBvbkNvbHVtblJlc2l6ZShjb2x1bW4sIGNsYW1wQ29sdW1uV2lkdGgod2lkdGgsIGNvbHVtbikpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbkxvc3RQb2ludGVyQ2FwdHVyZSgpIHtcbiAgICAgIGN1cnJlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBvblBvaW50ZXJNb3ZlKTtcbiAgICAgIGN1cnJlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9zdHBvaW50ZXJjYXB0dXJlJywgb25Mb3N0UG9pbnRlckNhcHR1cmUpO1xuICAgIH1cbiAgICBjdXJyZW50VGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKHBvaW50ZXJJZCk7XG4gICAgY3VycmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgIGN1cnJlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbG9zdHBvaW50ZXJjYXB0dXJlJywgb25Mb3N0UG9pbnRlckNhcHR1cmUpO1xuICB9XG4gIGZ1bmN0aW9uIG9uU29ydChjdHJsQ2xpY2spIHtcbiAgICBpZiAob25Tb3J0Q29sdW1uc0NoYW5nZSA9PSBudWxsKSByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgc29ydERlc2NlbmRpbmdGaXJzdFxuICAgIH0gPSBjb2x1bW47XG4gICAgaWYgKHNvcnRDb2x1bW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbmV4dFNvcnQgPSB7XG4gICAgICAgIGNvbHVtbktleTogY29sdW1uLmtleSxcbiAgICAgICAgZGlyZWN0aW9uOiBzb3J0RGVzY2VuZGluZ0ZpcnN0ID8gJ0RFU0MnIDogJ0FTQydcbiAgICAgIH07XG4gICAgICBvblNvcnRDb2x1bW5zQ2hhbmdlKHNvcnRDb2x1bW5zICYmIGN0cmxDbGljayA/IFsuLi5zb3J0Q29sdW1ucywgbmV4dFNvcnRdIDogW25leHRTb3J0XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuZXh0U29ydENvbHVtbjtcbiAgICAgIGlmIChzb3J0RGVzY2VuZGluZ0ZpcnN0ID09PSB0cnVlICYmIHNvcnREaXJlY3Rpb24gPT09ICdERVNDJyB8fCBzb3J0RGVzY2VuZGluZ0ZpcnN0ICE9PSB0cnVlICYmIHNvcnREaXJlY3Rpb24gPT09ICdBU0MnKSB7XG4gICAgICAgIG5leHRTb3J0Q29sdW1uID0ge1xuICAgICAgICAgIGNvbHVtbktleTogY29sdW1uLmtleSxcbiAgICAgICAgICBkaXJlY3Rpb246IHNvcnREaXJlY3Rpb24gPT09ICdBU0MnID8gJ0RFU0MnIDogJ0FTQydcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChjdHJsQ2xpY2spIHtcbiAgICAgICAgY29uc3QgbmV4dFNvcnRDb2x1bW5zID0gWy4uLnNvcnRDb2x1bW5zXTtcbiAgICAgICAgaWYgKG5leHRTb3J0Q29sdW1uKSB7XG4gICAgICAgICAgbmV4dFNvcnRDb2x1bW5zW3NvcnRJbmRleF0gPSBuZXh0U29ydENvbHVtbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0U29ydENvbHVtbnMuc3BsaWNlKHNvcnRJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgb25Tb3J0Q29sdW1uc0NoYW5nZShuZXh0U29ydENvbHVtbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25Tb3J0Q29sdW1uc0NoYW5nZShuZXh0U29ydENvbHVtbiA/IFtuZXh0U29ydENvbHVtbl0gOiBbXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQpIHtcbiAgICBzZWxlY3RDZWxsKHtcbiAgICAgIGlkeDogY29sdW1uLmlkeCxcbiAgICAgIHJvd0lkeFxuICAgIH0pO1xuICAgIGlmIChzb3J0YWJsZSkge1xuICAgICAgb25Tb3J0KGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uRG91YmxlQ2xpY2soKSB7XG4gICAgb25Db2x1bW5SZXNpemUoY29sdW1uLCAnbWF4LWNvbnRlbnQnKTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVGb2N1cyhldmVudCkge1xuICAgIG9uRm9jdXM/LihldmVudCk7XG4gICAgaWYgKHNob3VsZEZvY3VzR3JpZCkge1xuICAgICAgc2VsZWN0Q2VsbCh7XG4gICAgICAgIGlkeDogMCxcbiAgICAgICAgcm93SWR4XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gJyAnIHx8IGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG9uU29ydChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvbkRyYWdTdGFydChldmVudCkge1xuICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKGRyYWdEcm9wS2V5LCBjb2x1bW4ua2V5KTtcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdtb3ZlJztcbiAgICBzZXRJc0RyYWdnaW5nKHRydWUpO1xuICB9XG4gIGZ1bmN0aW9uIG9uRHJhZ0VuZCgpIHtcbiAgICBzZXRJc0RyYWdnaW5nKGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBvbkRyYWdPdmVyKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdtb3ZlJztcbiAgfVxuICBmdW5jdGlvbiBvbkRyb3AoZXZlbnQpIHtcbiAgICBzZXRJc092ZXIoZmFsc2UpO1xuICAgIGlmIChldmVudC5kYXRhVHJhbnNmZXIudHlwZXMuaW5jbHVkZXMoZHJhZ0Ryb3BLZXkpKSB7XG4gICAgICBjb25zdCBzb3VyY2VLZXkgPSBldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShkcmFnRHJvcEtleSk7XG4gICAgICBpZiAoc291cmNlS2V5ICE9PSBjb2x1bW4ua2V5KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG9uQ29sdW1uc1Jlb3JkZXI/Lihzb3VyY2VLZXksIGNvbHVtbi5rZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvbkRyYWdFbnRlcihldmVudCkge1xuICAgIGlmIChpc0V2ZW50UGVydGluZW50KGV2ZW50KSkge1xuICAgICAgc2V0SXNPdmVyKHRydWUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvbkRyYWdMZWF2ZShldmVudCkge1xuICAgIGlmIChpc0V2ZW50UGVydGluZW50KGV2ZW50KSkge1xuICAgICAgc2V0SXNPdmVyKGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgbGV0IGRyYWdnYWJsZVByb3BzO1xuICBpZiAoZHJhZ2dhYmxlKSB7XG4gICAgZHJhZ2dhYmxlUHJvcHMgPSB7XG4gICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICBvbkRyYWdTdGFydCxcbiAgICAgIG9uRHJhZ0VuZCxcbiAgICAgIG9uRHJhZ092ZXIsXG4gICAgICBvbkRyYWdFbnRlcixcbiAgICAgIG9uRHJhZ0xlYXZlLFxuICAgICAgb25Ecm9wXG4gICAgfTtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL2pzeHMoXCJkaXZcIiwge1xuICAgIHJvbGU6IFwiY29sdW1uaGVhZGVyXCIsXG4gICAgXCJhcmlhLWNvbGluZGV4XCI6IGNvbHVtbi5pZHggKyAxLFxuICAgIFwiYXJpYS1jb2xzcGFuXCI6IGNvbFNwYW4sXG4gICAgXCJhcmlhLXJvd3NwYW5cIjogcm93U3BhbixcbiAgICBcImFyaWEtc2VsZWN0ZWRcIjogaXNDZWxsU2VsZWN0ZWQsXG4gICAgXCJhcmlhLXNvcnRcIjogYXJpYVNvcnQsXG4gICAgdGFiSW5kZXg6IHNob3VsZEZvY3VzR3JpZCA/IDAgOiB0YWJJbmRleCxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICBzdHlsZToge1xuICAgICAgLi4uZ2V0SGVhZGVyQ2VsbFN0eWxlKGNvbHVtbiwgcm93SWR4LCByb3dTcGFuKSxcbiAgICAgIC4uLmdldENlbGxTdHlsZShjb2x1bW4sIGNvbFNwYW4pXG4gICAgfSxcbiAgICBvbkZvY3VzOiBoYW5kbGVGb2N1cyxcbiAgICBvbkNsaWNrOiBvbkNsaWNrLFxuICAgIG9uS2V5RG93bjogc29ydGFibGUgPyBvbktleURvd24gOiB1bmRlZmluZWQsXG4gICAgLi4uZHJhZ2dhYmxlUHJvcHMsXG4gICAgY2hpbGRyZW46IFtyZW5kZXJIZWFkZXJDZWxsJDEoe1xuICAgICAgY29sdW1uLFxuICAgICAgc29ydERpcmVjdGlvbixcbiAgICAgIHByaW9yaXR5LFxuICAgICAgdGFiSW5kZXg6IGNoaWxkVGFiSW5kZXhcbiAgICB9KSwgcmVzaXphYmxlICYmIC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiByZXNpemVIYW5kbGVDbGFzc25hbWUsXG4gICAgICBvbkNsaWNrOiBzdG9wUHJvcGFnYXRpb24sXG4gICAgICBvbkRvdWJsZUNsaWNrOiBvbkRvdWJsZUNsaWNrLFxuICAgICAgb25Qb2ludGVyRG93bjogb25Qb2ludGVyRG93blxuICAgIH0pXVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzRXZlbnRQZXJ0aW5lbnQoZXZlbnQpIHtcbiAgY29uc3QgcmVsYXRlZFRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gIHJldHVybiAhZXZlbnQuY3VycmVudFRhcmdldC5jb250YWlucyhyZWxhdGVkVGFyZ2V0KTtcbn1cblxuY29uc3Qgcm93ID0gXCJyMXVwZnI4MDctMC0wLWJldGEtNDZcIjtcbmNvbnN0IHJvd0NsYXNzbmFtZSA9IGByZGctcm93ICR7cm93fWA7XG5jb25zdCByb3dTZWxlY3RlZCA9IFwicjE5MG1oZDM3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCByb3dTZWxlY3RlZENsYXNzbmFtZSA9ICdyZGctcm93LXNlbGVjdGVkJztcbmNvbnN0IHJvd1NlbGVjdGVkV2l0aEZyb3plbkNlbGwgPSBcInIxMzlxdTltNy0wLTAtYmV0YS00NlwiO1xuY29uc3QgdG9wU3VtbWFyeVJvd0NsYXNzbmFtZSA9ICdyZGctdG9wLXN1bW1hcnktcm93JztcbmNvbnN0IGJvdHRvbVN1bW1hcnlSb3dDbGFzc25hbWUgPSAncmRnLWJvdHRvbS1zdW1tYXJ5LXJvdyc7XG5cbmNvbnN0IGhlYWRlclJvdyA9IFwiaDEwdHNrY3g3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCBoZWFkZXJSb3dDbGFzc25hbWUgPSBgcmRnLWhlYWRlci1yb3cgJHtoZWFkZXJSb3d9YDtcbmZ1bmN0aW9uIEhlYWRlclJvdyh7XG4gIHJvd0lkeCxcbiAgY29sdW1ucyxcbiAgb25Db2x1bW5SZXNpemUsXG4gIG9uQ29sdW1uc1Jlb3JkZXIsXG4gIHNvcnRDb2x1bW5zLFxuICBvblNvcnRDb2x1bW5zQ2hhbmdlLFxuICBsYXN0RnJvemVuQ29sdW1uSW5kZXgsXG4gIHNlbGVjdGVkQ2VsbElkeCxcbiAgc2VsZWN0Q2VsbCxcbiAgc2hvdWxkRm9jdXNHcmlkLFxuICBkaXJlY3Rpb25cbn0pIHtcbiAgY29uc3QgZHJhZ0Ryb3BLZXkgPSB1c2VJZCgpO1xuICBjb25zdCBjZWxscyA9IFtdO1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgY29sdW1ucy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zW2luZGV4XTtcbiAgICBjb25zdCBjb2xTcGFuID0gZ2V0Q29sU3Bhbihjb2x1bW4sIGxhc3RGcm96ZW5Db2x1bW5JbmRleCwge1xuICAgICAgdHlwZTogJ0hFQURFUidcbiAgICB9KTtcbiAgICBpZiAoY29sU3BhbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbmRleCArPSBjb2xTcGFuIC0gMTtcbiAgICB9XG4gICAgY2VsbHMucHVzaCggLyojX19QVVJFX18qL2pzeChIZWFkZXJDZWxsLCB7XG4gICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgIGNvbFNwYW46IGNvbFNwYW4sXG4gICAgICByb3dJZHg6IHJvd0lkeCxcbiAgICAgIGlzQ2VsbFNlbGVjdGVkOiBzZWxlY3RlZENlbGxJZHggPT09IGNvbHVtbi5pZHgsXG4gICAgICBvbkNvbHVtblJlc2l6ZTogb25Db2x1bW5SZXNpemUsXG4gICAgICBvbkNvbHVtbnNSZW9yZGVyOiBvbkNvbHVtbnNSZW9yZGVyLFxuICAgICAgb25Tb3J0Q29sdW1uc0NoYW5nZTogb25Tb3J0Q29sdW1uc0NoYW5nZSxcbiAgICAgIHNvcnRDb2x1bW5zOiBzb3J0Q29sdW1ucyxcbiAgICAgIHNlbGVjdENlbGw6IHNlbGVjdENlbGwsXG4gICAgICBzaG91bGRGb2N1c0dyaWQ6IHNob3VsZEZvY3VzR3JpZCAmJiBpbmRleCA9PT0gMCxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgZHJhZ0Ryb3BLZXk6IGRyYWdEcm9wS2V5XG4gICAgfSwgY29sdW1uLmtleSkpO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICByb2xlOiBcInJvd1wiLFxuICAgIFwiYXJpYS1yb3dpbmRleFwiOiByb3dJZHgsXG4gICAgY2xhc3NOYW1lOiBjbHN4KGhlYWRlclJvd0NsYXNzbmFtZSwgc2VsZWN0ZWRDZWxsSWR4ID09PSAtMSAmJiByb3dTZWxlY3RlZENsYXNzbmFtZSksXG4gICAgY2hpbGRyZW46IGNlbGxzXG4gIH0pO1xufVxuY29uc3QgSGVhZGVyUm93JDEgPSAvKiNfX1BVUkVfXyovbWVtbyhIZWFkZXJSb3cpO1xuXG5mdW5jdGlvbiBHcm91cGVkQ29sdW1uSGVhZGVyUm93KHtcbiAgcm93SWR4LFxuICBsZXZlbCxcbiAgY29sdW1ucyxcbiAgc2VsZWN0ZWRDZWxsSWR4LFxuICBzZWxlY3RDZWxsXG59KSB7XG4gIGNvbnN0IGNlbGxzID0gW107XG4gIGNvbnN0IHJlbmRlcmVkUGFyZW50cyA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBjb2x1bW4gb2YgY29sdW1ucykge1xuICAgIGxldCB7XG4gICAgICBwYXJlbnRcbiAgICB9ID0gY29sdW1uO1xuICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gICAgd2hpbGUgKHBhcmVudC5sZXZlbCA+IGxldmVsKSB7XG4gICAgICBpZiAocGFyZW50LnBhcmVudCA9PT0gdW5kZWZpbmVkKSBicmVhaztcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIGlmIChwYXJlbnQubGV2ZWwgPT09IGxldmVsICYmICFyZW5kZXJlZFBhcmVudHMuaGFzKHBhcmVudCkpIHtcbiAgICAgIHJlbmRlcmVkUGFyZW50cy5hZGQocGFyZW50KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaWR4XG4gICAgICB9ID0gcGFyZW50O1xuICAgICAgY2VsbHMucHVzaCggLyojX19QVVJFX18qL2pzeChHcm91cGVkQ29sdW1uSGVhZGVyQ2VsbCwge1xuICAgICAgICBjb2x1bW46IHBhcmVudCxcbiAgICAgICAgcm93SWR4OiByb3dJZHgsXG4gICAgICAgIGlzQ2VsbFNlbGVjdGVkOiBzZWxlY3RlZENlbGxJZHggPT09IGlkeCxcbiAgICAgICAgc2VsZWN0Q2VsbDogc2VsZWN0Q2VsbFxuICAgICAgfSwgaWR4KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICByb2xlOiBcInJvd1wiLFxuICAgIFwiYXJpYS1yb3dpbmRleFwiOiByb3dJZHgsXG4gICAgY2xhc3NOYW1lOiBoZWFkZXJSb3dDbGFzc25hbWUsXG4gICAgY2hpbGRyZW46IGNlbGxzXG4gIH0pO1xufVxuY29uc3QgR3JvdXBlZENvbHVtbkhlYWRlclJvdyQxID0gLyojX19QVVJFX18qL21lbW8oR3JvdXBlZENvbHVtbkhlYWRlclJvdyk7XG5cbmNvbnN0IGNlbGxDb3BpZWQgPSBcImM2cmE4YTM3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCBjZWxsQ29waWVkQ2xhc3NuYW1lID0gYHJkZy1jZWxsLWNvcGllZCAke2NlbGxDb3BpZWR9YDtcbmNvbnN0IGNlbGxEcmFnZ2VkT3ZlciA9IFwiY3E5MTBtMDctMC0wLWJldGEtNDZcIjtcbmNvbnN0IGNlbGxEcmFnZ2VkT3ZlckNsYXNzbmFtZSA9IGByZGctY2VsbC1kcmFnZ2VkLW92ZXIgJHtjZWxsRHJhZ2dlZE92ZXJ9YDtcbmZ1bmN0aW9uIENlbGwoe1xuICBjb2x1bW4sXG4gIGNvbFNwYW4sXG4gIGlzQ2VsbFNlbGVjdGVkLFxuICBpc0NvcGllZCxcbiAgaXNEcmFnZ2VkT3ZlcixcbiAgcm93LFxuICByb3dJZHgsXG4gIG9uQ2xpY2ssXG4gIG9uRG91YmxlQ2xpY2ssXG4gIG9uQ29udGV4dE1lbnUsXG4gIG9uUm93Q2hhbmdlLFxuICBzZWxlY3RDZWxsLFxuICAuLi5wcm9wc1xufSkge1xuICBjb25zdCB7XG4gICAgdGFiSW5kZXgsXG4gICAgY2hpbGRUYWJJbmRleCxcbiAgICBvbkZvY3VzXG4gIH0gPSB1c2VSb3ZpbmdUYWJJbmRleChpc0NlbGxTZWxlY3RlZCk7XG4gIGNvbnN0IHtcbiAgICBjZWxsQ2xhc3NcbiAgfSA9IGNvbHVtbjtcbiAgY29uc3QgY2xhc3NOYW1lID0gZ2V0Q2VsbENsYXNzbmFtZShjb2x1bW4sIHR5cGVvZiBjZWxsQ2xhc3MgPT09ICdmdW5jdGlvbicgPyBjZWxsQ2xhc3Mocm93KSA6IGNlbGxDbGFzcywgaXNDb3BpZWQgJiYgY2VsbENvcGllZENsYXNzbmFtZSwgaXNEcmFnZ2VkT3ZlciAmJiBjZWxsRHJhZ2dlZE92ZXJDbGFzc25hbWUpO1xuICBjb25zdCBpc0VkaXRhYmxlID0gaXNDZWxsRWRpdGFibGVVdGlsKGNvbHVtbiwgcm93KTtcbiAgZnVuY3Rpb24gc2VsZWN0Q2VsbFdyYXBwZXIob3BlbkVkaXRvcikge1xuICAgIHNlbGVjdENlbGwoe1xuICAgICAgcm93SWR4LFxuICAgICAgaWR4OiBjb2x1bW4uaWR4XG4gICAgfSwgb3BlbkVkaXRvcik7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAob25DbGljaykge1xuICAgICAgY29uc3QgY2VsbEV2ZW50ID0gY3JlYXRlQ2VsbEV2ZW50KGV2ZW50KTtcbiAgICAgIG9uQ2xpY2soe1xuICAgICAgICByb3csXG4gICAgICAgIGNvbHVtbixcbiAgICAgICAgc2VsZWN0Q2VsbDogc2VsZWN0Q2VsbFdyYXBwZXJcbiAgICAgIH0sIGNlbGxFdmVudCk7XG4gICAgICBpZiAoY2VsbEV2ZW50LmlzR3JpZERlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxlY3RDZWxsV3JhcHBlcigpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZUNvbnRleHRNZW51KGV2ZW50KSB7XG4gICAgaWYgKG9uQ29udGV4dE1lbnUpIHtcbiAgICAgIGNvbnN0IGNlbGxFdmVudCA9IGNyZWF0ZUNlbGxFdmVudChldmVudCk7XG4gICAgICBvbkNvbnRleHRNZW51KHtcbiAgICAgICAgcm93LFxuICAgICAgICBjb2x1bW4sXG4gICAgICAgIHNlbGVjdENlbGw6IHNlbGVjdENlbGxXcmFwcGVyXG4gICAgICB9LCBjZWxsRXZlbnQpO1xuICAgICAgaWYgKGNlbGxFdmVudC5pc0dyaWREZWZhdWx0UHJldmVudGVkKCkpIHJldHVybjtcbiAgICB9XG4gICAgc2VsZWN0Q2VsbFdyYXBwZXIoKTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVEb3VibGVDbGljayhldmVudCkge1xuICAgIGlmIChvbkRvdWJsZUNsaWNrKSB7XG4gICAgICBjb25zdCBjZWxsRXZlbnQgPSBjcmVhdGVDZWxsRXZlbnQoZXZlbnQpO1xuICAgICAgb25Eb3VibGVDbGljayh7XG4gICAgICAgIHJvdyxcbiAgICAgICAgY29sdW1uLFxuICAgICAgICBzZWxlY3RDZWxsOiBzZWxlY3RDZWxsV3JhcHBlclxuICAgICAgfSwgY2VsbEV2ZW50KTtcbiAgICAgIGlmIChjZWxsRXZlbnQuaXNHcmlkRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm47XG4gICAgfVxuICAgIHNlbGVjdENlbGxXcmFwcGVyKHRydWUpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVJvd0NoYW5nZShuZXdSb3cpIHtcbiAgICBvblJvd0NoYW5nZShjb2x1bW4sIG5ld1Jvdyk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgIHJvbGU6IFwiZ3JpZGNlbGxcIixcbiAgICBcImFyaWEtY29saW5kZXhcIjogY29sdW1uLmlkeCArIDEsXG4gICAgXCJhcmlhLWNvbHNwYW5cIjogY29sU3BhbixcbiAgICBcImFyaWEtc2VsZWN0ZWRcIjogaXNDZWxsU2VsZWN0ZWQsXG4gICAgXCJhcmlhLXJlYWRvbmx5XCI6ICFpc0VkaXRhYmxlIHx8IHVuZGVmaW5lZCxcbiAgICB0YWJJbmRleDogdGFiSW5kZXgsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgc3R5bGU6IGdldENlbGxTdHlsZShjb2x1bW4sIGNvbFNwYW4pLFxuICAgIG9uQ2xpY2s6IGhhbmRsZUNsaWNrLFxuICAgIG9uRG91YmxlQ2xpY2s6IGhhbmRsZURvdWJsZUNsaWNrLFxuICAgIG9uQ29udGV4dE1lbnU6IGhhbmRsZUNvbnRleHRNZW51LFxuICAgIG9uRm9jdXM6IG9uRm9jdXMsXG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IGNvbHVtbi5yZW5kZXJDZWxsKHtcbiAgICAgIGNvbHVtbixcbiAgICAgIHJvdyxcbiAgICAgIHJvd0lkeCxcbiAgICAgIGlzQ2VsbEVkaXRhYmxlOiBpc0VkaXRhYmxlLFxuICAgICAgdGFiSW5kZXg6IGNoaWxkVGFiSW5kZXgsXG4gICAgICBvblJvd0NoYW5nZTogaGFuZGxlUm93Q2hhbmdlXG4gICAgfSlcbiAgfSk7XG59XG5jb25zdCBDZWxsJDEgPSAvKiNfX1BVUkVfXyovbWVtbyhDZWxsKTtcblxuZnVuY3Rpb24gUm93KHtcbiAgY2xhc3NOYW1lLFxuICByb3dJZHgsXG4gIGdyaWRSb3dTdGFydCxcbiAgc2VsZWN0ZWRDZWxsSWR4LFxuICBpc1Jvd1NlbGVjdGVkLFxuICBjb3BpZWRDZWxsSWR4LFxuICBkcmFnZ2VkT3ZlckNlbGxJZHgsXG4gIGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgcm93LFxuICB2aWV3cG9ydENvbHVtbnMsXG4gIHNlbGVjdGVkQ2VsbEVkaXRvcixcbiAgb25DZWxsQ2xpY2ssXG4gIG9uQ2VsbERvdWJsZUNsaWNrLFxuICBvbkNlbGxDb250ZXh0TWVudSxcbiAgcm93Q2xhc3MsXG4gIHNldERyYWdnZWRPdmVyUm93SWR4LFxuICBvbk1vdXNlRW50ZXIsXG4gIG9uUm93Q2hhbmdlLFxuICBzZWxlY3RDZWxsLFxuICAuLi5wcm9wc1xufSwgcmVmKSB7XG4gIGNvbnN0IGhhbmRsZVJvd0NoYW5nZSA9IHVzZUxhdGVzdEZ1bmMoKGNvbHVtbiwgbmV3Um93KSA9PiB7XG4gICAgb25Sb3dDaGFuZ2UoY29sdW1uLCByb3dJZHgsIG5ld1Jvdyk7XG4gIH0pO1xuICBmdW5jdGlvbiBoYW5kbGVEcmFnRW50ZXIoZXZlbnQpIHtcbiAgICBzZXREcmFnZ2VkT3ZlclJvd0lkeD8uKHJvd0lkeCk7XG4gICAgb25Nb3VzZUVudGVyPy4oZXZlbnQpO1xuICB9XG4gIGNsYXNzTmFtZSA9IGNsc3gocm93Q2xhc3NuYW1lLCBgcmRnLXJvdy0ke3Jvd0lkeCAlIDIgPT09IDAgPyAnZXZlbicgOiAnb2RkJ31gLCByb3dDbGFzcz8uKHJvdywgcm93SWR4KSwgY2xhc3NOYW1lLCBzZWxlY3RlZENlbGxJZHggPT09IC0xICYmIHJvd1NlbGVjdGVkQ2xhc3NuYW1lKTtcbiAgY29uc3QgY2VsbHMgPSBbXTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHZpZXdwb3J0Q29sdW1ucy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBjb2x1bW4gPSB2aWV3cG9ydENvbHVtbnNbaW5kZXhdO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkeFxuICAgIH0gPSBjb2x1bW47XG4gICAgY29uc3QgY29sU3BhbiA9IGdldENvbFNwYW4oY29sdW1uLCBsYXN0RnJvemVuQ29sdW1uSW5kZXgsIHtcbiAgICAgIHR5cGU6ICdST1cnLFxuICAgICAgcm93XG4gICAgfSk7XG4gICAgaWYgKGNvbFNwYW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5kZXggKz0gY29sU3BhbiAtIDE7XG4gICAgfVxuICAgIGNvbnN0IGlzQ2VsbFNlbGVjdGVkID0gc2VsZWN0ZWRDZWxsSWR4ID09PSBpZHg7XG4gICAgaWYgKGlzQ2VsbFNlbGVjdGVkICYmIHNlbGVjdGVkQ2VsbEVkaXRvcikge1xuICAgICAgY2VsbHMucHVzaChzZWxlY3RlZENlbGxFZGl0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZWxscy5wdXNoKCAvKiNfX1BVUkVfXyovanN4KENlbGwkMSwge1xuICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgY29sU3BhbjogY29sU3BhbixcbiAgICAgICAgcm93OiByb3csXG4gICAgICAgIHJvd0lkeDogcm93SWR4LFxuICAgICAgICBpc0NvcGllZDogY29waWVkQ2VsbElkeCA9PT0gaWR4LFxuICAgICAgICBpc0RyYWdnZWRPdmVyOiBkcmFnZ2VkT3ZlckNlbGxJZHggPT09IGlkeCxcbiAgICAgICAgaXNDZWxsU2VsZWN0ZWQ6IGlzQ2VsbFNlbGVjdGVkLFxuICAgICAgICBvbkNsaWNrOiBvbkNlbGxDbGljayxcbiAgICAgICAgb25Eb3VibGVDbGljazogb25DZWxsRG91YmxlQ2xpY2ssXG4gICAgICAgIG9uQ29udGV4dE1lbnU6IG9uQ2VsbENvbnRleHRNZW51LFxuICAgICAgICBvblJvd0NoYW5nZTogaGFuZGxlUm93Q2hhbmdlLFxuICAgICAgICBzZWxlY3RDZWxsOiBzZWxlY3RDZWxsXG4gICAgICB9LCBjb2x1bW4ua2V5KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFJvd1NlbGVjdGlvblByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGlzUm93U2VsZWN0ZWQsXG4gICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgICAgcm9sZTogXCJyb3dcIixcbiAgICAgIHJlZjogcmVmLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICBvbk1vdXNlRW50ZXI6IGhhbmRsZURyYWdFbnRlcixcbiAgICAgIHN0eWxlOiBnZXRSb3dTdHlsZShncmlkUm93U3RhcnQpLFxuICAgICAgLi4ucHJvcHMsXG4gICAgICBjaGlsZHJlbjogY2VsbHNcbiAgICB9KVxuICB9KTtcbn1cbmNvbnN0IFJvd0NvbXBvbmVudCA9IC8qI19fUFVSRV9fKi9tZW1vKCAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZihSb3cpKTtcbmNvbnN0IFJvd0NvbXBvbmVudCQxID0gUm93Q29tcG9uZW50O1xuZnVuY3Rpb24gZGVmYXVsdFJlbmRlclJvdyhrZXksIHByb3BzKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFJvd0NvbXBvbmVudCwge1xuICAgIC4uLnByb3BzXG4gIH0sIGtleSk7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbFRvQ2VsbCh7XG4gIHNjcm9sbFRvUG9zaXRpb246IHtcbiAgICBpZHgsXG4gICAgcm93SWR4XG4gIH0sXG4gIGdyaWRFbGVtZW50LFxuICBzZXRTY3JvbGxUb0NlbGxQb3NpdGlvblxufSkge1xuICBjb25zdCByZWYgPSB1c2VSZWYobnVsbCk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgc2Nyb2xsSW50b1ZpZXcocmVmLmN1cnJlbnQpO1xuICB9KTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBmdW5jdGlvbiByZW1vdmVTY3JvbGxUb0NlbGwoKSB7XG4gICAgICBzZXRTY3JvbGxUb0NlbGxQb3NpdGlvbihudWxsKTtcbiAgICB9XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIocmVtb3ZlU2Nyb2xsVG9DZWxsLCB7XG4gICAgICByb290OiBncmlkRWxlbWVudCxcbiAgICAgIHRocmVzaG9sZDogMS4wXG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShyZWYuY3VycmVudCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICB9LCBbZ3JpZEVsZW1lbnQsIHNldFNjcm9sbFRvQ2VsbFBvc2l0aW9uXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICByZWY6IHJlZixcbiAgICBzdHlsZToge1xuICAgICAgZ3JpZENvbHVtbjogaWR4ID09PSB1bmRlZmluZWQgPyAnMS8tMScgOiBpZHggKyAxLFxuICAgICAgZ3JpZFJvdzogcm93SWR4ID09PSB1bmRlZmluZWQgPyAnMS8tMScgOiByb3dJZHggKyAyXG4gICAgfVxuICB9KTtcbn1cblxuY29uc3QgYXJyb3cgPSBcImEzZWp0YXI3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCBhcnJvd0NsYXNzbmFtZSA9IGByZGctc29ydC1hcnJvdyAke2Fycm93fWA7XG5mdW5jdGlvbiByZW5kZXJTb3J0U3RhdHVzKHtcbiAgc29ydERpcmVjdGlvbixcbiAgcHJpb3JpdHlcbn0pIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3hzKEZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFtyZW5kZXJTb3J0SWNvbih7XG4gICAgICBzb3J0RGlyZWN0aW9uXG4gICAgfSksIHJlbmRlclNvcnRQcmlvcml0eSh7XG4gICAgICBwcmlvcml0eVxuICAgIH0pXVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbmRlclNvcnRJY29uKHtcbiAgc29ydERpcmVjdGlvblxufSkge1xuICBpZiAoc29ydERpcmVjdGlvbiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goXCJzdmdcIiwge1xuICAgIHZpZXdCb3g6IFwiMCAwIDEyIDhcIixcbiAgICB3aWR0aDogXCIxMlwiLFxuICAgIGhlaWdodDogXCI4XCIsXG4gICAgY2xhc3NOYW1lOiBhcnJvd0NsYXNzbmFtZSxcbiAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IHNvcnREaXJlY3Rpb24gPT09ICdBU0MnID8gJ00wIDggNiAwIDEyIDgnIDogJ00wIDAgNiA4IDEyIDAnXG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiByZW5kZXJTb3J0UHJpb3JpdHkoe1xuICBwcmlvcml0eVxufSkge1xuICByZXR1cm4gcHJpb3JpdHk7XG59XG5cbmNvbnN0IHJvb3QgPSBcInJudm9kejU3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCByb290Q2xhc3NuYW1lID0gYHJkZyAke3Jvb3R9YDtcbmNvbnN0IHZpZXdwb3J0RHJhZ2dpbmcgPSBcInZscXY5MWs3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCB2aWV3cG9ydERyYWdnaW5nQ2xhc3NuYW1lID0gYHJkZy12aWV3cG9ydC1kcmFnZ2luZyAke3ZpZXdwb3J0RHJhZ2dpbmd9YDtcbmNvbnN0IGZvY3VzU2lua0NsYXNzbmFtZSA9IFwiZjFsc2Zyenc3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCBmb2N1c1NpbmtIZWFkZXJBbmRTdW1tYXJ5Q2xhc3NuYW1lID0gXCJmMWN0ZTBsZzctMC0wLWJldGEtNDZcIjtcblxuY29uc3Qgc3VtbWFyeUNlbGxDbGFzc25hbWUgPSBcInM4d2M2Zmw3LTAtMC1iZXRhLTQ2XCI7XG5mdW5jdGlvbiBTdW1tYXJ5Q2VsbCh7XG4gIGNvbHVtbixcbiAgY29sU3BhbixcbiAgcm93LFxuICByb3dJZHgsXG4gIGlzQ2VsbFNlbGVjdGVkLFxuICBzZWxlY3RDZWxsXG59KSB7XG4gIGNvbnN0IHtcbiAgICB0YWJJbmRleCxcbiAgICBjaGlsZFRhYkluZGV4LFxuICAgIG9uRm9jdXNcbiAgfSA9IHVzZVJvdmluZ1RhYkluZGV4KGlzQ2VsbFNlbGVjdGVkKTtcbiAgY29uc3Qge1xuICAgIHN1bW1hcnlDZWxsQ2xhc3NcbiAgfSA9IGNvbHVtbjtcbiAgY29uc3QgY2xhc3NOYW1lID0gZ2V0Q2VsbENsYXNzbmFtZShjb2x1bW4sIHN1bW1hcnlDZWxsQ2xhc3NuYW1lLCB0eXBlb2Ygc3VtbWFyeUNlbGxDbGFzcyA9PT0gJ2Z1bmN0aW9uJyA/IHN1bW1hcnlDZWxsQ2xhc3Mocm93KSA6IHN1bW1hcnlDZWxsQ2xhc3MpO1xuICBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgIHNlbGVjdENlbGwoe1xuICAgICAgcm93SWR4LFxuICAgICAgaWR4OiBjb2x1bW4uaWR4XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgIHJvbGU6IFwiZ3JpZGNlbGxcIixcbiAgICBcImFyaWEtY29saW5kZXhcIjogY29sdW1uLmlkeCArIDEsXG4gICAgXCJhcmlhLWNvbHNwYW5cIjogY29sU3BhbixcbiAgICBcImFyaWEtc2VsZWN0ZWRcIjogaXNDZWxsU2VsZWN0ZWQsXG4gICAgdGFiSW5kZXg6IHRhYkluZGV4LFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIHN0eWxlOiBnZXRDZWxsU3R5bGUoY29sdW1uLCBjb2xTcGFuKSxcbiAgICBvbkNsaWNrOiBvbkNsaWNrLFxuICAgIG9uRm9jdXM6IG9uRm9jdXMsXG4gICAgY2hpbGRyZW46IGNvbHVtbi5yZW5kZXJTdW1tYXJ5Q2VsbD8uKHtcbiAgICAgIGNvbHVtbixcbiAgICAgIHJvdyxcbiAgICAgIHRhYkluZGV4OiBjaGlsZFRhYkluZGV4XG4gICAgfSlcbiAgfSk7XG59XG5jb25zdCBTdW1tYXJ5Q2VsbCQxID0gLyojX19QVVJFX18qL21lbW8oU3VtbWFyeUNlbGwpO1xuXG5jb25zdCBzdW1tYXJ5Um93ID0gXCJza3VocDU1Ny0wLTAtYmV0YS00NlwiO1xuY29uc3QgdG9wU3VtbWFyeVJvdyA9IFwidGY4bDV1YjctMC0wLWJldGEtNDZcIjtcbmNvbnN0IHN1bW1hcnlSb3dDbGFzc25hbWUgPSBgcmRnLXN1bW1hcnktcm93ICR7c3VtbWFyeVJvd31gO1xuZnVuY3Rpb24gU3VtbWFyeVJvdyh7XG4gIHJvd0lkeCxcbiAgZ3JpZFJvd1N0YXJ0LFxuICByb3csXG4gIHZpZXdwb3J0Q29sdW1ucyxcbiAgdG9wLFxuICBib3R0b20sXG4gIGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgc2VsZWN0ZWRDZWxsSWR4LFxuICBpc1RvcCxcbiAgc2VsZWN0Q2VsbCxcbiAgJ2FyaWEtcm93aW5kZXgnOiBhcmlhUm93SW5kZXhcbn0pIHtcbiAgY29uc3QgY2VsbHMgPSBbXTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHZpZXdwb3J0Q29sdW1ucy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBjb2x1bW4gPSB2aWV3cG9ydENvbHVtbnNbaW5kZXhdO1xuICAgIGNvbnN0IGNvbFNwYW4gPSBnZXRDb2xTcGFuKGNvbHVtbiwgbGFzdEZyb3plbkNvbHVtbkluZGV4LCB7XG4gICAgICB0eXBlOiAnU1VNTUFSWScsXG4gICAgICByb3dcbiAgICB9KTtcbiAgICBpZiAoY29sU3BhbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbmRleCArPSBjb2xTcGFuIC0gMTtcbiAgICB9XG4gICAgY29uc3QgaXNDZWxsU2VsZWN0ZWQgPSBzZWxlY3RlZENlbGxJZHggPT09IGNvbHVtbi5pZHg7XG4gICAgY2VsbHMucHVzaCggLyojX19QVVJFX18qL2pzeChTdW1tYXJ5Q2VsbCQxLCB7XG4gICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgIGNvbFNwYW46IGNvbFNwYW4sXG4gICAgICByb3c6IHJvdyxcbiAgICAgIHJvd0lkeDogcm93SWR4LFxuICAgICAgaXNDZWxsU2VsZWN0ZWQ6IGlzQ2VsbFNlbGVjdGVkLFxuICAgICAgc2VsZWN0Q2VsbDogc2VsZWN0Q2VsbFxuICAgIH0sIGNvbHVtbi5rZXkpKTtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChcImRpdlwiLCB7XG4gICAgcm9sZTogXCJyb3dcIixcbiAgICBcImFyaWEtcm93aW5kZXhcIjogYXJpYVJvd0luZGV4LFxuICAgIGNsYXNzTmFtZTogY2xzeChyb3dDbGFzc25hbWUsIGByZGctcm93LSR7cm93SWR4ICUgMiA9PT0gMCA/ICdldmVuJyA6ICdvZGQnfWAsIHN1bW1hcnlSb3dDbGFzc25hbWUsIGlzVG9wID8gYCR7dG9wU3VtbWFyeVJvd0NsYXNzbmFtZX0gJHt0b3BTdW1tYXJ5Um93fWAgOiBib3R0b21TdW1tYXJ5Um93Q2xhc3NuYW1lLCBzZWxlY3RlZENlbGxJZHggPT09IC0xICYmIHJvd1NlbGVjdGVkQ2xhc3NuYW1lKSxcbiAgICBzdHlsZToge1xuICAgICAgLi4uZ2V0Um93U3R5bGUoZ3JpZFJvd1N0YXJ0KSxcbiAgICAgICctLXJkZy1zdW1tYXJ5LXJvdy10b3AnOiB0b3AgIT09IHVuZGVmaW5lZCA/IGAke3RvcH1weGAgOiB1bmRlZmluZWQsXG4gICAgICAnLS1yZGctc3VtbWFyeS1yb3ctYm90dG9tJzogYm90dG9tICE9PSB1bmRlZmluZWQgPyBgJHtib3R0b219cHhgIDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICBjaGlsZHJlbjogY2VsbHNcbiAgfSk7XG59XG5jb25zdCBTdW1tYXJ5Um93JDEgPSAvKiNfX1BVUkVfXyovbWVtbyhTdW1tYXJ5Um93KTtcblxuZnVuY3Rpb24gRGF0YUdyaWQocHJvcHMsIHJlZikge1xuICBjb25zdCB7XG4gICAgY29sdW1uczogcmF3Q29sdW1ucyxcbiAgICByb3dzLFxuICAgIHRvcFN1bW1hcnlSb3dzLFxuICAgIGJvdHRvbVN1bW1hcnlSb3dzLFxuICAgIHJvd0tleUdldHRlcixcbiAgICBvblJvd3NDaGFuZ2UsXG4gICAgcm93SGVpZ2h0OiByYXdSb3dIZWlnaHQsXG4gICAgaGVhZGVyUm93SGVpZ2h0OiByYXdIZWFkZXJSb3dIZWlnaHQsXG4gICAgc3VtbWFyeVJvd0hlaWdodDogcmF3U3VtbWFyeVJvd0hlaWdodCxcbiAgICBzZWxlY3RlZFJvd3MsXG4gICAgb25TZWxlY3RlZFJvd3NDaGFuZ2UsXG4gICAgc29ydENvbHVtbnMsXG4gICAgb25Tb3J0Q29sdW1uc0NoYW5nZSxcbiAgICBkZWZhdWx0Q29sdW1uT3B0aW9ucyxcbiAgICBvbkNlbGxDbGljayxcbiAgICBvbkNlbGxEb3VibGVDbGljayxcbiAgICBvbkNlbGxDb250ZXh0TWVudSxcbiAgICBvbkNlbGxLZXlEb3duLFxuICAgIG9uU2VsZWN0ZWRDZWxsQ2hhbmdlLFxuICAgIG9uU2Nyb2xsLFxuICAgIG9uQ29sdW1uUmVzaXplLFxuICAgIG9uQ29sdW1uc1Jlb3JkZXIsXG4gICAgb25GaWxsLFxuICAgIG9uQ29weSxcbiAgICBvblBhc3RlLFxuICAgIGVuYWJsZVZpcnR1YWxpemF0aW9uOiByYXdFbmFibGVWaXJ0dWFsaXphdGlvbixcbiAgICByZW5kZXJlcnMsXG4gICAgY2xhc3NOYW1lLFxuICAgIHN0eWxlLFxuICAgIHJvd0NsYXNzLFxuICAgIGRpcmVjdGlvbjogcmF3RGlyZWN0aW9uLFxuICAgIHJvbGU6IHJhd1JvbGUsXG4gICAgJ2FyaWEtbGFiZWwnOiBhcmlhTGFiZWwsXG4gICAgJ2FyaWEtbGFiZWxsZWRieSc6IGFyaWFMYWJlbGxlZEJ5LFxuICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogYXJpYURlc2NyaWJlZEJ5LFxuICAgICdhcmlhLXJvd2NvdW50JzogcmF3QXJpYVJvd0NvdW50LFxuICAgICdkYXRhLXRlc3RpZCc6IHRlc3RJZFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGRlZmF1bHRSZW5kZXJlcnMgPSB1c2VEZWZhdWx0UmVuZGVyZXJzKCk7XG4gIGNvbnN0IHJvbGUgPSByYXdSb2xlID8/ICdncmlkJztcbiAgY29uc3Qgcm93SGVpZ2h0ID0gcmF3Um93SGVpZ2h0ID8/IDM1O1xuICBjb25zdCBoZWFkZXJSb3dIZWlnaHQgPSByYXdIZWFkZXJSb3dIZWlnaHQgPz8gKHR5cGVvZiByb3dIZWlnaHQgPT09ICdudW1iZXInID8gcm93SGVpZ2h0IDogMzUpO1xuICBjb25zdCBzdW1tYXJ5Um93SGVpZ2h0ID0gcmF3U3VtbWFyeVJvd0hlaWdodCA/PyAodHlwZW9mIHJvd0hlaWdodCA9PT0gJ251bWJlcicgPyByb3dIZWlnaHQgOiAzNSk7XG4gIGNvbnN0IHJlbmRlclJvdyA9IHJlbmRlcmVycz8ucmVuZGVyUm93ID8/IGRlZmF1bHRSZW5kZXJlcnM/LnJlbmRlclJvdyA/PyBkZWZhdWx0UmVuZGVyUm93O1xuICBjb25zdCByZW5kZXJTb3J0U3RhdHVzJDEgPSByZW5kZXJlcnM/LnJlbmRlclNvcnRTdGF0dXMgPz8gZGVmYXVsdFJlbmRlcmVycz8ucmVuZGVyU29ydFN0YXR1cyA/PyByZW5kZXJTb3J0U3RhdHVzO1xuICBjb25zdCByZW5kZXJDaGVja2JveCQxID0gcmVuZGVyZXJzPy5yZW5kZXJDaGVja2JveCA/PyBkZWZhdWx0UmVuZGVyZXJzPy5yZW5kZXJDaGVja2JveCA/PyByZW5kZXJDaGVja2JveDtcbiAgY29uc3Qgbm9Sb3dzRmFsbGJhY2sgPSByZW5kZXJlcnM/Lm5vUm93c0ZhbGxiYWNrID8/IGRlZmF1bHRSZW5kZXJlcnM/Lm5vUm93c0ZhbGxiYWNrO1xuICBjb25zdCBlbmFibGVWaXJ0dWFsaXphdGlvbiA9IHJhd0VuYWJsZVZpcnR1YWxpemF0aW9uID8/IHRydWU7XG4gIGNvbnN0IGRpcmVjdGlvbiA9IHJhd0RpcmVjdGlvbiA/PyAnbHRyJztcbiAgY29uc3QgW3Njcm9sbFRvcCwgc2V0U2Nyb2xsVG9wXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbc2Nyb2xsTGVmdCwgc2V0U2Nyb2xsTGVmdF0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW3Jlc2l6ZWRDb2x1bW5XaWR0aHMsIHNldFJlc2l6ZWRDb2x1bW5XaWR0aHNdID0gdXNlU3RhdGUoKCkgPT4gbmV3IE1hcCgpKTtcbiAgY29uc3QgW21lYXN1cmVkQ29sdW1uV2lkdGhzLCBzZXRNZWFzdXJlZENvbHVtbldpZHRoc10gPSB1c2VTdGF0ZSgoKSA9PiBuZXcgTWFwKCkpO1xuICBjb25zdCBbY29waWVkQ2VsbCwgc2V0Q29waWVkQ2VsbF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2lzRHJhZ2dpbmcsIHNldERyYWdnaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2RyYWdnZWRPdmVyUm93SWR4LCBzZXRPdmVyUm93SWR4XSA9IHVzZVN0YXRlKHVuZGVmaW5lZCk7XG4gIGNvbnN0IFtzY3JvbGxUb1Bvc2l0aW9uLCBzZXRTY3JvbGxUb1Bvc2l0aW9uXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBnZXRDb2x1bW5XaWR0aCA9IHVzZUNhbGxiYWNrKGNvbHVtbiA9PiB7XG4gICAgcmV0dXJuIHJlc2l6ZWRDb2x1bW5XaWR0aHMuZ2V0KGNvbHVtbi5rZXkpID8/IG1lYXN1cmVkQ29sdW1uV2lkdGhzLmdldChjb2x1bW4ua2V5KSA/PyBjb2x1bW4ud2lkdGg7XG4gIH0sIFttZWFzdXJlZENvbHVtbldpZHRocywgcmVzaXplZENvbHVtbldpZHRoc10pO1xuICBjb25zdCBbZ3JpZFJlZiwgZ3JpZFdpZHRoLCBncmlkSGVpZ2h0LCBob3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0XSA9IHVzZUdyaWREaW1lbnNpb25zKCk7XG4gIGNvbnN0IHtcbiAgICBjb2x1bW5zLFxuICAgIGNvbFNwYW5Db2x1bW5zLFxuICAgIGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgICBoZWFkZXJSb3dzQ291bnQsXG4gICAgY29sT3ZlcnNjYW5TdGFydElkeCxcbiAgICBjb2xPdmVyc2NhbkVuZElkeCxcbiAgICB0ZW1wbGF0ZUNvbHVtbnMsXG4gICAgbGF5b3V0Q3NzVmFycyxcbiAgICB0b3RhbEZyb3plbkNvbHVtbldpZHRoXG4gIH0gPSB1c2VDYWxjdWxhdGVkQ29sdW1ucyh7XG4gICAgcmF3Q29sdW1ucyxcbiAgICBkZWZhdWx0Q29sdW1uT3B0aW9ucyxcbiAgICBnZXRDb2x1bW5XaWR0aCxcbiAgICBzY3JvbGxMZWZ0LFxuICAgIHZpZXdwb3J0V2lkdGg6IGdyaWRXaWR0aCxcbiAgICBlbmFibGVWaXJ0dWFsaXphdGlvblxuICB9KTtcbiAgY29uc3QgdG9wU3VtbWFyeVJvd3NDb3VudCA9IHRvcFN1bW1hcnlSb3dzPy5sZW5ndGggPz8gMDtcbiAgY29uc3QgYm90dG9tU3VtbWFyeVJvd3NDb3VudCA9IGJvdHRvbVN1bW1hcnlSb3dzPy5sZW5ndGggPz8gMDtcbiAgY29uc3Qgc3VtbWFyeVJvd3NDb3VudCA9IHRvcFN1bW1hcnlSb3dzQ291bnQgKyBib3R0b21TdW1tYXJ5Um93c0NvdW50O1xuICBjb25zdCBoZWFkZXJBbmRUb3BTdW1tYXJ5Um93c0NvdW50ID0gaGVhZGVyUm93c0NvdW50ICsgdG9wU3VtbWFyeVJvd3NDb3VudDtcbiAgY29uc3QgZ3JvdXBlZENvbHVtbkhlYWRlclJvd3NDb3VudCA9IGhlYWRlclJvd3NDb3VudCAtIDE7XG4gIGNvbnN0IG1pblJvd0lkeCA9IC1oZWFkZXJBbmRUb3BTdW1tYXJ5Um93c0NvdW50O1xuICBjb25zdCBtYWluSGVhZGVyUm93SWR4ID0gbWluUm93SWR4ICsgZ3JvdXBlZENvbHVtbkhlYWRlclJvd3NDb3VudDtcbiAgY29uc3QgbWF4Um93SWR4ID0gcm93cy5sZW5ndGggKyBib3R0b21TdW1tYXJ5Um93c0NvdW50IC0gMTtcbiAgY29uc3QgW3NlbGVjdGVkUG9zaXRpb24sIHNldFNlbGVjdGVkUG9zaXRpb25dID0gdXNlU3RhdGUoKCkgPT4gKHtcbiAgICBpZHg6IC0xLFxuICAgIHJvd0lkeDogbWluUm93SWR4IC0gMSxcbiAgICBtb2RlOiAnU0VMRUNUJ1xuICB9KSk7XG4gIGNvbnN0IHByZXZTZWxlY3RlZFBvc2l0aW9uID0gdXNlUmVmKHNlbGVjdGVkUG9zaXRpb24pO1xuICBjb25zdCBsYXRlc3REcmFnZ2VkT3ZlclJvd0lkeCA9IHVzZVJlZihkcmFnZ2VkT3ZlclJvd0lkeCk7XG4gIGNvbnN0IGxhc3RTZWxlY3RlZFJvd0lkeCA9IHVzZVJlZigtMSk7XG4gIGNvbnN0IGZvY3VzU2lua1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qgc2hvdWxkRm9jdXNDZWxsUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgaXNUcmVlR3JpZCA9IHJvbGUgPT09ICd0cmVlZ3JpZCc7XG4gIGNvbnN0IGhlYWRlclJvd3NIZWlnaHQgPSBoZWFkZXJSb3dzQ291bnQgKiBoZWFkZXJSb3dIZWlnaHQ7XG4gIGNvbnN0IHN1bW1hcnlSb3dzSGVpZ2h0ID0gc3VtbWFyeVJvd3NDb3VudCAqIHN1bW1hcnlSb3dIZWlnaHQ7XG4gIGNvbnN0IGNsaWVudEhlaWdodCA9IGdyaWRIZWlnaHQgLSBoZWFkZXJSb3dzSGVpZ2h0IC0gc3VtbWFyeVJvd3NIZWlnaHQ7XG4gIGNvbnN0IGlzU2VsZWN0YWJsZSA9IHNlbGVjdGVkUm93cyAhPSBudWxsICYmIG9uU2VsZWN0ZWRSb3dzQ2hhbmdlICE9IG51bGw7XG4gIGNvbnN0IGlzUnRsID0gZGlyZWN0aW9uID09PSAncnRsJztcbiAgY29uc3QgbGVmdEtleSA9IGlzUnRsID8gJ0Fycm93UmlnaHQnIDogJ0Fycm93TGVmdCc7XG4gIGNvbnN0IHJpZ2h0S2V5ID0gaXNSdGwgPyAnQXJyb3dMZWZ0JyA6ICdBcnJvd1JpZ2h0JztcbiAgY29uc3QgYXJpYVJvd0NvdW50ID0gcmF3QXJpYVJvd0NvdW50ID8/IGhlYWRlclJvd3NDb3VudCArIHJvd3MubGVuZ3RoICsgc3VtbWFyeVJvd3NDb3VudDtcbiAgY29uc3QgZGVmYXVsdEdyaWRDb21wb25lbnRzID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIHJlbmRlckNoZWNrYm94OiByZW5kZXJDaGVja2JveCQxLFxuICAgIHJlbmRlclNvcnRTdGF0dXM6IHJlbmRlclNvcnRTdGF0dXMkMVxuICB9KSwgW3JlbmRlckNoZWNrYm94JDEsIHJlbmRlclNvcnRTdGF0dXMkMV0pO1xuICBjb25zdCBhbGxSb3dzU2VsZWN0ZWQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBsZW5ndGhcbiAgICB9ID0gcm93cztcbiAgICByZXR1cm4gbGVuZ3RoICE9PSAwICYmIHNlbGVjdGVkUm93cyAhPSBudWxsICYmIHJvd0tleUdldHRlciAhPSBudWxsICYmIHNlbGVjdGVkUm93cy5zaXplID49IGxlbmd0aCAmJiByb3dzLmV2ZXJ5KHJvdyA9PiBzZWxlY3RlZFJvd3MuaGFzKHJvd0tleUdldHRlcihyb3cpKSk7XG4gIH0sIFtyb3dzLCBzZWxlY3RlZFJvd3MsIHJvd0tleUdldHRlcl0pO1xuICBjb25zdCB7XG4gICAgcm93T3ZlcnNjYW5TdGFydElkeCxcbiAgICByb3dPdmVyc2NhbkVuZElkeCxcbiAgICB0b3RhbFJvd0hlaWdodCxcbiAgICBncmlkVGVtcGxhdGVSb3dzLFxuICAgIGdldFJvd1RvcCxcbiAgICBnZXRSb3dIZWlnaHQsXG4gICAgZmluZFJvd0lkeFxuICB9ID0gdXNlVmlld3BvcnRSb3dzKHtcbiAgICByb3dzLFxuICAgIHJvd0hlaWdodCxcbiAgICBjbGllbnRIZWlnaHQsXG4gICAgc2Nyb2xsVG9wLFxuICAgIGVuYWJsZVZpcnR1YWxpemF0aW9uXG4gIH0pO1xuICBjb25zdCB2aWV3cG9ydENvbHVtbnMgPSB1c2VWaWV3cG9ydENvbHVtbnMoe1xuICAgIGNvbHVtbnMsXG4gICAgY29sU3BhbkNvbHVtbnMsXG4gICAgY29sT3ZlcnNjYW5TdGFydElkeCxcbiAgICBjb2xPdmVyc2NhbkVuZElkeCxcbiAgICBsYXN0RnJvemVuQ29sdW1uSW5kZXgsXG4gICAgcm93T3ZlcnNjYW5TdGFydElkeCxcbiAgICByb3dPdmVyc2NhbkVuZElkeCxcbiAgICByb3dzLFxuICAgIHRvcFN1bW1hcnlSb3dzLFxuICAgIGJvdHRvbVN1bW1hcnlSb3dzXG4gIH0pO1xuICBjb25zdCB7XG4gICAgZ3JpZFRlbXBsYXRlQ29sdW1ucyxcbiAgICBoYW5kbGVDb2x1bW5SZXNpemVcbiAgfSA9IHVzZUNvbHVtbldpZHRocyhjb2x1bW5zLCB2aWV3cG9ydENvbHVtbnMsIHRlbXBsYXRlQ29sdW1ucywgZ3JpZFJlZiwgZ3JpZFdpZHRoLCByZXNpemVkQ29sdW1uV2lkdGhzLCBtZWFzdXJlZENvbHVtbldpZHRocywgc2V0UmVzaXplZENvbHVtbldpZHRocywgc2V0TWVhc3VyZWRDb2x1bW5XaWR0aHMsIG9uQ29sdW1uUmVzaXplKTtcbiAgY29uc3QgbWluQ29sSWR4ID0gaXNUcmVlR3JpZCA/IC0xIDogMDtcbiAgY29uc3QgbWF4Q29sSWR4ID0gY29sdW1ucy5sZW5ndGggLSAxO1xuICBjb25zdCBzZWxlY3RlZENlbGxJc1dpdGhpblNlbGVjdGlvbkJvdW5kcyA9IGlzQ2VsbFdpdGhpblNlbGVjdGlvbkJvdW5kcyhzZWxlY3RlZFBvc2l0aW9uKTtcbiAgY29uc3Qgc2VsZWN0ZWRDZWxsSXNXaXRoaW5WaWV3cG9ydEJvdW5kcyA9IGlzQ2VsbFdpdGhpblZpZXdwb3J0Qm91bmRzKHNlbGVjdGVkUG9zaXRpb24pO1xuICBjb25zdCBzY3JvbGxIZWlnaHQgPSBoZWFkZXJSb3dIZWlnaHQgKyB0b3RhbFJvd0hlaWdodCArIHN1bW1hcnlSb3dzSGVpZ2h0ICsgaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodDtcbiAgY29uc3QgaGFuZGxlQ29sdW1uUmVzaXplTGF0ZXN0ID0gdXNlTGF0ZXN0RnVuYyhoYW5kbGVDb2x1bW5SZXNpemUpO1xuICBjb25zdCBvbkNvbHVtbnNSZW9yZGVyTGFzdGVzdCA9IHVzZUxhdGVzdEZ1bmMob25Db2x1bW5zUmVvcmRlcik7XG4gIGNvbnN0IG9uU29ydENvbHVtbnNDaGFuZ2VMYXRlc3QgPSB1c2VMYXRlc3RGdW5jKG9uU29ydENvbHVtbnNDaGFuZ2UpO1xuICBjb25zdCBvbkNlbGxDbGlja0xhdGVzdCA9IHVzZUxhdGVzdEZ1bmMob25DZWxsQ2xpY2spO1xuICBjb25zdCBvbkNlbGxEb3VibGVDbGlja0xhdGVzdCA9IHVzZUxhdGVzdEZ1bmMob25DZWxsRG91YmxlQ2xpY2spO1xuICBjb25zdCBvbkNlbGxDb250ZXh0TWVudUxhdGVzdCA9IHVzZUxhdGVzdEZ1bmMob25DZWxsQ29udGV4dE1lbnUpO1xuICBjb25zdCBzZWxlY3RSb3dMYXRlc3QgPSB1c2VMYXRlc3RGdW5jKHNlbGVjdFJvdyk7XG4gIGNvbnN0IGhhbmRsZUZvcm1hdHRlclJvd0NoYW5nZUxhdGVzdCA9IHVzZUxhdGVzdEZ1bmModXBkYXRlUm93KTtcbiAgY29uc3Qgc2VsZWN0Q2VsbExhdGVzdCA9IHVzZUxhdGVzdEZ1bmMoc2VsZWN0Q2VsbCk7XG4gIGNvbnN0IHNlbGVjdEhlYWRlckNlbGxMYXRlc3QgPSB1c2VMYXRlc3RGdW5jKCh7XG4gICAgaWR4LFxuICAgIHJvd0lkeFxuICB9KSA9PiB7XG4gICAgc2VsZWN0Q2VsbCh7XG4gICAgICByb3dJZHg6IG1pblJvd0lkeCArIHJvd0lkeCAtIDEsXG4gICAgICBpZHhcbiAgICB9KTtcbiAgfSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFzZWxlY3RlZENlbGxJc1dpdGhpblNlbGVjdGlvbkJvdW5kcyB8fCBpc1NhbWVQb3NpdGlvbihzZWxlY3RlZFBvc2l0aW9uLCBwcmV2U2VsZWN0ZWRQb3NpdGlvbi5jdXJyZW50KSkge1xuICAgICAgcHJldlNlbGVjdGVkUG9zaXRpb24uY3VycmVudCA9IHNlbGVjdGVkUG9zaXRpb247XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByZXZTZWxlY3RlZFBvc2l0aW9uLmN1cnJlbnQgPSBzZWxlY3RlZFBvc2l0aW9uO1xuICAgIGlmIChzZWxlY3RlZFBvc2l0aW9uLmlkeCA9PT0gLTEpIHtcbiAgICAgIGZvY3VzU2lua1JlZi5jdXJyZW50LmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBzY3JvbGxJbnRvVmlldyhmb2N1c1NpbmtSZWYuY3VycmVudCk7XG4gICAgfVxuICB9KTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNob3VsZEZvY3VzQ2VsbFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgc2hvdWxkRm9jdXNDZWxsUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICBmb2N1c0NlbGxPckNlbGxDb250ZW50KCk7XG4gIH0pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gKHtcbiAgICBlbGVtZW50OiBncmlkUmVmLmN1cnJlbnQsXG4gICAgc2Nyb2xsVG9DZWxsKHtcbiAgICAgIGlkeCxcbiAgICAgIHJvd0lkeFxuICAgIH0pIHtcbiAgICAgIGNvbnN0IHNjcm9sbFRvSWR4ID0gaWR4ICE9PSB1bmRlZmluZWQgJiYgaWR4ID4gbGFzdEZyb3plbkNvbHVtbkluZGV4ICYmIGlkeCA8IGNvbHVtbnMubGVuZ3RoID8gaWR4IDogdW5kZWZpbmVkO1xuICAgICAgY29uc3Qgc2Nyb2xsVG9Sb3dJZHggPSByb3dJZHggIT09IHVuZGVmaW5lZCAmJiBpc1Jvd0lkeFdpdGhpblZpZXdwb3J0Qm91bmRzKHJvd0lkeCkgPyByb3dJZHggOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoc2Nyb2xsVG9JZHggIT09IHVuZGVmaW5lZCB8fCBzY3JvbGxUb1Jvd0lkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNldFNjcm9sbFRvUG9zaXRpb24oe1xuICAgICAgICAgIGlkeDogc2Nyb2xsVG9JZHgsXG4gICAgICAgICAgcm93SWR4OiBzY3JvbGxUb1Jvd0lkeFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNlbGVjdENlbGxcbiAgfSkpO1xuICBjb25zdCBzZXREcmFnZ2VkT3ZlclJvd0lkeCA9IHVzZUNhbGxiYWNrKHJvd0lkeCA9PiB7XG4gICAgc2V0T3ZlclJvd0lkeChyb3dJZHgpO1xuICAgIGxhdGVzdERyYWdnZWRPdmVyUm93SWR4LmN1cnJlbnQgPSByb3dJZHg7XG4gIH0sIFtdKTtcbiAgZnVuY3Rpb24gc2VsZWN0Um93KGFyZ3MpIHtcbiAgICBpZiAoIW9uU2VsZWN0ZWRSb3dzQ2hhbmdlKSByZXR1cm47XG4gICAgYXNzZXJ0SXNWYWxpZEtleUdldHRlcihyb3dLZXlHZXR0ZXIpO1xuICAgIGlmIChhcmdzLnR5cGUgPT09ICdIRUFERVInKSB7XG4gICAgICBjb25zdCBuZXdTZWxlY3RlZFJvd3MgPSBuZXcgU2V0KHNlbGVjdGVkUm93cyk7XG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgIGNvbnN0IHJvd0tleSA9IHJvd0tleUdldHRlcihyb3cpO1xuICAgICAgICBpZiAoYXJncy5jaGVja2VkKSB7XG4gICAgICAgICAgbmV3U2VsZWN0ZWRSb3dzLmFkZChyb3dLZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1NlbGVjdGVkUm93cy5kZWxldGUocm93S2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb25TZWxlY3RlZFJvd3NDaGFuZ2UobmV3U2VsZWN0ZWRSb3dzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcm93LFxuICAgICAgY2hlY2tlZCxcbiAgICAgIGlzU2hpZnRDbGlja1xuICAgIH0gPSBhcmdzO1xuICAgIGNvbnN0IG5ld1NlbGVjdGVkUm93cyA9IG5ldyBTZXQoc2VsZWN0ZWRSb3dzKTtcbiAgICBjb25zdCByb3dLZXkgPSByb3dLZXlHZXR0ZXIocm93KTtcbiAgICBjb25zdCBwcmV2aW91c1Jvd0lkeCA9IGxhc3RTZWxlY3RlZFJvd0lkeC5jdXJyZW50O1xuICAgIGNvbnN0IHJvd0lkeCA9IHJvd3MuaW5kZXhPZihyb3cpO1xuICAgIGxhc3RTZWxlY3RlZFJvd0lkeC5jdXJyZW50ID0gcm93SWR4O1xuICAgIGlmIChjaGVja2VkKSB7XG4gICAgICBuZXdTZWxlY3RlZFJvd3MuYWRkKHJvd0tleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1NlbGVjdGVkUm93cy5kZWxldGUocm93S2V5KTtcbiAgICB9XG4gICAgaWYgKGlzU2hpZnRDbGljayAmJiBwcmV2aW91c1Jvd0lkeCAhPT0gLTEgJiYgcHJldmlvdXNSb3dJZHggIT09IHJvd0lkeCAmJiBwcmV2aW91c1Jvd0lkeCA8IHJvd3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzdGVwID0gc2lnbihyb3dJZHggLSBwcmV2aW91c1Jvd0lkeCk7XG4gICAgICBmb3IgKGxldCBpID0gcHJldmlvdXNSb3dJZHggKyBzdGVwOyBpICE9PSByb3dJZHg7IGkgKz0gc3RlcCkge1xuICAgICAgICBjb25zdCByb3cgPSByb3dzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgIG5ld1NlbGVjdGVkUm93cy5hZGQocm93S2V5R2V0dGVyKHJvdykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1NlbGVjdGVkUm93cy5kZWxldGUocm93S2V5R2V0dGVyKHJvdykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG9uU2VsZWN0ZWRSb3dzQ2hhbmdlKG5ld1NlbGVjdGVkUm93cyk7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkeCxcbiAgICAgIHJvd0lkeCxcbiAgICAgIG1vZGVcbiAgICB9ID0gc2VsZWN0ZWRQb3NpdGlvbjtcbiAgICBpZiAobW9kZSA9PT0gJ0VESVQnKSByZXR1cm47XG4gICAgaWYgKG9uQ2VsbEtleURvd24gJiYgaXNSb3dJZHhXaXRoaW5WaWV3cG9ydEJvdW5kcyhyb3dJZHgpKSB7XG4gICAgICBjb25zdCByb3cgPSByb3dzW3Jvd0lkeF07XG4gICAgICBjb25zdCBjZWxsRXZlbnQgPSBjcmVhdGVDZWxsRXZlbnQoZXZlbnQpO1xuICAgICAgb25DZWxsS2V5RG93bih7XG4gICAgICAgIG1vZGU6ICdTRUxFQ1QnLFxuICAgICAgICByb3csXG4gICAgICAgIGNvbHVtbjogY29sdW1uc1tpZHhdLFxuICAgICAgICByb3dJZHgsXG4gICAgICAgIHNlbGVjdENlbGxcbiAgICAgIH0sIGNlbGxFdmVudCk7XG4gICAgICBpZiAoY2VsbEV2ZW50LmlzR3JpZERlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIShldmVudC50YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSkgcmV0dXJuO1xuICAgIGNvbnN0IGlzQ2VsbEV2ZW50ID0gZXZlbnQudGFyZ2V0LmNsb3Nlc3QoJy5yZGctY2VsbCcpICE9PSBudWxsO1xuICAgIGNvbnN0IGlzUm93RXZlbnQgPSBpc1RyZWVHcmlkICYmIGV2ZW50LnRhcmdldCA9PT0gZm9jdXNTaW5rUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFpc0NlbGxFdmVudCAmJiAhaXNSb3dFdmVudCkgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIGtleUNvZGVcbiAgICB9ID0gZXZlbnQ7XG4gICAgaWYgKHNlbGVjdGVkQ2VsbElzV2l0aGluVmlld3BvcnRCb3VuZHMgJiYgKG9uUGFzdGUgIT0gbnVsbCB8fCBvbkNvcHkgIT0gbnVsbCkgJiYgaXNDdHJsS2V5SGVsZERvd24oZXZlbnQpKSB7XG4gICAgICBjb25zdCBjS2V5ID0gNjc7XG4gICAgICBjb25zdCB2S2V5ID0gODY7XG4gICAgICBpZiAoa2V5Q29kZSA9PT0gY0tleSkge1xuICAgICAgICBpZiAod2luZG93LmdldFNlbGVjdGlvbigpPy5pc0NvbGxhcHNlZCA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgaGFuZGxlQ29weSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoa2V5Q29kZSA9PT0gdktleSkge1xuICAgICAgICBoYW5kbGVQYXN0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICBjYXNlICdFc2NhcGUnOlxuICAgICAgICBzZXRDb3BpZWRDZWxsKG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICBjYXNlICdBcnJvd0xlZnQnOlxuICAgICAgY2FzZSAnQXJyb3dSaWdodCc6XG4gICAgICBjYXNlICdUYWInOlxuICAgICAgY2FzZSAnSG9tZSc6XG4gICAgICBjYXNlICdFbmQnOlxuICAgICAgY2FzZSAnUGFnZVVwJzpcbiAgICAgIGNhc2UgJ1BhZ2VEb3duJzpcbiAgICAgICAgbmF2aWdhdGUoZXZlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGhhbmRsZUNlbGxJbnB1dChldmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVTY3JvbGwoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBzY3JvbGxUb3AsXG4gICAgICBzY3JvbGxMZWZ0XG4gICAgfSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgIHNldFNjcm9sbFRvcChzY3JvbGxUb3ApO1xuICAgICAgc2V0U2Nyb2xsTGVmdChhYnMoc2Nyb2xsTGVmdCkpO1xuICAgIH0pO1xuICAgIG9uU2Nyb2xsPy4oZXZlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVJvdyhjb2x1bW4sIHJvd0lkeCwgcm93KSB7XG4gICAgaWYgKHR5cGVvZiBvblJvd3NDaGFuZ2UgIT09ICdmdW5jdGlvbicpIHJldHVybjtcbiAgICBpZiAocm93ID09PSByb3dzW3Jvd0lkeF0pIHJldHVybjtcbiAgICBjb25zdCB1cGRhdGVkUm93cyA9IFsuLi5yb3dzXTtcbiAgICB1cGRhdGVkUm93c1tyb3dJZHhdID0gcm93O1xuICAgIG9uUm93c0NoYW5nZSh1cGRhdGVkUm93cywge1xuICAgICAgaW5kZXhlczogW3Jvd0lkeF0sXG4gICAgICBjb2x1bW5cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBjb21taXRFZGl0b3JDaGFuZ2VzKCkge1xuICAgIGlmIChzZWxlY3RlZFBvc2l0aW9uLm1vZGUgIT09ICdFRElUJykgcmV0dXJuO1xuICAgIHVwZGF0ZVJvdyhjb2x1bW5zW3NlbGVjdGVkUG9zaXRpb24uaWR4XSwgc2VsZWN0ZWRQb3NpdGlvbi5yb3dJZHgsIHNlbGVjdGVkUG9zaXRpb24ucm93KTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVDb3B5KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkeCxcbiAgICAgIHJvd0lkeFxuICAgIH0gPSBzZWxlY3RlZFBvc2l0aW9uO1xuICAgIGNvbnN0IHNvdXJjZVJvdyA9IHJvd3Nbcm93SWR4XTtcbiAgICBjb25zdCBzb3VyY2VDb2x1bW5LZXkgPSBjb2x1bW5zW2lkeF0ua2V5O1xuICAgIHNldENvcGllZENlbGwoe1xuICAgICAgcm93OiBzb3VyY2VSb3csXG4gICAgICBjb2x1bW5LZXk6IHNvdXJjZUNvbHVtbktleVxuICAgIH0pO1xuICAgIG9uQ29weT8uKHtcbiAgICAgIHNvdXJjZVJvdyxcbiAgICAgIHNvdXJjZUNvbHVtbktleVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVBhc3RlKCkge1xuICAgIGlmICghb25QYXN0ZSB8fCAhb25Sb3dzQ2hhbmdlIHx8IGNvcGllZENlbGwgPT09IG51bGwgfHwgIWlzQ2VsbEVkaXRhYmxlKHNlbGVjdGVkUG9zaXRpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGlkeCxcbiAgICAgIHJvd0lkeFxuICAgIH0gPSBzZWxlY3RlZFBvc2l0aW9uO1xuICAgIGNvbnN0IHRhcmdldENvbHVtbiA9IGNvbHVtbnNbaWR4XTtcbiAgICBjb25zdCB0YXJnZXRSb3cgPSByb3dzW3Jvd0lkeF07XG4gICAgY29uc3QgdXBkYXRlZFRhcmdldFJvdyA9IG9uUGFzdGUoe1xuICAgICAgc291cmNlUm93OiBjb3BpZWRDZWxsLnJvdyxcbiAgICAgIHNvdXJjZUNvbHVtbktleTogY29waWVkQ2VsbC5jb2x1bW5LZXksXG4gICAgICB0YXJnZXRSb3csXG4gICAgICB0YXJnZXRDb2x1bW5LZXk6IHRhcmdldENvbHVtbi5rZXlcbiAgICB9KTtcbiAgICB1cGRhdGVSb3codGFyZ2V0Q29sdW1uLCByb3dJZHgsIHVwZGF0ZWRUYXJnZXRSb3cpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZUNlbGxJbnB1dChldmVudCkge1xuICAgIGlmICghc2VsZWN0ZWRDZWxsSXNXaXRoaW5WaWV3cG9ydEJvdW5kcykgcmV0dXJuO1xuICAgIGNvbnN0IHJvdyA9IHJvd3Nbc2VsZWN0ZWRQb3NpdGlvbi5yb3dJZHhdO1xuICAgIGNvbnN0IHtcbiAgICAgIGtleSxcbiAgICAgIHNoaWZ0S2V5XG4gICAgfSA9IGV2ZW50O1xuICAgIGlmIChpc1NlbGVjdGFibGUgJiYgc2hpZnRLZXkgJiYga2V5ID09PSAnICcpIHtcbiAgICAgIGFzc2VydElzVmFsaWRLZXlHZXR0ZXIocm93S2V5R2V0dGVyKTtcbiAgICAgIGNvbnN0IHJvd0tleSA9IHJvd0tleUdldHRlcihyb3cpO1xuICAgICAgc2VsZWN0Um93KHtcbiAgICAgICAgdHlwZTogJ1JPVycsXG4gICAgICAgIHJvdyxcbiAgICAgICAgY2hlY2tlZDogIXNlbGVjdGVkUm93cy5oYXMocm93S2V5KSxcbiAgICAgICAgaXNTaGlmdENsaWNrOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNDZWxsRWRpdGFibGUoc2VsZWN0ZWRQb3NpdGlvbikgJiYgaXNEZWZhdWx0Q2VsbElucHV0KGV2ZW50KSkge1xuICAgICAgc2V0U2VsZWN0ZWRQb3NpdGlvbigoe1xuICAgICAgICBpZHgsXG4gICAgICAgIHJvd0lkeFxuICAgICAgfSkgPT4gKHtcbiAgICAgICAgaWR4LFxuICAgICAgICByb3dJZHgsXG4gICAgICAgIG1vZGU6ICdFRElUJyxcbiAgICAgICAgcm93LFxuICAgICAgICBvcmlnaW5hbFJvdzogcm93XG4gICAgICB9KSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGlzQ29sSWR4V2l0aGluU2VsZWN0aW9uQm91bmRzKGlkeCkge1xuICAgIHJldHVybiBpZHggPj0gbWluQ29sSWR4ICYmIGlkeCA8PSBtYXhDb2xJZHg7XG4gIH1cbiAgZnVuY3Rpb24gaXNSb3dJZHhXaXRoaW5WaWV3cG9ydEJvdW5kcyhyb3dJZHgpIHtcbiAgICByZXR1cm4gcm93SWR4ID49IDAgJiYgcm93SWR4IDwgcm93cy5sZW5ndGg7XG4gIH1cbiAgZnVuY3Rpb24gaXNDZWxsV2l0aGluU2VsZWN0aW9uQm91bmRzKHtcbiAgICBpZHgsXG4gICAgcm93SWR4XG4gIH0pIHtcbiAgICByZXR1cm4gcm93SWR4ID49IG1pblJvd0lkeCAmJiByb3dJZHggPD0gbWF4Um93SWR4ICYmIGlzQ29sSWR4V2l0aGluU2VsZWN0aW9uQm91bmRzKGlkeCk7XG4gIH1cbiAgZnVuY3Rpb24gaXNDZWxsV2l0aGluRWRpdEJvdW5kcyh7XG4gICAgaWR4LFxuICAgIHJvd0lkeFxuICB9KSB7XG4gICAgcmV0dXJuIGlzUm93SWR4V2l0aGluVmlld3BvcnRCb3VuZHMocm93SWR4KSAmJiBpZHggPj0gMCAmJiBpZHggPD0gbWF4Q29sSWR4O1xuICB9XG4gIGZ1bmN0aW9uIGlzQ2VsbFdpdGhpblZpZXdwb3J0Qm91bmRzKHtcbiAgICBpZHgsXG4gICAgcm93SWR4XG4gIH0pIHtcbiAgICByZXR1cm4gaXNSb3dJZHhXaXRoaW5WaWV3cG9ydEJvdW5kcyhyb3dJZHgpICYmIGlzQ29sSWR4V2l0aGluU2VsZWN0aW9uQm91bmRzKGlkeCk7XG4gIH1cbiAgZnVuY3Rpb24gaXNDZWxsRWRpdGFibGUocG9zaXRpb24pIHtcbiAgICByZXR1cm4gaXNDZWxsV2l0aGluRWRpdEJvdW5kcyhwb3NpdGlvbikgJiYgaXNTZWxlY3RlZENlbGxFZGl0YWJsZSh7XG4gICAgICBjb2x1bW5zLFxuICAgICAgcm93cyxcbiAgICAgIHNlbGVjdGVkUG9zaXRpb246IHBvc2l0aW9uXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc2VsZWN0Q2VsbChwb3NpdGlvbiwgZW5hYmxlRWRpdG9yKSB7XG4gICAgaWYgKCFpc0NlbGxXaXRoaW5TZWxlY3Rpb25Cb3VuZHMocG9zaXRpb24pKSByZXR1cm47XG4gICAgY29tbWl0RWRpdG9yQ2hhbmdlcygpO1xuICAgIGNvbnN0IHJvdyA9IHJvd3NbcG9zaXRpb24ucm93SWR4XTtcbiAgICBjb25zdCBzYW1lUG9zaXRpb24gPSBpc1NhbWVQb3NpdGlvbihzZWxlY3RlZFBvc2l0aW9uLCBwb3NpdGlvbik7XG4gICAgaWYgKGVuYWJsZUVkaXRvciAmJiBpc0NlbGxFZGl0YWJsZShwb3NpdGlvbikpIHtcbiAgICAgIHNldFNlbGVjdGVkUG9zaXRpb24oe1xuICAgICAgICAuLi5wb3NpdGlvbixcbiAgICAgICAgbW9kZTogJ0VESVQnLFxuICAgICAgICByb3csXG4gICAgICAgIG9yaWdpbmFsUm93OiByb3dcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoc2FtZVBvc2l0aW9uKSB7XG4gICAgICBzY3JvbGxJbnRvVmlldyhnZXRDZWxsVG9TY3JvbGwoZ3JpZFJlZi5jdXJyZW50KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZEZvY3VzQ2VsbFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIHNldFNlbGVjdGVkUG9zaXRpb24oe1xuICAgICAgICAuLi5wb3NpdGlvbixcbiAgICAgICAgbW9kZTogJ1NFTEVDVCdcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob25TZWxlY3RlZENlbGxDaGFuZ2UgJiYgIXNhbWVQb3NpdGlvbikge1xuICAgICAgb25TZWxlY3RlZENlbGxDaGFuZ2Uoe1xuICAgICAgICByb3dJZHg6IHBvc2l0aW9uLnJvd0lkeCxcbiAgICAgICAgcm93LFxuICAgICAgICBjb2x1bW46IGNvbHVtbnNbcG9zaXRpb24uaWR4XVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldE5leHRQb3NpdGlvbihrZXksIGN0cmxLZXksIHNoaWZ0S2V5KSB7XG4gICAgY29uc3Qge1xuICAgICAgaWR4LFxuICAgICAgcm93SWR4XG4gICAgfSA9IHNlbGVjdGVkUG9zaXRpb247XG4gICAgY29uc3QgaXNSb3dTZWxlY3RlZCA9IHNlbGVjdGVkQ2VsbElzV2l0aGluU2VsZWN0aW9uQm91bmRzICYmIGlkeCA9PT0gLTE7XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgJ0Fycm93VXAnOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkeCxcbiAgICAgICAgICByb3dJZHg6IHJvd0lkeCAtIDFcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWR4LFxuICAgICAgICAgIHJvd0lkeDogcm93SWR4ICsgMVxuICAgICAgICB9O1xuICAgICAgY2FzZSBsZWZ0S2V5OlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkeDogaWR4IC0gMSxcbiAgICAgICAgICByb3dJZHhcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgcmlnaHRLZXk6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWR4OiBpZHggKyAxLFxuICAgICAgICAgIHJvd0lkeFxuICAgICAgICB9O1xuICAgICAgY2FzZSAnVGFiJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZHg6IGlkeCArIChzaGlmdEtleSA/IC0xIDogMSksXG4gICAgICAgICAgcm93SWR4XG4gICAgICAgIH07XG4gICAgICBjYXNlICdIb21lJzpcbiAgICAgICAgaWYgKGlzUm93U2VsZWN0ZWQpIHJldHVybiB7XG4gICAgICAgICAgaWR4LFxuICAgICAgICAgIHJvd0lkeDogbWluUm93SWR4XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWR4OiAwLFxuICAgICAgICAgIHJvd0lkeDogY3RybEtleSA/IG1pblJvd0lkeCA6IHJvd0lkeFxuICAgICAgICB9O1xuICAgICAgY2FzZSAnRW5kJzpcbiAgICAgICAgaWYgKGlzUm93U2VsZWN0ZWQpIHJldHVybiB7XG4gICAgICAgICAgaWR4LFxuICAgICAgICAgIHJvd0lkeDogbWF4Um93SWR4XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWR4OiBtYXhDb2xJZHgsXG4gICAgICAgICAgcm93SWR4OiBjdHJsS2V5ID8gbWF4Um93SWR4IDogcm93SWR4XG4gICAgICAgIH07XG4gICAgICBjYXNlICdQYWdlVXAnOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkUG9zaXRpb24ucm93SWR4ID09PSBtaW5Sb3dJZHgpIHJldHVybiBzZWxlY3RlZFBvc2l0aW9uO1xuICAgICAgICAgIGNvbnN0IG5leHRSb3dZID0gZ2V0Um93VG9wKHJvd0lkeCkgKyBnZXRSb3dIZWlnaHQocm93SWR4KSAtIGNsaWVudEhlaWdodDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWR4LFxuICAgICAgICAgICAgcm93SWR4OiBuZXh0Um93WSA+IDAgPyBmaW5kUm93SWR4KG5leHRSb3dZKSA6IDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICBjYXNlICdQYWdlRG93bic6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWRQb3NpdGlvbi5yb3dJZHggPj0gcm93cy5sZW5ndGgpIHJldHVybiBzZWxlY3RlZFBvc2l0aW9uO1xuICAgICAgICAgIGNvbnN0IG5leHRSb3dZID0gZ2V0Um93VG9wKHJvd0lkeCkgKyBjbGllbnRIZWlnaHQ7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkeCxcbiAgICAgICAgICAgIHJvd0lkeDogbmV4dFJvd1kgPCB0b3RhbFJvd0hlaWdodCA/IGZpbmRSb3dJZHgobmV4dFJvd1kpIDogcm93cy5sZW5ndGggLSAxXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkUG9zaXRpb247XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG5hdmlnYXRlKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAga2V5LFxuICAgICAgc2hpZnRLZXlcbiAgICB9ID0gZXZlbnQ7XG4gICAgbGV0IGNlbGxOYXZpZ2F0aW9uTW9kZSA9ICdOT05FJztcbiAgICBpZiAoa2V5ID09PSAnVGFiJykge1xuICAgICAgaWYgKGNhbkV4aXRHcmlkKHtcbiAgICAgICAgc2hpZnRLZXksXG4gICAgICAgIG1heENvbElkeCxcbiAgICAgICAgbWluUm93SWR4LFxuICAgICAgICBtYXhSb3dJZHgsXG4gICAgICAgIHNlbGVjdGVkUG9zaXRpb25cbiAgICAgIH0pKSB7XG4gICAgICAgIGNvbW1pdEVkaXRvckNoYW5nZXMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2VsbE5hdmlnYXRpb25Nb2RlID0gJ0NIQU5HRV9ST1cnO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IGN0cmxLZXkgPSBpc0N0cmxLZXlIZWxkRG93bihldmVudCk7XG4gICAgY29uc3QgbmV4dFBvc2l0aW9uID0gZ2V0TmV4dFBvc2l0aW9uKGtleSwgY3RybEtleSwgc2hpZnRLZXkpO1xuICAgIGlmIChpc1NhbWVQb3NpdGlvbihzZWxlY3RlZFBvc2l0aW9uLCBuZXh0UG9zaXRpb24pKSByZXR1cm47XG4gICAgY29uc3QgbmV4dFNlbGVjdGVkQ2VsbFBvc2l0aW9uID0gZ2V0TmV4dFNlbGVjdGVkQ2VsbFBvc2l0aW9uKHtcbiAgICAgIG1vdmVVcDoga2V5ID09PSAnQXJyb3dVcCcsXG4gICAgICBtb3ZlTmV4dDoga2V5ID09PSByaWdodEtleSB8fCBrZXkgPT09ICdUYWInICYmICFzaGlmdEtleSxcbiAgICAgIGNvbHVtbnMsXG4gICAgICBjb2xTcGFuQ29sdW1ucyxcbiAgICAgIHJvd3MsXG4gICAgICB0b3BTdW1tYXJ5Um93cyxcbiAgICAgIGJvdHRvbVN1bW1hcnlSb3dzLFxuICAgICAgbWluUm93SWR4LFxuICAgICAgbWFpbkhlYWRlclJvd0lkeCxcbiAgICAgIG1heFJvd0lkeCxcbiAgICAgIGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgICAgIGNlbGxOYXZpZ2F0aW9uTW9kZSxcbiAgICAgIGN1cnJlbnRQb3NpdGlvbjogc2VsZWN0ZWRQb3NpdGlvbixcbiAgICAgIG5leHRQb3NpdGlvbixcbiAgICAgIGlzQ2VsbFdpdGhpbkJvdW5kczogaXNDZWxsV2l0aGluU2VsZWN0aW9uQm91bmRzXG4gICAgfSk7XG4gICAgc2VsZWN0Q2VsbChuZXh0U2VsZWN0ZWRDZWxsUG9zaXRpb24pO1xuICB9XG4gIGZ1bmN0aW9uIGdldERyYWdnZWRPdmVyQ2VsbElkeChjdXJyZW50Um93SWR4KSB7XG4gICAgaWYgKGRyYWdnZWRPdmVyUm93SWR4ID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICByb3dJZHhcbiAgICB9ID0gc2VsZWN0ZWRQb3NpdGlvbjtcbiAgICBjb25zdCBpc0RyYWdnZWRPdmVyID0gcm93SWR4IDwgZHJhZ2dlZE92ZXJSb3dJZHggPyByb3dJZHggPCBjdXJyZW50Um93SWR4ICYmIGN1cnJlbnRSb3dJZHggPD0gZHJhZ2dlZE92ZXJSb3dJZHggOiByb3dJZHggPiBjdXJyZW50Um93SWR4ICYmIGN1cnJlbnRSb3dJZHggPj0gZHJhZ2dlZE92ZXJSb3dJZHg7XG4gICAgcmV0dXJuIGlzRHJhZ2dlZE92ZXIgPyBzZWxlY3RlZFBvc2l0aW9uLmlkeCA6IHVuZGVmaW5lZDtcbiAgfVxuICBmdW5jdGlvbiBmb2N1c0NlbGxPckNlbGxDb250ZW50KCkge1xuICAgIGNvbnN0IGNlbGwgPSBnZXRDZWxsVG9TY3JvbGwoZ3JpZFJlZi5jdXJyZW50KTtcbiAgICBpZiAoY2VsbCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgIHNjcm9sbEludG9WaWV3KGNlbGwpO1xuICAgIGNvbnN0IGVsZW1lbnRUb0ZvY3VzID0gY2VsbC5xdWVyeVNlbGVjdG9yKCdbdGFiaW5kZXg9XCIwXCJdJykgPz8gY2VsbDtcbiAgICBlbGVtZW50VG9Gb2N1cy5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyRHJhZ0hhbmRsZSgpIHtcbiAgICBpZiAob25GaWxsID09IG51bGwgfHwgc2VsZWN0ZWRQb3NpdGlvbi5tb2RlID09PSAnRURJVCcgfHwgIWlzQ2VsbFdpdGhpblZpZXdwb3J0Qm91bmRzKHNlbGVjdGVkUG9zaXRpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGlkeCxcbiAgICAgIHJvd0lkeFxuICAgIH0gPSBzZWxlY3RlZFBvc2l0aW9uO1xuICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnNbaWR4XTtcbiAgICBpZiAoY29sdW1uLnJlbmRlckVkaXRDZWxsID09IG51bGwgfHwgY29sdW1uLmVkaXRhYmxlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb2x1bW5XaWR0aCA9IGdldENvbHVtbldpZHRoKGNvbHVtbik7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goRHJhZ0hhbmRsZSwge1xuICAgICAgZ3JpZFJvd1N0YXJ0OiBoZWFkZXJBbmRUb3BTdW1tYXJ5Um93c0NvdW50ICsgcm93SWR4ICsgMSxcbiAgICAgIHJvd3M6IHJvd3MsXG4gICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgIGNvbHVtbldpZHRoOiBjb2x1bW5XaWR0aCxcbiAgICAgIG1heENvbElkeDogbWF4Q29sSWR4LFxuICAgICAgaXNMYXN0Um93OiByb3dJZHggPT09IG1heFJvd0lkeCxcbiAgICAgIHNlbGVjdGVkUG9zaXRpb246IHNlbGVjdGVkUG9zaXRpb24sXG4gICAgICBpc0NlbGxFZGl0YWJsZTogaXNDZWxsRWRpdGFibGUsXG4gICAgICBsYXRlc3REcmFnZ2VkT3ZlclJvd0lkeDogbGF0ZXN0RHJhZ2dlZE92ZXJSb3dJZHgsXG4gICAgICBvblJvd3NDaGFuZ2U6IG9uUm93c0NoYW5nZSxcbiAgICAgIG9uQ2xpY2s6IGZvY3VzQ2VsbE9yQ2VsbENvbnRlbnQsXG4gICAgICBvbkZpbGw6IG9uRmlsbCxcbiAgICAgIHNldERyYWdnaW5nOiBzZXREcmFnZ2luZyxcbiAgICAgIHNldERyYWdnZWRPdmVyUm93SWR4OiBzZXREcmFnZ2VkT3ZlclJvd0lkeFxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdldENlbGxFZGl0b3Iocm93SWR4KSB7XG4gICAgaWYgKHNlbGVjdGVkUG9zaXRpb24ucm93SWR4ICE9PSByb3dJZHggfHwgc2VsZWN0ZWRQb3NpdGlvbi5tb2RlID09PSAnU0VMRUNUJykgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkeCxcbiAgICAgIHJvd1xuICAgIH0gPSBzZWxlY3RlZFBvc2l0aW9uO1xuICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnNbaWR4XTtcbiAgICBjb25zdCBjb2xTcGFuID0gZ2V0Q29sU3Bhbihjb2x1bW4sIGxhc3RGcm96ZW5Db2x1bW5JbmRleCwge1xuICAgICAgdHlwZTogJ1JPVycsXG4gICAgICByb3dcbiAgICB9KTtcbiAgICBjb25zdCBjbG9zZUVkaXRvciA9IHNob3VsZEZvY3VzQ2VsbCA9PiB7XG4gICAgICBzaG91bGRGb2N1c0NlbGxSZWYuY3VycmVudCA9IHNob3VsZEZvY3VzQ2VsbDtcbiAgICAgIHNldFNlbGVjdGVkUG9zaXRpb24oKHtcbiAgICAgICAgaWR4LFxuICAgICAgICByb3dJZHhcbiAgICAgIH0pID0+ICh7XG4gICAgICAgIGlkeCxcbiAgICAgICAgcm93SWR4LFxuICAgICAgICBtb2RlOiAnU0VMRUNUJ1xuICAgICAgfSkpO1xuICAgIH07XG4gICAgY29uc3Qgb25Sb3dDaGFuZ2UgPSAocm93LCBjb21taXRDaGFuZ2VzLCBzaG91bGRGb2N1c0NlbGwpID0+IHtcbiAgICAgIGlmIChjb21taXRDaGFuZ2VzKSB7XG4gICAgICAgIGZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgdXBkYXRlUm93KGNvbHVtbiwgc2VsZWN0ZWRQb3NpdGlvbi5yb3dJZHgsIHJvdyk7XG4gICAgICAgICAgY2xvc2VFZGl0b3Ioc2hvdWxkRm9jdXNDZWxsKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3RlZFBvc2l0aW9uKHBvc2l0aW9uID0+ICh7XG4gICAgICAgICAgLi4ucG9zaXRpb24sXG4gICAgICAgICAgcm93XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChyb3dzW3NlbGVjdGVkUG9zaXRpb24ucm93SWR4XSAhPT0gc2VsZWN0ZWRQb3NpdGlvbi5vcmlnaW5hbFJvdykge1xuICAgICAgY2xvc2VFZGl0b3IoZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gLyojX19QVVJFX18qL2pzeChFZGl0Q2VsbCwge1xuICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICBjb2xTcGFuOiBjb2xTcGFuLFxuICAgICAgcm93OiByb3csXG4gICAgICByb3dJZHg6IHJvd0lkeCxcbiAgICAgIG9uUm93Q2hhbmdlOiBvblJvd0NoYW5nZSxcbiAgICAgIGNsb3NlRWRpdG9yOiBjbG9zZUVkaXRvcixcbiAgICAgIG9uS2V5RG93bjogb25DZWxsS2V5RG93bixcbiAgICAgIG5hdmlnYXRlOiBuYXZpZ2F0ZVxuICAgIH0sIGNvbHVtbi5rZXkpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFJvd1ZpZXdwb3J0Q29sdW1ucyhyb3dJZHgpIHtcbiAgICBjb25zdCBzZWxlY3RlZENvbHVtbiA9IHNlbGVjdGVkUG9zaXRpb24uaWR4ID09PSAtMSA/IHVuZGVmaW5lZCA6IGNvbHVtbnNbc2VsZWN0ZWRQb3NpdGlvbi5pZHhdO1xuICAgIGlmIChzZWxlY3RlZENvbHVtbiAhPT0gdW5kZWZpbmVkICYmIHNlbGVjdGVkUG9zaXRpb24ucm93SWR4ID09PSByb3dJZHggJiYgIXZpZXdwb3J0Q29sdW1ucy5pbmNsdWRlcyhzZWxlY3RlZENvbHVtbikpIHtcbiAgICAgIHJldHVybiBzZWxlY3RlZFBvc2l0aW9uLmlkeCA+IGNvbE92ZXJzY2FuRW5kSWR4ID8gWy4uLnZpZXdwb3J0Q29sdW1ucywgc2VsZWN0ZWRDb2x1bW5dIDogWy4uLnZpZXdwb3J0Q29sdW1ucy5zbGljZSgwLCBsYXN0RnJvemVuQ29sdW1uSW5kZXggKyAxKSwgc2VsZWN0ZWRDb2x1bW4sIC4uLnZpZXdwb3J0Q29sdW1ucy5zbGljZShsYXN0RnJvemVuQ29sdW1uSW5kZXggKyAxKV07XG4gICAgfVxuICAgIHJldHVybiB2aWV3cG9ydENvbHVtbnM7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Vmlld3BvcnRSb3dzKCkge1xuICAgIGNvbnN0IHJvd0VsZW1lbnRzID0gW107XG4gICAgY29uc3Qge1xuICAgICAgaWR4OiBzZWxlY3RlZElkeCxcbiAgICAgIHJvd0lkeDogc2VsZWN0ZWRSb3dJZHhcbiAgICB9ID0gc2VsZWN0ZWRQb3NpdGlvbjtcbiAgICBjb25zdCBzdGFydFJvd0lkeCA9IHNlbGVjdGVkQ2VsbElzV2l0aGluVmlld3BvcnRCb3VuZHMgJiYgc2VsZWN0ZWRSb3dJZHggPCByb3dPdmVyc2NhblN0YXJ0SWR4ID8gcm93T3ZlcnNjYW5TdGFydElkeCAtIDEgOiByb3dPdmVyc2NhblN0YXJ0SWR4O1xuICAgIGNvbnN0IGVuZFJvd0lkeCA9IHNlbGVjdGVkQ2VsbElzV2l0aGluVmlld3BvcnRCb3VuZHMgJiYgc2VsZWN0ZWRSb3dJZHggPiByb3dPdmVyc2NhbkVuZElkeCA/IHJvd092ZXJzY2FuRW5kSWR4ICsgMSA6IHJvd092ZXJzY2FuRW5kSWR4O1xuICAgIGZvciAobGV0IHZpZXdwb3J0Um93SWR4ID0gc3RhcnRSb3dJZHg7IHZpZXdwb3J0Um93SWR4IDw9IGVuZFJvd0lkeDsgdmlld3BvcnRSb3dJZHgrKykge1xuICAgICAgY29uc3QgaXNSb3dPdXRzaWRlVmlld3BvcnQgPSB2aWV3cG9ydFJvd0lkeCA9PT0gcm93T3ZlcnNjYW5TdGFydElkeCAtIDEgfHwgdmlld3BvcnRSb3dJZHggPT09IHJvd092ZXJzY2FuRW5kSWR4ICsgMTtcbiAgICAgIGNvbnN0IHJvd0lkeCA9IGlzUm93T3V0c2lkZVZpZXdwb3J0ID8gc2VsZWN0ZWRSb3dJZHggOiB2aWV3cG9ydFJvd0lkeDtcbiAgICAgIGxldCByb3dDb2x1bW5zID0gdmlld3BvcnRDb2x1bW5zO1xuICAgICAgY29uc3Qgc2VsZWN0ZWRDb2x1bW4gPSBzZWxlY3RlZElkeCA9PT0gLTEgPyB1bmRlZmluZWQgOiBjb2x1bW5zW3NlbGVjdGVkSWR4XTtcbiAgICAgIGlmIChzZWxlY3RlZENvbHVtbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1Jvd091dHNpZGVWaWV3cG9ydCkge1xuICAgICAgICAgIHJvd0NvbHVtbnMgPSBbc2VsZWN0ZWRDb2x1bW5dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvd0NvbHVtbnMgPSBnZXRSb3dWaWV3cG9ydENvbHVtbnMocm93SWR4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgcm93ID0gcm93c1tyb3dJZHhdO1xuICAgICAgY29uc3QgZ3JpZFJvd1N0YXJ0ID0gaGVhZGVyQW5kVG9wU3VtbWFyeVJvd3NDb3VudCArIHJvd0lkeCArIDE7XG4gICAgICBsZXQga2V5ID0gcm93SWR4O1xuICAgICAgbGV0IGlzUm93U2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGlmICh0eXBlb2Ygcm93S2V5R2V0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGtleSA9IHJvd0tleUdldHRlcihyb3cpO1xuICAgICAgICBpc1Jvd1NlbGVjdGVkID0gc2VsZWN0ZWRSb3dzPy5oYXMoa2V5KSA/PyBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJvd0VsZW1lbnRzLnB1c2gocmVuZGVyUm93KGtleSwge1xuICAgICAgICAnYXJpYS1yb3dpbmRleCc6IGhlYWRlckFuZFRvcFN1bW1hcnlSb3dzQ291bnQgKyByb3dJZHggKyAxLFxuICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IGlzU2VsZWN0YWJsZSA/IGlzUm93U2VsZWN0ZWQgOiB1bmRlZmluZWQsXG4gICAgICAgIHJvd0lkeCxcbiAgICAgICAgcm93LFxuICAgICAgICB2aWV3cG9ydENvbHVtbnM6IHJvd0NvbHVtbnMsXG4gICAgICAgIGlzUm93U2VsZWN0ZWQsXG4gICAgICAgIG9uQ2VsbENsaWNrOiBvbkNlbGxDbGlja0xhdGVzdCxcbiAgICAgICAgb25DZWxsRG91YmxlQ2xpY2s6IG9uQ2VsbERvdWJsZUNsaWNrTGF0ZXN0LFxuICAgICAgICBvbkNlbGxDb250ZXh0TWVudTogb25DZWxsQ29udGV4dE1lbnVMYXRlc3QsXG4gICAgICAgIHJvd0NsYXNzLFxuICAgICAgICBncmlkUm93U3RhcnQsXG4gICAgICAgIGNvcGllZENlbGxJZHg6IGNvcGllZENlbGwgIT09IG51bGwgJiYgY29waWVkQ2VsbC5yb3cgPT09IHJvdyA/IGNvbHVtbnMuZmluZEluZGV4KGMgPT4gYy5rZXkgPT09IGNvcGllZENlbGwuY29sdW1uS2V5KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc2VsZWN0ZWRDZWxsSWR4OiBzZWxlY3RlZFJvd0lkeCA9PT0gcm93SWR4ID8gc2VsZWN0ZWRJZHggOiB1bmRlZmluZWQsXG4gICAgICAgIGRyYWdnZWRPdmVyQ2VsbElkeDogZ2V0RHJhZ2dlZE92ZXJDZWxsSWR4KHJvd0lkeCksXG4gICAgICAgIHNldERyYWdnZWRPdmVyUm93SWR4OiBpc0RyYWdnaW5nID8gc2V0RHJhZ2dlZE92ZXJSb3dJZHggOiB1bmRlZmluZWQsXG4gICAgICAgIGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgICAgICAgb25Sb3dDaGFuZ2U6IGhhbmRsZUZvcm1hdHRlclJvd0NoYW5nZUxhdGVzdCxcbiAgICAgICAgc2VsZWN0Q2VsbDogc2VsZWN0Q2VsbExhdGVzdCxcbiAgICAgICAgc2VsZWN0ZWRDZWxsRWRpdG9yOiBnZXRDZWxsRWRpdG9yKHJvd0lkeClcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvd0VsZW1lbnRzO1xuICB9XG4gIGlmIChzZWxlY3RlZFBvc2l0aW9uLmlkeCA+IG1heENvbElkeCB8fCBzZWxlY3RlZFBvc2l0aW9uLnJvd0lkeCA+IG1heFJvd0lkeCkge1xuICAgIHNldFNlbGVjdGVkUG9zaXRpb24oe1xuICAgICAgaWR4OiAtMSxcbiAgICAgIHJvd0lkeDogbWluUm93SWR4IC0gMSxcbiAgICAgIG1vZGU6ICdTRUxFQ1QnXG4gICAgfSk7XG4gICAgc2V0RHJhZ2dlZE92ZXJSb3dJZHgodW5kZWZpbmVkKTtcbiAgfVxuICBsZXQgdGVtcGxhdGVSb3dzID0gYHJlcGVhdCgke2hlYWRlclJvd3NDb3VudH0sICR7aGVhZGVyUm93SGVpZ2h0fXB4KWA7XG4gIGlmICh0b3BTdW1tYXJ5Um93c0NvdW50ID4gMCkge1xuICAgIHRlbXBsYXRlUm93cyArPSBgIHJlcGVhdCgke3RvcFN1bW1hcnlSb3dzQ291bnR9LCAke3N1bW1hcnlSb3dIZWlnaHR9cHgpYDtcbiAgfVxuICBpZiAocm93cy5sZW5ndGggPiAwKSB7XG4gICAgdGVtcGxhdGVSb3dzICs9IGdyaWRUZW1wbGF0ZVJvd3M7XG4gIH1cbiAgaWYgKGJvdHRvbVN1bW1hcnlSb3dzQ291bnQgPiAwKSB7XG4gICAgdGVtcGxhdGVSb3dzICs9IGAgcmVwZWF0KCR7Ym90dG9tU3VtbWFyeVJvd3NDb3VudH0sICR7c3VtbWFyeVJvd0hlaWdodH1weClgO1xuICB9XG4gIGNvbnN0IGlzR3JvdXBSb3dGb2N1c2VkID0gc2VsZWN0ZWRQb3NpdGlvbi5pZHggPT09IC0xICYmIHNlbGVjdGVkUG9zaXRpb24ucm93SWR4ICE9PSBtaW5Sb3dJZHggLSAxO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeHMoXCJkaXZcIiwge1xuICAgIHJvbGU6IHJvbGUsXG4gICAgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbCxcbiAgICBcImFyaWEtbGFiZWxsZWRieVwiOiBhcmlhTGFiZWxsZWRCeSxcbiAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogYXJpYURlc2NyaWJlZEJ5LFxuICAgIFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcIjogaXNTZWxlY3RhYmxlID8gdHJ1ZSA6IHVuZGVmaW5lZCxcbiAgICBcImFyaWEtY29sY291bnRcIjogY29sdW1ucy5sZW5ndGgsXG4gICAgXCJhcmlhLXJvd2NvdW50XCI6IGFyaWFSb3dDb3VudCxcbiAgICBjbGFzc05hbWU6IGNsc3gocm9vdENsYXNzbmFtZSwgY2xhc3NOYW1lLCBpc0RyYWdnaW5nICYmIHZpZXdwb3J0RHJhZ2dpbmdDbGFzc25hbWUpLFxuICAgIHN0eWxlOiB7XG4gICAgICAuLi5zdHlsZSxcbiAgICAgIHNjcm9sbFBhZGRpbmdJbmxpbmVTdGFydDogc2VsZWN0ZWRQb3NpdGlvbi5pZHggPiBsYXN0RnJvemVuQ29sdW1uSW5kZXggfHwgc2Nyb2xsVG9Qb3NpdGlvbj8uaWR4ICE9PSB1bmRlZmluZWQgPyBgJHt0b3RhbEZyb3plbkNvbHVtbldpZHRofXB4YCA6IHVuZGVmaW5lZCxcbiAgICAgIHNjcm9sbFBhZGRpbmdCbG9jazogaXNSb3dJZHhXaXRoaW5WaWV3cG9ydEJvdW5kcyhzZWxlY3RlZFBvc2l0aW9uLnJvd0lkeCkgfHwgc2Nyb2xsVG9Qb3NpdGlvbj8ucm93SWR4ICE9PSB1bmRlZmluZWQgPyBgJHtoZWFkZXJSb3dzSGVpZ2h0ICsgdG9wU3VtbWFyeVJvd3NDb3VudCAqIHN1bW1hcnlSb3dIZWlnaHR9cHggJHtib3R0b21TdW1tYXJ5Um93c0NvdW50ICogc3VtbWFyeVJvd0hlaWdodH1weGAgOiB1bmRlZmluZWQsXG4gICAgICBncmlkVGVtcGxhdGVDb2x1bW5zLFxuICAgICAgZ3JpZFRlbXBsYXRlUm93czogdGVtcGxhdGVSb3dzLFxuICAgICAgJy0tcmRnLWhlYWRlci1yb3ctaGVpZ2h0JzogYCR7aGVhZGVyUm93SGVpZ2h0fXB4YCxcbiAgICAgICctLXJkZy1zY3JvbGwtaGVpZ2h0JzogYCR7c2Nyb2xsSGVpZ2h0fXB4YCxcbiAgICAgIC4uLmxheW91dENzc1ZhcnNcbiAgICB9LFxuICAgIGRpcjogZGlyZWN0aW9uLFxuICAgIHJlZjogZ3JpZFJlZixcbiAgICBvblNjcm9sbDogaGFuZGxlU2Nyb2xsLFxuICAgIG9uS2V5RG93bjogaGFuZGxlS2V5RG93bixcbiAgICBcImRhdGEtdGVzdGlkXCI6IHRlc3RJZCxcbiAgICBjaGlsZHJlbjogWy8qI19fUFVSRV9fKi9qc3goRGF0YUdyaWREZWZhdWx0UmVuZGVyZXJzUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBkZWZhdWx0R3JpZENvbXBvbmVudHMsXG4gICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeHMoUm93U2VsZWN0aW9uQ2hhbmdlUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHNlbGVjdFJvd0xhdGVzdCxcbiAgICAgICAgY2hpbGRyZW46IFsvKiNfX1BVUkVfXyovanN4cyhSb3dTZWxlY3Rpb25Qcm92aWRlciwge1xuICAgICAgICAgIHZhbHVlOiBhbGxSb3dzU2VsZWN0ZWQsXG4gICAgICAgICAgY2hpbGRyZW46IFtBcnJheS5mcm9tKHtcbiAgICAgICAgICAgIGxlbmd0aDogZ3JvdXBlZENvbHVtbkhlYWRlclJvd3NDb3VudFxuICAgICAgICAgIH0sIChfLCBpbmRleCkgPT4gLyojX19QVVJFX18qL2pzeChHcm91cGVkQ29sdW1uSGVhZGVyUm93JDEsIHtcbiAgICAgICAgICAgIHJvd0lkeDogaW5kZXggKyAxLFxuICAgICAgICAgICAgbGV2ZWw6IC1ncm91cGVkQ29sdW1uSGVhZGVyUm93c0NvdW50ICsgaW5kZXgsXG4gICAgICAgICAgICBjb2x1bW5zOiBnZXRSb3dWaWV3cG9ydENvbHVtbnMobWluUm93SWR4ICsgaW5kZXgpLFxuICAgICAgICAgICAgc2VsZWN0ZWRDZWxsSWR4OiBzZWxlY3RlZFBvc2l0aW9uLnJvd0lkeCA9PT0gbWluUm93SWR4ICsgaW5kZXggPyBzZWxlY3RlZFBvc2l0aW9uLmlkeCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNlbGVjdENlbGw6IHNlbGVjdEhlYWRlckNlbGxMYXRlc3RcbiAgICAgICAgICB9LCBpbmRleCkpLCAvKiNfX1BVUkVfXyovanN4KEhlYWRlclJvdyQxLCB7XG4gICAgICAgICAgICByb3dJZHg6IGhlYWRlclJvd3NDb3VudCxcbiAgICAgICAgICAgIGNvbHVtbnM6IGdldFJvd1ZpZXdwb3J0Q29sdW1ucyhtYWluSGVhZGVyUm93SWR4KSxcbiAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplOiBoYW5kbGVDb2x1bW5SZXNpemVMYXRlc3QsXG4gICAgICAgICAgICBvbkNvbHVtbnNSZW9yZGVyOiBvbkNvbHVtbnNSZW9yZGVyTGFzdGVzdCxcbiAgICAgICAgICAgIHNvcnRDb2x1bW5zOiBzb3J0Q29sdW1ucyxcbiAgICAgICAgICAgIG9uU29ydENvbHVtbnNDaGFuZ2U6IG9uU29ydENvbHVtbnNDaGFuZ2VMYXRlc3QsXG4gICAgICAgICAgICBsYXN0RnJvemVuQ29sdW1uSW5kZXg6IGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgICAgICAgICAgIHNlbGVjdGVkQ2VsbElkeDogc2VsZWN0ZWRQb3NpdGlvbi5yb3dJZHggPT09IG1haW5IZWFkZXJSb3dJZHggPyBzZWxlY3RlZFBvc2l0aW9uLmlkeCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNlbGVjdENlbGw6IHNlbGVjdEhlYWRlckNlbGxMYXRlc3QsXG4gICAgICAgICAgICBzaG91bGRGb2N1c0dyaWQ6ICFzZWxlY3RlZENlbGxJc1dpdGhpblNlbGVjdGlvbkJvdW5kcyxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgICAgICAgfSldXG4gICAgICAgIH0pLCByb3dzLmxlbmd0aCA9PT0gMCAmJiBub1Jvd3NGYWxsYmFjayA/IG5vUm93c0ZhbGxiYWNrIDogLyojX19QVVJFX18qL2pzeHMoRnJhZ21lbnQsIHtcbiAgICAgICAgICBjaGlsZHJlbjogW3RvcFN1bW1hcnlSb3dzPy5tYXAoKHJvdywgcm93SWR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBncmlkUm93U3RhcnQgPSBoZWFkZXJSb3dzQ291bnQgKyAxICsgcm93SWR4O1xuICAgICAgICAgICAgY29uc3Qgc3VtbWFyeVJvd0lkeCA9IG1haW5IZWFkZXJSb3dJZHggKyAxICsgcm93SWR4O1xuICAgICAgICAgICAgY29uc3QgaXNTdW1tYXJ5Um93U2VsZWN0ZWQgPSBzZWxlY3RlZFBvc2l0aW9uLnJvd0lkeCA9PT0gc3VtbWFyeVJvd0lkeDtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGhlYWRlclJvd3NIZWlnaHQgKyBzdW1tYXJ5Um93SGVpZ2h0ICogcm93SWR4O1xuICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goU3VtbWFyeVJvdyQxLCB7XG4gICAgICAgICAgICAgIFwiYXJpYS1yb3dpbmRleFwiOiBncmlkUm93U3RhcnQsXG4gICAgICAgICAgICAgIHJvd0lkeDogc3VtbWFyeVJvd0lkeCxcbiAgICAgICAgICAgICAgZ3JpZFJvd1N0YXJ0OiBncmlkUm93U3RhcnQsXG4gICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgYm90dG9tOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHZpZXdwb3J0Q29sdW1uczogZ2V0Um93Vmlld3BvcnRDb2x1bW5zKHN1bW1hcnlSb3dJZHgpLFxuICAgICAgICAgICAgICBsYXN0RnJvemVuQ29sdW1uSW5kZXg6IGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgICAgICAgICAgICAgc2VsZWN0ZWRDZWxsSWR4OiBpc1N1bW1hcnlSb3dTZWxlY3RlZCA/IHNlbGVjdGVkUG9zaXRpb24uaWR4IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBpc1RvcDogdHJ1ZSxcbiAgICAgICAgICAgICAgc2VsZWN0Q2VsbDogc2VsZWN0Q2VsbExhdGVzdFxuICAgICAgICAgICAgfSwgcm93SWR4KTtcbiAgICAgICAgICB9KSwgZ2V0Vmlld3BvcnRSb3dzKCksIGJvdHRvbVN1bW1hcnlSb3dzPy5tYXAoKHJvdywgcm93SWR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBncmlkUm93U3RhcnQgPSBoZWFkZXJBbmRUb3BTdW1tYXJ5Um93c0NvdW50ICsgcm93cy5sZW5ndGggKyByb3dJZHggKyAxO1xuICAgICAgICAgICAgY29uc3Qgc3VtbWFyeVJvd0lkeCA9IHJvd3MubGVuZ3RoICsgcm93SWR4O1xuICAgICAgICAgICAgY29uc3QgaXNTdW1tYXJ5Um93U2VsZWN0ZWQgPSBzZWxlY3RlZFBvc2l0aW9uLnJvd0lkeCA9PT0gc3VtbWFyeVJvd0lkeDtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGNsaWVudEhlaWdodCA+IHRvdGFsUm93SGVpZ2h0ID8gZ3JpZEhlaWdodCAtIHN1bW1hcnlSb3dIZWlnaHQgKiAoYm90dG9tU3VtbWFyeVJvd3MubGVuZ3RoIC0gcm93SWR4KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IHRvcCA9PT0gdW5kZWZpbmVkID8gc3VtbWFyeVJvd0hlaWdodCAqIChib3R0b21TdW1tYXJ5Um93cy5sZW5ndGggLSAxIC0gcm93SWR4KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFN1bW1hcnlSb3ckMSwge1xuICAgICAgICAgICAgICBcImFyaWEtcm93aW5kZXhcIjogYXJpYVJvd0NvdW50IC0gYm90dG9tU3VtbWFyeVJvd3NDb3VudCArIHJvd0lkeCArIDEsXG4gICAgICAgICAgICAgIHJvd0lkeDogc3VtbWFyeVJvd0lkeCxcbiAgICAgICAgICAgICAgZ3JpZFJvd1N0YXJ0OiBncmlkUm93U3RhcnQsXG4gICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgYm90dG9tOiBib3R0b20sXG4gICAgICAgICAgICAgIHZpZXdwb3J0Q29sdW1uczogZ2V0Um93Vmlld3BvcnRDb2x1bW5zKHN1bW1hcnlSb3dJZHgpLFxuICAgICAgICAgICAgICBsYXN0RnJvemVuQ29sdW1uSW5kZXg6IGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgICAgICAgICAgICAgc2VsZWN0ZWRDZWxsSWR4OiBpc1N1bW1hcnlSb3dTZWxlY3RlZCA/IHNlbGVjdGVkUG9zaXRpb24uaWR4IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBpc1RvcDogZmFsc2UsXG4gICAgICAgICAgICAgIHNlbGVjdENlbGw6IHNlbGVjdENlbGxMYXRlc3RcbiAgICAgICAgICAgIH0sIHJvd0lkeCk7XG4gICAgICAgICAgfSldXG4gICAgICAgIH0pXVxuICAgICAgfSlcbiAgICB9KSwgcmVuZGVyRHJhZ0hhbmRsZSgpLCByZW5kZXJNZWFzdXJpbmdDZWxscyh2aWV3cG9ydENvbHVtbnMpLCBpc1RyZWVHcmlkICYmIC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgICAgcmVmOiBmb2N1c1NpbmtSZWYsXG4gICAgICB0YWJJbmRleDogaXNHcm91cFJvd0ZvY3VzZWQgPyAwIDogLTEsXG4gICAgICBjbGFzc05hbWU6IGNsc3goZm9jdXNTaW5rQ2xhc3NuYW1lLCBpc0dyb3VwUm93Rm9jdXNlZCAmJiBbcm93U2VsZWN0ZWQsIGxhc3RGcm96ZW5Db2x1bW5JbmRleCAhPT0gLTEgJiYgcm93U2VsZWN0ZWRXaXRoRnJvemVuQ2VsbF0sICFpc1Jvd0lkeFdpdGhpblZpZXdwb3J0Qm91bmRzKHNlbGVjdGVkUG9zaXRpb24ucm93SWR4KSAmJiBmb2N1c1NpbmtIZWFkZXJBbmRTdW1tYXJ5Q2xhc3NuYW1lKSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGdyaWRSb3dTdGFydDogc2VsZWN0ZWRQb3NpdGlvbi5yb3dJZHggKyBoZWFkZXJBbmRUb3BTdW1tYXJ5Um93c0NvdW50ICsgMVxuICAgICAgfVxuICAgIH0pLCBzY3JvbGxUb1Bvc2l0aW9uICE9PSBudWxsICYmIC8qI19fUFVSRV9fKi9qc3goU2Nyb2xsVG9DZWxsLCB7XG4gICAgICBzY3JvbGxUb1Bvc2l0aW9uOiBzY3JvbGxUb1Bvc2l0aW9uLFxuICAgICAgc2V0U2Nyb2xsVG9DZWxsUG9zaXRpb246IHNldFNjcm9sbFRvUG9zaXRpb24sXG4gICAgICBncmlkRWxlbWVudDogZ3JpZFJlZi5jdXJyZW50XG4gICAgfSldXG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0Q2VsbFRvU2Nyb2xsKGdyaWRFbCkge1xuICByZXR1cm4gZ3JpZEVsLnF1ZXJ5U2VsZWN0b3IoJzpzY29wZSA+IFtyb2xlPVwicm93XCJdID4gW3RhYmluZGV4PVwiMFwiXScpO1xufVxuZnVuY3Rpb24gaXNTYW1lUG9zaXRpb24ocDEsIHAyKSB7XG4gIHJldHVybiBwMS5pZHggPT09IHAyLmlkeCAmJiBwMS5yb3dJZHggPT09IHAyLnJvd0lkeDtcbn1cbmNvbnN0IERhdGFHcmlkJDEgPSAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZihEYXRhR3JpZCk7XG5cbmZ1bmN0aW9uIEdyb3VwQ2VsbCh7XG4gIGlkLFxuICBncm91cEtleSxcbiAgY2hpbGRSb3dzLFxuICBpc0V4cGFuZGVkLFxuICBpc0NlbGxTZWxlY3RlZCxcbiAgY29sdW1uLFxuICByb3csXG4gIGdyb3VwQ29sdW1uSW5kZXgsXG4gIGlzR3JvdXBCeUNvbHVtbixcbiAgdG9nZ2xlR3JvdXA6IHRvZ2dsZUdyb3VwV3JhcHBlclxufSkge1xuICBjb25zdCB7XG4gICAgdGFiSW5kZXgsXG4gICAgY2hpbGRUYWJJbmRleCxcbiAgICBvbkZvY3VzXG4gIH0gPSB1c2VSb3ZpbmdUYWJJbmRleChpc0NlbGxTZWxlY3RlZCk7XG4gIGZ1bmN0aW9uIHRvZ2dsZUdyb3VwKCkge1xuICAgIHRvZ2dsZUdyb3VwV3JhcHBlcihpZCk7XG4gIH1cbiAgY29uc3QgaXNMZXZlbE1hdGNoaW5nID0gaXNHcm91cEJ5Q29sdW1uICYmIGdyb3VwQ29sdW1uSW5kZXggPT09IGNvbHVtbi5pZHg7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICByb2xlOiBcImdyaWRjZWxsXCIsXG4gICAgXCJhcmlhLWNvbGluZGV4XCI6IGNvbHVtbi5pZHggKyAxLFxuICAgIFwiYXJpYS1zZWxlY3RlZFwiOiBpc0NlbGxTZWxlY3RlZCxcbiAgICB0YWJJbmRleDogdGFiSW5kZXgsXG4gICAgY2xhc3NOYW1lOiBnZXRDZWxsQ2xhc3NuYW1lKGNvbHVtbiksXG4gICAgc3R5bGU6IHtcbiAgICAgIC4uLmdldENlbGxTdHlsZShjb2x1bW4pLFxuICAgICAgY3Vyc29yOiBpc0xldmVsTWF0Y2hpbmcgPyAncG9pbnRlcicgOiAnZGVmYXVsdCdcbiAgICB9LFxuICAgIG9uQ2xpY2s6IGlzTGV2ZWxNYXRjaGluZyA/IHRvZ2dsZUdyb3VwIDogdW5kZWZpbmVkLFxuICAgIG9uRm9jdXM6IG9uRm9jdXMsXG4gICAgY2hpbGRyZW46ICghaXNHcm91cEJ5Q29sdW1uIHx8IGlzTGV2ZWxNYXRjaGluZykgJiYgY29sdW1uLnJlbmRlckdyb3VwQ2VsbD8uKHtcbiAgICAgIGdyb3VwS2V5LFxuICAgICAgY2hpbGRSb3dzLFxuICAgICAgY29sdW1uLFxuICAgICAgcm93LFxuICAgICAgaXNFeHBhbmRlZCxcbiAgICAgIHRhYkluZGV4OiBjaGlsZFRhYkluZGV4LFxuICAgICAgdG9nZ2xlR3JvdXBcbiAgICB9KVxuICB9LCBjb2x1bW4ua2V5KTtcbn1cbmNvbnN0IEdyb3VwQ2VsbCQxID0gLyojX19QVVJFX18qL21lbW8oR3JvdXBDZWxsKTtcblxuY29uc3QgZ3JvdXBSb3cgPSBcImcxeXhsdXYzNy0wLTAtYmV0YS00NlwiO1xuY29uc3QgZ3JvdXBSb3dDbGFzc25hbWUgPSBgcmRnLWdyb3VwLXJvdyAke2dyb3VwUm93fWA7XG5mdW5jdGlvbiBHcm91cGVkUm93KHtcbiAgY2xhc3NOYW1lLFxuICByb3csXG4gIHJvd0lkeCxcbiAgdmlld3BvcnRDb2x1bW5zLFxuICBzZWxlY3RlZENlbGxJZHgsXG4gIGlzUm93U2VsZWN0ZWQsXG4gIHNlbGVjdENlbGwsXG4gIGdyaWRSb3dTdGFydCxcbiAgZ3JvdXBCeSxcbiAgdG9nZ2xlR3JvdXAsXG4gIC4uLnByb3BzXG59KSB7XG4gIGNvbnN0IGlkeCA9IHZpZXdwb3J0Q29sdW1uc1swXS5rZXkgPT09IFNFTEVDVF9DT0xVTU5fS0VZID8gcm93LmxldmVsICsgMSA6IHJvdy5sZXZlbDtcbiAgZnVuY3Rpb24gaGFuZGxlU2VsZWN0R3JvdXAoKSB7XG4gICAgc2VsZWN0Q2VsbCh7XG4gICAgICByb3dJZHgsXG4gICAgICBpZHg6IC0xXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goUm93U2VsZWN0aW9uUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogaXNSb3dTZWxlY3RlZCxcbiAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChcImRpdlwiLCB7XG4gICAgICByb2xlOiBcInJvd1wiLFxuICAgICAgXCJhcmlhLWxldmVsXCI6IHJvdy5sZXZlbCArIDEsXG4gICAgICBcImFyaWEtc2V0c2l6ZVwiOiByb3cuc2V0U2l6ZSxcbiAgICAgIFwiYXJpYS1wb3NpbnNldFwiOiByb3cucG9zSW5TZXQgKyAxLFxuICAgICAgXCJhcmlhLWV4cGFuZGVkXCI6IHJvdy5pc0V4cGFuZGVkLFxuICAgICAgY2xhc3NOYW1lOiBjbHN4KHJvd0NsYXNzbmFtZSwgZ3JvdXBSb3dDbGFzc25hbWUsIGByZGctcm93LSR7cm93SWR4ICUgMiA9PT0gMCA/ICdldmVuJyA6ICdvZGQnfWAsIGNsYXNzTmFtZSwgc2VsZWN0ZWRDZWxsSWR4ID09PSAtMSAmJiByb3dTZWxlY3RlZENsYXNzbmFtZSksXG4gICAgICBvbkNsaWNrOiBoYW5kbGVTZWxlY3RHcm91cCxcbiAgICAgIHN0eWxlOiBnZXRSb3dTdHlsZShncmlkUm93U3RhcnQpLFxuICAgICAgLi4ucHJvcHMsXG4gICAgICBjaGlsZHJlbjogdmlld3BvcnRDb2x1bW5zLm1hcChjb2x1bW4gPT4gLyojX19QVVJFX18qL2pzeChHcm91cENlbGwkMSwge1xuICAgICAgICBpZDogcm93LmlkLFxuICAgICAgICBncm91cEtleTogcm93Lmdyb3VwS2V5LFxuICAgICAgICBjaGlsZFJvd3M6IHJvdy5jaGlsZFJvd3MsXG4gICAgICAgIGlzRXhwYW5kZWQ6IHJvdy5pc0V4cGFuZGVkLFxuICAgICAgICBpc0NlbGxTZWxlY3RlZDogc2VsZWN0ZWRDZWxsSWR4ID09PSBjb2x1bW4uaWR4LFxuICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgcm93OiByb3csXG4gICAgICAgIGdyb3VwQ29sdW1uSW5kZXg6IGlkeCxcbiAgICAgICAgdG9nZ2xlR3JvdXA6IHRvZ2dsZUdyb3VwLFxuICAgICAgICBpc0dyb3VwQnlDb2x1bW46IGdyb3VwQnkuaW5jbHVkZXMoY29sdW1uLmtleSlcbiAgICAgIH0sIGNvbHVtbi5rZXkpKVxuICAgIH0pXG4gIH0pO1xufVxuY29uc3QgR3JvdXBlZFJvdyQxID0gLyojX19QVVJFX18qL21lbW8oR3JvdXBlZFJvdyk7XG5cbmZ1bmN0aW9uIFRyZWVEYXRhR3JpZCh7XG4gIGNvbHVtbnM6IHJhd0NvbHVtbnMsXG4gIHJvd3M6IHJhd1Jvd3MsXG4gIHJvd0hlaWdodDogcmF3Um93SGVpZ2h0LFxuICByb3dLZXlHZXR0ZXI6IHJhd1Jvd0tleUdldHRlcixcbiAgb25DZWxsS2V5RG93bjogcmF3T25DZWxsS2V5RG93bixcbiAgb25Sb3dzQ2hhbmdlLFxuICBzZWxlY3RlZFJvd3M6IHJhd1NlbGVjdGVkUm93cyxcbiAgb25TZWxlY3RlZFJvd3NDaGFuZ2U6IHJhd09uU2VsZWN0ZWRSb3dzQ2hhbmdlLFxuICByZW5kZXJlcnMsXG4gIGdyb3VwQnk6IHJhd0dyb3VwQnksXG4gIHJvd0dyb3VwZXIsXG4gIGV4cGFuZGVkR3JvdXBJZHMsXG4gIG9uRXhwYW5kZWRHcm91cElkc0NoYW5nZSxcbiAgLi4ucHJvcHNcbn0sIHJlZikge1xuICBjb25zdCBkZWZhdWx0UmVuZGVyZXJzID0gdXNlRGVmYXVsdFJlbmRlcmVycygpO1xuICBjb25zdCByYXdSZW5kZXJSb3cgPSByZW5kZXJlcnM/LnJlbmRlclJvdyA/PyBkZWZhdWx0UmVuZGVyZXJzPy5yZW5kZXJSb3cgPz8gZGVmYXVsdFJlbmRlclJvdztcbiAgY29uc3QgaGVhZGVyQW5kVG9wU3VtbWFyeVJvd3NDb3VudCA9IDEgKyAocHJvcHMudG9wU3VtbWFyeVJvd3M/Lmxlbmd0aCA/PyAwKTtcbiAgY29uc3QgaXNSdGwgPSBwcm9wcy5kaXJlY3Rpb24gPT09ICdydGwnO1xuICBjb25zdCBsZWZ0S2V5ID0gaXNSdGwgPyAnQXJyb3dSaWdodCcgOiAnQXJyb3dMZWZ0JztcbiAgY29uc3QgcmlnaHRLZXkgPSBpc1J0bCA/ICdBcnJvd0xlZnQnIDogJ0Fycm93UmlnaHQnO1xuICBjb25zdCB0b2dnbGVHcm91cExhdGVzdCA9IHVzZUxhdGVzdEZ1bmModG9nZ2xlR3JvdXApO1xuICBjb25zdCB7XG4gICAgY29sdW1ucyxcbiAgICBncm91cEJ5XG4gIH0gPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBjb2x1bW5zID0gWy4uLnJhd0NvbHVtbnNdLnNvcnQoKHtcbiAgICAgIGtleTogYUtleVxuICAgIH0sIHtcbiAgICAgIGtleTogYktleVxuICAgIH0pID0+IHtcbiAgICAgIGlmIChhS2V5ID09PSBTRUxFQ1RfQ09MVU1OX0tFWSkgcmV0dXJuIC0xO1xuICAgICAgaWYgKGJLZXkgPT09IFNFTEVDVF9DT0xVTU5fS0VZKSByZXR1cm4gMTtcbiAgICAgIGlmIChyYXdHcm91cEJ5LmluY2x1ZGVzKGFLZXkpKSB7XG4gICAgICAgIGlmIChyYXdHcm91cEJ5LmluY2x1ZGVzKGJLZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIHJhd0dyb3VwQnkuaW5kZXhPZihhS2V5KSAtIHJhd0dyb3VwQnkuaW5kZXhPZihiS2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZiAocmF3R3JvdXBCeS5pbmNsdWRlcyhiS2V5KSkgcmV0dXJuIDE7XG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcbiAgICBjb25zdCBncm91cEJ5ID0gW107XG4gICAgZm9yIChjb25zdCBbaW5kZXgsIGNvbHVtbl0gb2YgY29sdW1ucy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChyYXdHcm91cEJ5LmluY2x1ZGVzKGNvbHVtbi5rZXkpKSB7XG4gICAgICAgIGdyb3VwQnkucHVzaChjb2x1bW4ua2V5KTtcbiAgICAgICAgY29sdW1uc1tpbmRleF0gPSB7XG4gICAgICAgICAgLi4uY29sdW1uLFxuICAgICAgICAgIGZyb3plbjogdHJ1ZSxcbiAgICAgICAgICByZW5kZXJDZWxsOiAoKSA9PiBudWxsLFxuICAgICAgICAgIHJlbmRlckdyb3VwQ2VsbDogY29sdW1uLnJlbmRlckdyb3VwQ2VsbCA/PyByZW5kZXJUb2dnbGVHcm91cCxcbiAgICAgICAgICBlZGl0YWJsZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtbnMsXG4gICAgICBncm91cEJ5XG4gICAgfTtcbiAgfSwgW3Jhd0NvbHVtbnMsIHJhd0dyb3VwQnldKTtcbiAgY29uc3QgW2dyb3VwZWRSb3dzLCByb3dzQ291bnRdID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKGdyb3VwQnkubGVuZ3RoID09PSAwKSByZXR1cm4gW3VuZGVmaW5lZCwgcmF3Um93cy5sZW5ndGhdO1xuICAgIGNvbnN0IGdyb3VwUm93cyA9IChyb3dzLCBbZ3JvdXBCeUtleSwgLi4ucmVtYWluaW5nR3JvdXBCeUtleXNdLCBzdGFydFJvd0luZGV4KSA9PiB7XG4gICAgICBsZXQgZ3JvdXBSb3dzQ291bnQgPSAwO1xuICAgICAgY29uc3QgZ3JvdXBzID0ge307XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIGNoaWxkUm93c10gb2YgT2JqZWN0LmVudHJpZXMocm93R3JvdXBlcihyb3dzLCBncm91cEJ5S2V5KSkpIHtcbiAgICAgICAgY29uc3QgW2NoaWxkR3JvdXBzLCBjaGlsZFJvd3NDb3VudF0gPSByZW1haW5pbmdHcm91cEJ5S2V5cy5sZW5ndGggPT09IDAgPyBbY2hpbGRSb3dzLCBjaGlsZFJvd3MubGVuZ3RoXSA6IGdyb3VwUm93cyhjaGlsZFJvd3MsIHJlbWFpbmluZ0dyb3VwQnlLZXlzLCBzdGFydFJvd0luZGV4ICsgZ3JvdXBSb3dzQ291bnQgKyAxKTtcbiAgICAgICAgZ3JvdXBzW2tleV0gPSB7XG4gICAgICAgICAgY2hpbGRSb3dzLFxuICAgICAgICAgIGNoaWxkR3JvdXBzLFxuICAgICAgICAgIHN0YXJ0Um93SW5kZXg6IHN0YXJ0Um93SW5kZXggKyBncm91cFJvd3NDb3VudFxuICAgICAgICB9O1xuICAgICAgICBncm91cFJvd3NDb3VudCArPSBjaGlsZFJvd3NDb3VudCArIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2dyb3VwcywgZ3JvdXBSb3dzQ291bnRdO1xuICAgIH07XG4gICAgcmV0dXJuIGdyb3VwUm93cyhyYXdSb3dzLCBncm91cEJ5LCAwKTtcbiAgfSwgW2dyb3VwQnksIHJvd0dyb3VwZXIsIHJhd1Jvd3NdKTtcbiAgY29uc3QgW3Jvd3MsIGlzR3JvdXBSb3ddID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgYWxsR3JvdXBSb3dzID0gbmV3IFNldCgpO1xuICAgIGlmICghZ3JvdXBlZFJvd3MpIHJldHVybiBbcmF3Um93cywgaXNHcm91cFJvd107XG4gICAgY29uc3QgZmxhdHRlbmVkUm93cyA9IFtdO1xuICAgIGNvbnN0IGV4cGFuZEdyb3VwID0gKHJvd3MsIHBhcmVudElkLCBsZXZlbCkgPT4ge1xuICAgICAgaWYgKGlzUmVhZG9ubHlBcnJheShyb3dzKSkge1xuICAgICAgICBmbGF0dGVuZWRSb3dzLnB1c2goLi4ucm93cyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5rZXlzKHJvd3MpLmZvckVhY2goKGdyb3VwS2V5LCBwb3NJblNldCwga2V5cykgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IHBhcmVudElkICE9PSB1bmRlZmluZWQgPyBgJHtwYXJlbnRJZH1fXyR7Z3JvdXBLZXl9YCA6IGdyb3VwS2V5O1xuICAgICAgICBjb25zdCBpc0V4cGFuZGVkID0gZXhwYW5kZWRHcm91cElkcy5oYXMoaWQpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY2hpbGRSb3dzLFxuICAgICAgICAgIGNoaWxkR3JvdXBzLFxuICAgICAgICAgIHN0YXJ0Um93SW5kZXhcbiAgICAgICAgfSA9IHJvd3NbZ3JvdXBLZXldO1xuICAgICAgICBjb25zdCBncm91cFJvdyA9IHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwYXJlbnRJZCxcbiAgICAgICAgICBncm91cEtleSxcbiAgICAgICAgICBpc0V4cGFuZGVkLFxuICAgICAgICAgIGNoaWxkUm93cyxcbiAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICBwb3NJblNldCxcbiAgICAgICAgICBzdGFydFJvd0luZGV4LFxuICAgICAgICAgIHNldFNpemU6IGtleXMubGVuZ3RoXG4gICAgICAgIH07XG4gICAgICAgIGZsYXR0ZW5lZFJvd3MucHVzaChncm91cFJvdyk7XG4gICAgICAgIGFsbEdyb3VwUm93cy5hZGQoZ3JvdXBSb3cpO1xuICAgICAgICBpZiAoaXNFeHBhbmRlZCkge1xuICAgICAgICAgIGV4cGFuZEdyb3VwKGNoaWxkR3JvdXBzLCBpZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBleHBhbmRHcm91cChncm91cGVkUm93cywgdW5kZWZpbmVkLCAwKTtcbiAgICByZXR1cm4gW2ZsYXR0ZW5lZFJvd3MsIGlzR3JvdXBSb3ddO1xuICAgIGZ1bmN0aW9uIGlzR3JvdXBSb3cocm93KSB7XG4gICAgICByZXR1cm4gYWxsR3JvdXBSb3dzLmhhcyhyb3cpO1xuICAgIH1cbiAgfSwgW2V4cGFuZGVkR3JvdXBJZHMsIGdyb3VwZWRSb3dzLCByYXdSb3dzXSk7XG4gIGNvbnN0IHJvd0hlaWdodCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgcmF3Um93SGVpZ2h0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcm93ID0+IHtcbiAgICAgICAgaWYgKGlzR3JvdXBSb3cocm93KSkge1xuICAgICAgICAgIHJldHVybiByYXdSb3dIZWlnaHQoe1xuICAgICAgICAgICAgdHlwZTogJ0dST1VQJyxcbiAgICAgICAgICAgIHJvd1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYXdSb3dIZWlnaHQoe1xuICAgICAgICAgIHR5cGU6ICdST1cnLFxuICAgICAgICAgIHJvd1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiByYXdSb3dIZWlnaHQ7XG4gIH0sIFtpc0dyb3VwUm93LCByYXdSb3dIZWlnaHRdKTtcbiAgY29uc3QgZ2V0UGFyZW50Um93QW5kSW5kZXggPSB1c2VDYWxsYmFjayhyb3cgPT4ge1xuICAgIGNvbnN0IHJvd0lkeCA9IHJvd3MuaW5kZXhPZihyb3cpO1xuICAgIGZvciAobGV0IGkgPSByb3dJZHggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgcGFyZW50Um93ID0gcm93c1tpXTtcbiAgICAgIGlmIChpc0dyb3VwUm93KHBhcmVudFJvdykgJiYgKCFpc0dyb3VwUm93KHJvdykgfHwgcm93LnBhcmVudElkID09PSBwYXJlbnRSb3cuaWQpKSB7XG4gICAgICAgIHJldHVybiBbcGFyZW50Um93LCBpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSwgW2lzR3JvdXBSb3csIHJvd3NdKTtcbiAgY29uc3Qgcm93S2V5R2V0dGVyID0gdXNlQ2FsbGJhY2socm93ID0+IHtcbiAgICBpZiAoaXNHcm91cFJvdyhyb3cpKSB7XG4gICAgICByZXR1cm4gcm93LmlkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJhd1Jvd0tleUdldHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHJhd1Jvd0tleUdldHRlcihyb3cpO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRSb3dBbmRJbmRleCA9IGdldFBhcmVudFJvd0FuZEluZGV4KHJvdyk7XG4gICAgaWYgKHBhcmVudFJvd0FuZEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RhcnRSb3dJbmRleCxcbiAgICAgICAgY2hpbGRSb3dzXG4gICAgICB9ID0gcGFyZW50Um93QW5kSW5kZXhbMF07XG4gICAgICBjb25zdCBncm91cEluZGV4ID0gY2hpbGRSb3dzLmluZGV4T2Yocm93KTtcbiAgICAgIHJldHVybiBzdGFydFJvd0luZGV4ICsgZ3JvdXBJbmRleCArIDE7XG4gICAgfVxuICAgIHJldHVybiByb3dzLmluZGV4T2Yocm93KTtcbiAgfSwgW2dldFBhcmVudFJvd0FuZEluZGV4LCBpc0dyb3VwUm93LCByYXdSb3dLZXlHZXR0ZXIsIHJvd3NdKTtcbiAgY29uc3Qgc2VsZWN0ZWRSb3dzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHJhd1NlbGVjdGVkUm93cyA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICBhc3NlcnRJc1ZhbGlkS2V5R2V0dGVyKHJhd1Jvd0tleUdldHRlcik7XG4gICAgY29uc3Qgc2VsZWN0ZWRSb3dzID0gbmV3IFNldChyYXdTZWxlY3RlZFJvd3MpO1xuICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgIGlmIChpc0dyb3VwUm93KHJvdykpIHtcbiAgICAgICAgY29uc3QgaXNHcm91cFJvd1NlbGVjdGVkID0gcm93LmNoaWxkUm93cy5ldmVyeShjciA9PiByYXdTZWxlY3RlZFJvd3MuaGFzKHJhd1Jvd0tleUdldHRlcihjcikpKTtcbiAgICAgICAgaWYgKGlzR3JvdXBSb3dTZWxlY3RlZCkge1xuICAgICAgICAgIHNlbGVjdGVkUm93cy5hZGQocm93LmlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRSb3dzO1xuICB9LCBbaXNHcm91cFJvdywgcmF3Um93S2V5R2V0dGVyLCByYXdTZWxlY3RlZFJvd3MsIHJvd3NdKTtcbiAgZnVuY3Rpb24gb25TZWxlY3RlZFJvd3NDaGFuZ2UobmV3U2VsZWN0ZWRSb3dzKSB7XG4gICAgaWYgKCFyYXdPblNlbGVjdGVkUm93c0NoYW5nZSkgcmV0dXJuO1xuICAgIGFzc2VydElzVmFsaWRLZXlHZXR0ZXIocmF3Um93S2V5R2V0dGVyKTtcbiAgICBjb25zdCBuZXdSYXdTZWxlY3RlZFJvd3MgPSBuZXcgU2V0KHJhd1NlbGVjdGVkUm93cyk7XG4gICAgZm9yIChjb25zdCByb3cgb2Ygcm93cykge1xuICAgICAgY29uc3Qga2V5ID0gcm93S2V5R2V0dGVyKHJvdyk7XG4gICAgICBpZiAoc2VsZWN0ZWRSb3dzPy5oYXMoa2V5KSAmJiAhbmV3U2VsZWN0ZWRSb3dzLmhhcyhrZXkpKSB7XG4gICAgICAgIGlmIChpc0dyb3VwUm93KHJvdykpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGNyIG9mIHJvdy5jaGlsZFJvd3MpIHtcbiAgICAgICAgICAgIG5ld1Jhd1NlbGVjdGVkUm93cy5kZWxldGUocmF3Um93S2V5R2V0dGVyKGNyKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1Jhd1NlbGVjdGVkUm93cy5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc2VsZWN0ZWRSb3dzPy5oYXMoa2V5KSAmJiBuZXdTZWxlY3RlZFJvd3MuaGFzKGtleSkpIHtcbiAgICAgICAgaWYgKGlzR3JvdXBSb3cocm93KSkge1xuICAgICAgICAgIGZvciAoY29uc3QgY3Igb2Ygcm93LmNoaWxkUm93cykge1xuICAgICAgICAgICAgbmV3UmF3U2VsZWN0ZWRSb3dzLmFkZChyYXdSb3dLZXlHZXR0ZXIoY3IpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3UmF3U2VsZWN0ZWRSb3dzLmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJhd09uU2VsZWN0ZWRSb3dzQ2hhbmdlKG5ld1Jhd1NlbGVjdGVkUm93cyk7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihhcmdzLCBldmVudCkge1xuICAgIHJhd09uQ2VsbEtleURvd24/LihhcmdzLCBldmVudCk7XG4gICAgaWYgKGV2ZW50LmlzR3JpZERlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuO1xuICAgIGlmIChhcmdzLm1vZGUgPT09ICdFRElUJykgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbHVtbixcbiAgICAgIHJvd0lkeCxcbiAgICAgIHNlbGVjdENlbGxcbiAgICB9ID0gYXJncztcbiAgICBjb25zdCBpZHggPSBjb2x1bW4/LmlkeCA/PyAtMTtcbiAgICBjb25zdCByb3cgPSByb3dzW3Jvd0lkeF07XG4gICAgaWYgKCFpc0dyb3VwUm93KHJvdykpIHJldHVybjtcbiAgICBpZiAoaWR4ID09PSAtMSAmJiAoZXZlbnQua2V5ID09PSBsZWZ0S2V5ICYmIHJvdy5pc0V4cGFuZGVkIHx8IGV2ZW50LmtleSA9PT0gcmlnaHRLZXkgJiYgIXJvdy5pc0V4cGFuZGVkKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnByZXZlbnRHcmlkRGVmYXVsdCgpO1xuICAgICAgdG9nZ2xlR3JvdXAocm93LmlkKTtcbiAgICB9XG4gICAgaWYgKGlkeCA9PT0gLTEgJiYgZXZlbnQua2V5ID09PSBsZWZ0S2V5ICYmICFyb3cuaXNFeHBhbmRlZCAmJiByb3cubGV2ZWwgIT09IDApIHtcbiAgICAgIGNvbnN0IHBhcmVudFJvd0FuZEluZGV4ID0gZ2V0UGFyZW50Um93QW5kSW5kZXgocm93KTtcbiAgICAgIGlmIChwYXJlbnRSb3dBbmRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnRHcmlkRGVmYXVsdCgpO1xuICAgICAgICBzZWxlY3RDZWxsKHtcbiAgICAgICAgICBpZHgsXG4gICAgICAgICAgcm93SWR4OiBwYXJlbnRSb3dBbmRJbmRleFsxXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQ3RybEtleUhlbGREb3duKGV2ZW50KSAmJiAoZXZlbnQua2V5Q29kZSA9PT0gNjcgfHwgZXZlbnQua2V5Q29kZSA9PT0gODYpKSB7XG4gICAgICBldmVudC5wcmV2ZW50R3JpZERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlUm93c0NoYW5nZSh1cGRhdGVkUm93cywge1xuICAgIGluZGV4ZXMsXG4gICAgY29sdW1uXG4gIH0pIHtcbiAgICBpZiAoIW9uUm93c0NoYW5nZSkgcmV0dXJuO1xuICAgIGNvbnN0IHVwZGF0ZWRSYXdSb3dzID0gWy4uLnJhd1Jvd3NdO1xuICAgIGNvbnN0IHJhd0luZGV4ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4ZXMpIHtcbiAgICAgIGNvbnN0IHJhd0luZGV4ID0gcmF3Um93cy5pbmRleE9mKHJvd3NbaW5kZXhdKTtcbiAgICAgIHVwZGF0ZWRSYXdSb3dzW3Jhd0luZGV4XSA9IHVwZGF0ZWRSb3dzW2luZGV4XTtcbiAgICAgIHJhd0luZGV4ZXMucHVzaChyYXdJbmRleCk7XG4gICAgfVxuICAgIG9uUm93c0NoYW5nZSh1cGRhdGVkUmF3Um93cywge1xuICAgICAgaW5kZXhlczogcmF3SW5kZXhlcyxcbiAgICAgIGNvbHVtblxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHRvZ2dsZUdyb3VwKGdyb3VwSWQpIHtcbiAgICBjb25zdCBuZXdFeHBhbmRlZEdyb3VwSWRzID0gbmV3IFNldChleHBhbmRlZEdyb3VwSWRzKTtcbiAgICBpZiAobmV3RXhwYW5kZWRHcm91cElkcy5oYXMoZ3JvdXBJZCkpIHtcbiAgICAgIG5ld0V4cGFuZGVkR3JvdXBJZHMuZGVsZXRlKGdyb3VwSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdFeHBhbmRlZEdyb3VwSWRzLmFkZChncm91cElkKTtcbiAgICB9XG4gICAgb25FeHBhbmRlZEdyb3VwSWRzQ2hhbmdlKG5ld0V4cGFuZGVkR3JvdXBJZHMpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlclJvdyhrZXksIHtcbiAgICByb3csXG4gICAgcm93Q2xhc3MsXG4gICAgb25DZWxsQ2xpY2ssXG4gICAgb25DZWxsRG91YmxlQ2xpY2ssXG4gICAgb25DZWxsQ29udGV4dE1lbnUsXG4gICAgb25Sb3dDaGFuZ2UsXG4gICAgbGFzdEZyb3plbkNvbHVtbkluZGV4LFxuICAgIGNvcGllZENlbGxJZHgsXG4gICAgZHJhZ2dlZE92ZXJDZWxsSWR4LFxuICAgIHNldERyYWdnZWRPdmVyUm93SWR4LFxuICAgIHNlbGVjdGVkQ2VsbEVkaXRvcixcbiAgICAuLi5yb3dQcm9wc1xuICB9KSB7XG4gICAgaWYgKGlzR3JvdXBSb3cocm93KSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdGFydFJvd0luZGV4XG4gICAgICB9ID0gcm93O1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goR3JvdXBlZFJvdyQxLCB7XG4gICAgICAgIC4uLnJvd1Byb3BzLFxuICAgICAgICBcImFyaWEtcm93aW5kZXhcIjogaGVhZGVyQW5kVG9wU3VtbWFyeVJvd3NDb3VudCArIHN0YXJ0Um93SW5kZXggKyAxLFxuICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgZ3JvdXBCeTogZ3JvdXBCeSxcbiAgICAgICAgdG9nZ2xlR3JvdXA6IHRvZ2dsZUdyb3VwTGF0ZXN0XG4gICAgICB9LCBrZXkpO1xuICAgIH1cbiAgICBsZXQgYXJpYVJvd0luZGV4ID0gcm93UHJvcHNbJ2FyaWEtcm93aW5kZXgnXTtcbiAgICBjb25zdCBwYXJlbnRSb3dBbmRJbmRleCA9IGdldFBhcmVudFJvd0FuZEluZGV4KHJvdyk7XG4gICAgaWYgKHBhcmVudFJvd0FuZEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RhcnRSb3dJbmRleCxcbiAgICAgICAgY2hpbGRSb3dzXG4gICAgICB9ID0gcGFyZW50Um93QW5kSW5kZXhbMF07XG4gICAgICBjb25zdCBncm91cEluZGV4ID0gY2hpbGRSb3dzLmluZGV4T2Yocm93KTtcbiAgICAgIGFyaWFSb3dJbmRleCA9IHN0YXJ0Um93SW5kZXggKyBoZWFkZXJBbmRUb3BTdW1tYXJ5Um93c0NvdW50ICsgZ3JvdXBJbmRleCArIDI7XG4gICAgfVxuICAgIHJldHVybiByYXdSZW5kZXJSb3coa2V5LCB7XG4gICAgICAuLi5yb3dQcm9wcyxcbiAgICAgICdhcmlhLXJvd2luZGV4JzogYXJpYVJvd0luZGV4LFxuICAgICAgcm93LFxuICAgICAgcm93Q2xhc3MsXG4gICAgICBvbkNlbGxDbGljayxcbiAgICAgIG9uQ2VsbERvdWJsZUNsaWNrLFxuICAgICAgb25DZWxsQ29udGV4dE1lbnUsXG4gICAgICBvblJvd0NoYW5nZSxcbiAgICAgIGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgICAgIGNvcGllZENlbGxJZHgsXG4gICAgICBkcmFnZ2VkT3ZlckNlbGxJZHgsXG4gICAgICBzZXREcmFnZ2VkT3ZlclJvd0lkeCxcbiAgICAgIHNlbGVjdGVkQ2VsbEVkaXRvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KERhdGFHcmlkJDEsIHtcbiAgICAuLi5wcm9wcyxcbiAgICByb2xlOiBcInRyZWVncmlkXCIsXG4gICAgXCJhcmlhLXJvd2NvdW50XCI6IHJvd3NDb3VudCArIDEgKyAocHJvcHMudG9wU3VtbWFyeVJvd3M/Lmxlbmd0aCA/PyAwKSArIChwcm9wcy5ib3R0b21TdW1tYXJ5Um93cz8ubGVuZ3RoID8/IDApLFxuICAgIHJlZjogcmVmLFxuICAgIGNvbHVtbnM6IGNvbHVtbnMsXG4gICAgcm93czogcm93cyxcbiAgICByb3dIZWlnaHQ6IHJvd0hlaWdodCxcbiAgICByb3dLZXlHZXR0ZXI6IHJvd0tleUdldHRlcixcbiAgICBvblJvd3NDaGFuZ2U6IGhhbmRsZVJvd3NDaGFuZ2UsXG4gICAgc2VsZWN0ZWRSb3dzOiBzZWxlY3RlZFJvd3MsXG4gICAgb25TZWxlY3RlZFJvd3NDaGFuZ2U6IG9uU2VsZWN0ZWRSb3dzQ2hhbmdlLFxuICAgIG9uQ2VsbEtleURvd246IGhhbmRsZUtleURvd24sXG4gICAgcmVuZGVyZXJzOiB7XG4gICAgICAuLi5yZW5kZXJlcnMsXG4gICAgICByZW5kZXJSb3dcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNSZWFkb25seUFycmF5KGFycikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpO1xufVxuY29uc3QgVHJlZURhdGFHcmlkJDEgPSAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZihUcmVlRGF0YUdyaWQpO1xuXG5jb25zdCB0ZXh0RWRpdG9ySW50ZXJuYWxDbGFzc25hbWUgPSBcInQ3dnl4M2k3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCB0ZXh0RWRpdG9yQ2xhc3NuYW1lID0gYHJkZy10ZXh0LWVkaXRvciAke3RleHRFZGl0b3JJbnRlcm5hbENsYXNzbmFtZX1gO1xuZnVuY3Rpb24gYXV0b0ZvY3VzQW5kU2VsZWN0KGlucHV0KSB7XG4gIGlucHV0Py5mb2N1cygpO1xuICBpbnB1dD8uc2VsZWN0KCk7XG59XG5mdW5jdGlvbiB0ZXh0RWRpdG9yKHtcbiAgcm93LFxuICBjb2x1bW4sXG4gIG9uUm93Q2hhbmdlLFxuICBvbkNsb3NlXG59KSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiaW5wdXRcIiwge1xuICAgIGNsYXNzTmFtZTogdGV4dEVkaXRvckNsYXNzbmFtZSxcbiAgICByZWY6IGF1dG9Gb2N1c0FuZFNlbGVjdCxcbiAgICB2YWx1ZTogcm93W2NvbHVtbi5rZXldLFxuICAgIG9uQ2hhbmdlOiBldmVudCA9PiBvblJvd0NoYW5nZSh7XG4gICAgICAuLi5yb3csXG4gICAgICBbY29sdW1uLmtleV06IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgIH0pLFxuICAgIG9uQmx1cjogKCkgPT4gb25DbG9zZSh0cnVlLCBmYWxzZSlcbiAgfSk7XG59XG5cbmV4cG9ydCB7IERhdGFHcmlkRGVmYXVsdFJlbmRlcmVyc1Byb3ZpZGVyLCBSb3dDb21wb25lbnQkMSBhcyBSb3csIFNFTEVDVF9DT0xVTU5fS0VZLCBTZWxlY3RDZWxsRm9ybWF0dGVyLCBTZWxlY3RDb2x1bW4sIFRvZ2dsZUdyb3VwLCBUcmVlRGF0YUdyaWQkMSBhcyBUcmVlRGF0YUdyaWQsIERhdGFHcmlkJDEgYXMgZGVmYXVsdCwgcmVuZGVyQ2hlY2tib3gsIHJlbmRlckhlYWRlckNlbGwsIHJlbmRlclNvcnRJY29uLCByZW5kZXJTb3J0UHJpb3JpdHksIHJlbmRlclRvZ2dsZUdyb3VwLCByZW5kZXJWYWx1ZSwgdGV4dEVkaXRvciwgdXNlUm93U2VsZWN0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idW5kbGUuanMubWFwXG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VNZW1vIiwidXNlRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0JDEiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwibWVtbyIsInVzZUlkIiwiZm9yd2FyZFJlZiIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJmbHVzaFN5bmMiLCJjbHN4IiwianN4IiwianN4cyIsIkZyYWdtZW50IiwiZ2V0Q29sU3BhbiIsImNvbHVtbiIsImxhc3RGcm96ZW5Db2x1bW5JbmRleCIsImFyZ3MiLCJjb2xTcGFuIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiZnJvemVuIiwiaWR4IiwidW5kZWZpbmVkIiwic3RvcFByb3BhZ2F0aW9uIiwiZXZlbnQiLCJzY3JvbGxJbnRvVmlldyIsImVsZW1lbnQiLCJpbmxpbmUiLCJibG9jayIsImNyZWF0ZUNlbGxFdmVudCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJjZWxsRXZlbnQiLCJwcmV2ZW50R3JpZERlZmF1bHQiLCJpc0dyaWREZWZhdWx0UHJldmVudGVkIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIm5vbklucHV0S2V5cyIsIlNldCIsImlzQ3RybEtleUhlbGREb3duIiwiZSIsImN0cmxLZXkiLCJtZXRhS2V5Iiwia2V5IiwiaXNEZWZhdWx0Q2VsbElucHV0IiwidktleSIsImtleUNvZGUiLCJoYXMiLCJvbkVkaXRvck5hdmlnYXRpb24iLCJ0YXJnZXQiLCJIVE1MSW5wdXRFbGVtZW50IiwiSFRNTFRleHRBcmVhRWxlbWVudCIsIkhUTUxTZWxlY3RFbGVtZW50IiwiY2xvc2VzdCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJsZW5ndGgiLCJtZWFzdXJpbmdDZWxsQ2xhc3NuYW1lIiwicmVuZGVyTWVhc3VyaW5nQ2VsbHMiLCJ2aWV3cG9ydENvbHVtbnMiLCJtYXAiLCJtaW5XaWR0aCIsIm1heFdpZHRoIiwiY2xhc3NOYW1lIiwic3R5bGUiLCJncmlkQ29sdW1uU3RhcnQiLCJpc1NlbGVjdGVkQ2VsbEVkaXRhYmxlIiwic2VsZWN0ZWRQb3NpdGlvbiIsImNvbHVtbnMiLCJyb3dzIiwicm93Iiwicm93SWR4IiwiaXNDZWxsRWRpdGFibGVVdGlsIiwicmVuZGVyRWRpdENlbGwiLCJlZGl0YWJsZSIsImdldFNlbGVjdGVkQ2VsbENvbFNwYW4iLCJ0b3BTdW1tYXJ5Um93cyIsImJvdHRvbVN1bW1hcnlSb3dzIiwibWFpbkhlYWRlclJvd0lkeCIsInRvcFN1bW1hcnlSb3dzQ291bnQiLCJ0eXBlIiwiZ2V0TmV4dFNlbGVjdGVkQ2VsbFBvc2l0aW9uIiwibW92ZVVwIiwibW92ZU5leHQiLCJjZWxsTmF2aWdhdGlvbk1vZGUiLCJjb2xTcGFuQ29sdW1ucyIsIm1pblJvd0lkeCIsIm1heFJvd0lkeCIsImN1cnJlbnRQb3NpdGlvbiIsImN1cnJlbnRJZHgiLCJjdXJyZW50Um93SWR4IiwibmV4dFBvc2l0aW9uIiwiaXNDZWxsV2l0aGluQm91bmRzIiwibmV4dElkeCIsIm5leHRSb3dJZHgiLCJjb2x1bW5zQ291bnQiLCJzZXRDb2xTcGFuIiwiY29sSWR4IiwiZ2V0UGFyZW50Um93SWR4IiwicGFyZW50IiwibGV2ZWwiLCJzZXRIZWFkZXJHcm91cENvbEFuZFJvd1NwYW4iLCJuZXh0Q29sdW1uIiwicGFyZW50Um93SWR4IiwiZm91bmQiLCJpc0FmdGVyTGFzdENvbHVtbiIsImlzQmVmb3JlRmlyc3RDb2x1bW4iLCJpc0xhc3RSb3ciLCJpc0ZpcnN0Um93IiwibmV4dFBhcmVudFJvd0lkeCIsImNhbkV4aXRHcmlkIiwibWF4Q29sSWR4Iiwic2hpZnRLZXkiLCJhdExhc3RDZWxsSW5Sb3ciLCJhdEZpcnN0Q2VsbEluUm93IiwiYXRMYXN0Um93IiwiYXRGaXJzdFJvdyIsImNlbGwiLCJjZWxsQ2xhc3NuYW1lIiwiY2VsbEZyb3plbiIsImNlbGxGcm96ZW5DbGFzc25hbWUiLCJnZXRSb3dTdHlsZSIsImdldEhlYWRlckNlbGxTdHlsZSIsInJvd1NwYW4iLCJncmlkUm93RW5kIiwicGFkZGluZ0Jsb2NrU3RhcnQiLCJpbnNldEJsb2NrU3RhcnQiLCJncmlkUm93U3RhcnQiLCJnZXRDZWxsU3R5bGUiLCJpbmRleCIsImdyaWRDb2x1bW5FbmQiLCJpbnNldElubGluZVN0YXJ0IiwiZ2V0Q2VsbENsYXNzbmFtZSIsImV4dHJhQ2xhc3NlcyIsIm1pbiIsIm1heCIsImZsb29yIiwic2lnbiIsImFicyIsIk1hdGgiLCJhc3NlcnRJc1ZhbGlkS2V5R2V0dGVyIiwia2V5R2V0dGVyIiwiRXJyb3IiLCJjbGFtcENvbHVtbldpZHRoIiwid2lkdGgiLCJnZXRIZWFkZXJDZWxsUm93U3BhbiIsImNoZWNrYm94Q29udGFpbmVyIiwiY2hlY2tib3giLCJjaGVja2JveENsYXNzbmFtZSIsInJlbmRlckNoZWNrYm94Iiwib25DaGFuZ2UiLCJwcm9wcyIsImhhbmRsZUNoYW5nZSIsImNoZWNrZWQiLCJuYXRpdmVFdmVudCIsImNoaWxkcmVuIiwiZ3JvdXBDZWxsQ29udGVudCIsImdyb3VwQ2VsbENvbnRlbnRDbGFzc25hbWUiLCJjYXJldCIsImNhcmV0Q2xhc3NuYW1lIiwicmVuZGVyVG9nZ2xlR3JvdXAiLCJUb2dnbGVHcm91cCIsImdyb3VwS2V5IiwiaXNFeHBhbmRlZCIsInRhYkluZGV4IiwidG9nZ2xlR3JvdXAiLCJoYW5kbGVLZXlEb3duIiwiZCIsIm9uS2V5RG93biIsInZpZXdCb3giLCJoZWlnaHQiLCJyZW5kZXJWYWx1ZSIsIkRhdGFHcmlkRGVmYXVsdFJlbmRlcmVyc0NvbnRleHQiLCJEYXRhR3JpZERlZmF1bHRSZW5kZXJlcnNQcm92aWRlciIsIlByb3ZpZGVyIiwidXNlRGVmYXVsdFJlbmRlcmVycyIsIlNlbGVjdENlbGxGb3JtYXR0ZXIiLCJ2YWx1ZSIsImRpc2FibGVkIiwiYXJpYUxhYmVsIiwiYXJpYUxhYmVsbGVkQnkiLCJSb3dTZWxlY3Rpb25Db250ZXh0IiwiUm93U2VsZWN0aW9uUHJvdmlkZXIiLCJSb3dTZWxlY3Rpb25DaGFuZ2VDb250ZXh0IiwiUm93U2VsZWN0aW9uQ2hhbmdlUHJvdmlkZXIiLCJ1c2VSb3dTZWxlY3Rpb24iLCJyb3dTZWxlY3Rpb25Db250ZXh0Iiwicm93U2VsZWN0aW9uQ2hhbmdlQ29udGV4dCIsIlNFTEVDVF9DT0xVTU5fS0VZIiwiSGVhZGVyUmVuZGVyZXIiLCJpc1Jvd1NlbGVjdGVkIiwib25Sb3dTZWxlY3Rpb25DaGFuZ2UiLCJTZWxlY3RGb3JtYXR0ZXIiLCJpc1NoaWZ0Q2xpY2siLCJTZWxlY3RHcm91cEZvcm1hdHRlciIsIlNlbGVjdENvbHVtbiIsIm5hbWUiLCJyZXNpemFibGUiLCJzb3J0YWJsZSIsInJlbmRlckhlYWRlckNlbGwiLCJyZW5kZXJDZWxsIiwicmVuZGVyR3JvdXBDZWxsIiwiREVGQVVMVF9DT0xVTU5fV0lEVEgiLCJERUZBVUxUX0NPTFVNTl9NSU5fV0lEVEgiLCJ1c2VDYWxjdWxhdGVkQ29sdW1ucyIsInJhd0NvbHVtbnMiLCJkZWZhdWx0Q29sdW1uT3B0aW9ucyIsImdldENvbHVtbldpZHRoIiwidmlld3BvcnRXaWR0aCIsInNjcm9sbExlZnQiLCJlbmFibGVWaXJ0dWFsaXphdGlvbiIsImRlZmF1bHRXaWR0aCIsImRlZmF1bHRNaW5XaWR0aCIsImRlZmF1bHRNYXhXaWR0aCIsImRlZmF1bHRDZWxsUmVuZGVyZXIiLCJkZWZhdWx0U29ydGFibGUiLCJkZWZhdWx0UmVzaXphYmxlIiwiZGVmYXVsdERyYWdnYWJsZSIsImRyYWdnYWJsZSIsImhlYWRlclJvd3NDb3VudCIsImNvbGxlY3RDb2x1bW5zIiwicmF3Q29sdW1uIiwiY2FsY3VsYXRlZENvbHVtblBhcmVudCIsImhlYWRlckNlbGxDbGFzcyIsInB1c2giLCJzb3J0IiwiYUtleSIsImZyb3plbkEiLCJiS2V5IiwiZnJvemVuQiIsImZvckVhY2giLCJ1cGRhdGVDb2x1bW5QYXJlbnQiLCJ0ZW1wbGF0ZUNvbHVtbnMiLCJsYXlvdXRDc3NWYXJzIiwidG90YWxGcm96ZW5Db2x1bW5XaWR0aCIsImNvbHVtbk1ldHJpY3MiLCJNYXAiLCJsZWZ0Iiwic2V0IiwiY29sdW1uTWV0cmljIiwiZ2V0IiwiaSIsImNvbE92ZXJzY2FuU3RhcnRJZHgiLCJjb2xPdmVyc2NhbkVuZElkeCIsInZpZXdwb3J0TGVmdCIsInZpZXdwb3J0UmlnaHQiLCJsYXN0Q29sSWR4IiwiZmlyc3RVbmZyb3plbkNvbHVtbklkeCIsImNvbFZpc2libGVTdGFydElkeCIsImNvbFZpc2libGVFbmRJZHgiLCJ1c2VDb2x1bW5XaWR0aHMiLCJncmlkUmVmIiwiZ3JpZFdpZHRoIiwicmVzaXplZENvbHVtbldpZHRocyIsIm1lYXN1cmVkQ29sdW1uV2lkdGhzIiwic2V0UmVzaXplZENvbHVtbldpZHRocyIsInNldE1lYXN1cmVkQ29sdW1uV2lkdGhzIiwib25Db2x1bW5SZXNpemUiLCJwcmV2R3JpZFdpZHRoUmVmIiwiY29sdW1uc0NhbkZsZXgiLCJpZ25vcmVQcmV2aW91c2x5TWVhc3VyZWRDb2x1bW5zIiwiY3VycmVudCIsIm5ld1RlbXBsYXRlQ29sdW1ucyIsImNvbHVtbnNUb01lYXN1cmUiLCJncmlkVGVtcGxhdGVDb2x1bW5zIiwiam9pbiIsInVwZGF0ZU1lYXN1cmVkV2lkdGhzIiwibmV3TWVhc3VyZWRDb2x1bW5XaWR0aHMiLCJoYXNDaGFuZ2VzIiwibWVhc3VyZWRXaWR0aCIsIm1lYXN1cmVDb2x1bW5XaWR0aCIsImRlbGV0ZSIsImhhbmRsZUNvbHVtblJlc2l6ZSIsIm5leHRXaWR0aCIsInJlc2l6aW5nS2V5IiwibmV3UmVzaXplZENvbHVtbldpZHRocyIsInNlbGVjdG9yIiwiQ1NTIiwiZXNjYXBlIiwibWVhc3VyaW5nQ2VsbCIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ1c2VHcmlkRGltZW5zaW9ucyIsImlubGluZVNpemUiLCJzZXRJbmxpbmVTaXplIiwiYmxvY2tTaXplIiwic2V0QmxvY2tTaXplIiwiaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCIsInNldEhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQiLCJSZXNpemVPYnNlcnZlciIsIndpbmRvdyIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJpbml0aWFsSG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCIsImluaXRpYWxXaWR0aCIsImluaXRpYWxIZWlnaHQiLCJyZXNpemVPYnNlcnZlciIsImVudHJpZXMiLCJzaXplIiwiY29udGVudEJveFNpemUiLCJvYnNlcnZlIiwiZGlzY29ubmVjdCIsInVzZUxhdGVzdEZ1bmMiLCJmbiIsInJlZiIsImNhbGxiYWNrRm4iLCJ1c2VSb3ZpbmdUYWJJbmRleCIsImlzU2VsZWN0ZWQiLCJpc0NoaWxkRm9jdXNlZCIsInNldElzQ2hpbGRGb2N1c2VkIiwib25Gb2N1cyIsImN1cnJlbnRUYXJnZXQiLCJpc0ZvY3VzYWJsZSIsImNoaWxkVGFiSW5kZXgiLCJ1c2VWaWV3cG9ydENvbHVtbnMiLCJyb3dPdmVyc2NhblN0YXJ0SWR4Iiwicm93T3ZlcnNjYW5FbmRJZHgiLCJzdGFydElkeCIsInVwZGF0ZVN0YXJ0SWR4IiwidXNlVmlld3BvcnRSb3dzIiwicm93SGVpZ2h0Iiwic2Nyb2xsVG9wIiwidG90YWxSb3dIZWlnaHQiLCJncmlkVGVtcGxhdGVSb3dzIiwiZ2V0Um93VG9wIiwiZ2V0Um93SGVpZ2h0IiwiZmluZFJvd0lkeCIsIm9mZnNldCIsInJvd1Bvc2l0aW9ucyIsImN1cnJlbnRSb3dIZWlnaHQiLCJwb3NpdGlvbiIsInRvcCIsInZhbGlkYXRlUm93SWR4Iiwic3RhcnQiLCJlbmQiLCJtaWRkbGUiLCJjdXJyZW50T2Zmc2V0Iiwib3ZlcnNjYW5UaHJlc2hvbGQiLCJyb3dWaXNpYmxlU3RhcnRJZHgiLCJyb3dWaXNpYmxlRW5kSWR4IiwiY2VsbERyYWdIYW5kbGUiLCJjZWxsRHJhZ0hhbmRsZUZyb3plbkNsYXNzbmFtZSIsImNlbGxEcmFnSGFuZGxlQ2xhc3NuYW1lIiwiRHJhZ0hhbmRsZSIsImNvbHVtbldpZHRoIiwibGF0ZXN0RHJhZ2dlZE92ZXJSb3dJZHgiLCJpc0NlbGxFZGl0YWJsZSIsIm9uUm93c0NoYW5nZSIsIm9uRmlsbCIsIm9uQ2xpY2siLCJzZXREcmFnZ2luZyIsInNldERyYWdnZWRPdmVyUm93SWR4IiwiaGFuZGxlTW91c2VEb3duIiwicHJldmVudERlZmF1bHQiLCJidXR0b25zIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uTW91c2VPdmVyIiwib25Nb3VzZVVwIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhbmRsZURyYWdFbmQiLCJvdmVyUm93SWR4Iiwic3RhcnRSb3dJbmRleCIsImVuZFJvd0luZGV4IiwidXBkYXRlUm93cyIsImhhbmRsZURvdWJsZUNsaWNrIiwic3RhcnRSb3dJZHgiLCJlbmRSb3dJZHgiLCJzb3VyY2VSb3ciLCJ1cGRhdGVkUm93cyIsImluZGV4ZXMiLCJ1cGRhdGVkUm93IiwiY29sdW1uS2V5IiwidGFyZ2V0Um93IiwiZ2V0U3R5bGUiLCJtYXJnaW5FbmQiLCJpc0xhc3RDb2x1bW4iLCJtYXJnaW5JbmxpbmVFbmQiLCJtYXJnaW5CbG9ja0VuZCIsIm9uTW91c2VEb3duIiwib25Eb3VibGVDbGljayIsImNlbGxFZGl0aW5nIiwiRWRpdENlbGwiLCJvblJvd0NoYW5nZSIsImNsb3NlRWRpdG9yIiwibmF2aWdhdGUiLCJmcmFtZVJlcXVlc3RSZWYiLCJjb21taXRPbk91dHNpZGVDbGljayIsImVkaXRvck9wdGlvbnMiLCJjb21taXRPbk91dHNpZGVNb3VzZURvd24iLCJvbkNsb3NlIiwib25XaW5kb3dDYXB0dXJlTW91c2VEb3duIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FwdHVyZSIsImNhbmNlbEZyYW1lUmVxdWVzdCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwibW9kZSIsImNvbW1pdENoYW5nZXMiLCJzaG91bGRGb2N1c0NlbGwiLCJvbkVkaXRvclJvd0NoYW5nZSIsImNvbW1pdENoYW5nZXNBbmRGb2N1cyIsImNlbGxDbGFzcyIsImRpc3BsYXlDZWxsQ29udGVudCIsInJvbGUiLCJvbk1vdXNlRG93bkNhcHR1cmUiLCJHcm91cGVkQ29sdW1uSGVhZGVyQ2VsbCIsImlzQ2VsbFNlbGVjdGVkIiwic2VsZWN0Q2VsbCIsImhlYWRlclNvcnRDZWxsQ2xhc3NuYW1lIiwiaGVhZGVyU29ydE5hbWUiLCJoZWFkZXJTb3J0TmFtZUNsYXNzbmFtZSIsInNvcnREaXJlY3Rpb24iLCJwcmlvcml0eSIsIlNvcnRhYmxlSGVhZGVyQ2VsbCIsInJlbmRlclNvcnRTdGF0dXMiLCJjZWxsU29ydGFibGVDbGFzc25hbWUiLCJjZWxsUmVzaXphYmxlIiwiY2VsbFJlc2l6YWJsZUNsYXNzbmFtZSIsInJlc2l6ZUhhbmRsZUNsYXNzbmFtZSIsImNlbGxEcmFnZ2FibGVDbGFzc25hbWUiLCJjZWxsRHJhZ2dpbmciLCJjZWxsRHJhZ2dpbmdDbGFzc25hbWUiLCJjZWxsT3ZlciIsImNlbGxPdmVyQ2xhc3NuYW1lIiwiSGVhZGVyQ2VsbCIsIm9uQ29sdW1uc1Jlb3JkZXIiLCJzb3J0Q29sdW1ucyIsIm9uU29ydENvbHVtbnNDaGFuZ2UiLCJzaG91bGRGb2N1c0dyaWQiLCJkaXJlY3Rpb24iLCJkcmFnRHJvcEtleSIsImlzRHJhZ2dpbmciLCJzZXRJc0RyYWdnaW5nIiwiaXNPdmVyIiwic2V0SXNPdmVyIiwiaXNSdGwiLCJzb3J0SW5kZXgiLCJmaW5kSW5kZXgiLCJzb3J0Q29sdW1uIiwiYXJpYVNvcnQiLCJyZW5kZXJIZWFkZXJDZWxsJDEiLCJvblBvaW50ZXJEb3duIiwicG9pbnRlclR5cGUiLCJwb2ludGVySWQiLCJoZWFkZXJDZWxsIiwicGFyZW50RWxlbWVudCIsInJpZ2h0IiwiY2xpZW50WCIsIm9uUG9pbnRlck1vdmUiLCJvbkxvc3RQb2ludGVyQ2FwdHVyZSIsInNldFBvaW50ZXJDYXB0dXJlIiwib25Tb3J0IiwiY3RybENsaWNrIiwic29ydERlc2NlbmRpbmdGaXJzdCIsIm5leHRTb3J0IiwibmV4dFNvcnRDb2x1bW4iLCJuZXh0U29ydENvbHVtbnMiLCJzcGxpY2UiLCJoYW5kbGVGb2N1cyIsIm9uRHJhZ1N0YXJ0IiwiZGF0YVRyYW5zZmVyIiwic2V0RGF0YSIsImRyb3BFZmZlY3QiLCJvbkRyYWdFbmQiLCJvbkRyYWdPdmVyIiwib25Ecm9wIiwidHlwZXMiLCJpbmNsdWRlcyIsInNvdXJjZUtleSIsImdldERhdGEiLCJvbkRyYWdFbnRlciIsImlzRXZlbnRQZXJ0aW5lbnQiLCJvbkRyYWdMZWF2ZSIsImRyYWdnYWJsZVByb3BzIiwicmVsYXRlZFRhcmdldCIsImNvbnRhaW5zIiwicm93Q2xhc3NuYW1lIiwicm93U2VsZWN0ZWQiLCJyb3dTZWxlY3RlZENsYXNzbmFtZSIsInJvd1NlbGVjdGVkV2l0aEZyb3plbkNlbGwiLCJ0b3BTdW1tYXJ5Um93Q2xhc3NuYW1lIiwiYm90dG9tU3VtbWFyeVJvd0NsYXNzbmFtZSIsImhlYWRlclJvdyIsImhlYWRlclJvd0NsYXNzbmFtZSIsIkhlYWRlclJvdyIsInNlbGVjdGVkQ2VsbElkeCIsImNlbGxzIiwiSGVhZGVyUm93JDEiLCJHcm91cGVkQ29sdW1uSGVhZGVyUm93IiwicmVuZGVyZWRQYXJlbnRzIiwiYWRkIiwiR3JvdXBlZENvbHVtbkhlYWRlclJvdyQxIiwiY2VsbENvcGllZCIsImNlbGxDb3BpZWRDbGFzc25hbWUiLCJjZWxsRHJhZ2dlZE92ZXIiLCJjZWxsRHJhZ2dlZE92ZXJDbGFzc25hbWUiLCJDZWxsIiwiaXNDb3BpZWQiLCJpc0RyYWdnZWRPdmVyIiwib25Db250ZXh0TWVudSIsImlzRWRpdGFibGUiLCJzZWxlY3RDZWxsV3JhcHBlciIsIm9wZW5FZGl0b3IiLCJoYW5kbGVDbGljayIsImhhbmRsZUNvbnRleHRNZW51IiwiaGFuZGxlUm93Q2hhbmdlIiwibmV3Um93IiwiQ2VsbCQxIiwiUm93IiwiY29waWVkQ2VsbElkeCIsImRyYWdnZWRPdmVyQ2VsbElkeCIsInNlbGVjdGVkQ2VsbEVkaXRvciIsIm9uQ2VsbENsaWNrIiwib25DZWxsRG91YmxlQ2xpY2siLCJvbkNlbGxDb250ZXh0TWVudSIsInJvd0NsYXNzIiwib25Nb3VzZUVudGVyIiwiaGFuZGxlRHJhZ0VudGVyIiwiUm93Q29tcG9uZW50IiwiUm93Q29tcG9uZW50JDEiLCJkZWZhdWx0UmVuZGVyUm93IiwiU2Nyb2xsVG9DZWxsIiwic2Nyb2xsVG9Qb3NpdGlvbiIsImdyaWRFbGVtZW50Iiwic2V0U2Nyb2xsVG9DZWxsUG9zaXRpb24iLCJyZW1vdmVTY3JvbGxUb0NlbGwiLCJvYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwicm9vdCIsInRocmVzaG9sZCIsImdyaWRDb2x1bW4iLCJncmlkUm93IiwiYXJyb3ciLCJhcnJvd0NsYXNzbmFtZSIsInJlbmRlclNvcnRJY29uIiwicmVuZGVyU29ydFByaW9yaXR5Iiwicm9vdENsYXNzbmFtZSIsInZpZXdwb3J0RHJhZ2dpbmciLCJ2aWV3cG9ydERyYWdnaW5nQ2xhc3NuYW1lIiwiZm9jdXNTaW5rQ2xhc3NuYW1lIiwiZm9jdXNTaW5rSGVhZGVyQW5kU3VtbWFyeUNsYXNzbmFtZSIsInN1bW1hcnlDZWxsQ2xhc3NuYW1lIiwiU3VtbWFyeUNlbGwiLCJzdW1tYXJ5Q2VsbENsYXNzIiwicmVuZGVyU3VtbWFyeUNlbGwiLCJTdW1tYXJ5Q2VsbCQxIiwic3VtbWFyeVJvdyIsInRvcFN1bW1hcnlSb3ciLCJzdW1tYXJ5Um93Q2xhc3NuYW1lIiwiU3VtbWFyeVJvdyIsImJvdHRvbSIsImlzVG9wIiwiYXJpYVJvd0luZGV4IiwiU3VtbWFyeVJvdyQxIiwiRGF0YUdyaWQiLCJyb3dLZXlHZXR0ZXIiLCJyYXdSb3dIZWlnaHQiLCJoZWFkZXJSb3dIZWlnaHQiLCJyYXdIZWFkZXJSb3dIZWlnaHQiLCJzdW1tYXJ5Um93SGVpZ2h0IiwicmF3U3VtbWFyeVJvd0hlaWdodCIsInNlbGVjdGVkUm93cyIsIm9uU2VsZWN0ZWRSb3dzQ2hhbmdlIiwib25DZWxsS2V5RG93biIsIm9uU2VsZWN0ZWRDZWxsQ2hhbmdlIiwib25TY3JvbGwiLCJvbkNvcHkiLCJvblBhc3RlIiwicmF3RW5hYmxlVmlydHVhbGl6YXRpb24iLCJyZW5kZXJlcnMiLCJyYXdEaXJlY3Rpb24iLCJyYXdSb2xlIiwiYXJpYURlc2NyaWJlZEJ5IiwicmF3QXJpYVJvd0NvdW50IiwidGVzdElkIiwiZGVmYXVsdFJlbmRlcmVycyIsInJlbmRlclJvdyIsInJlbmRlclNvcnRTdGF0dXMkMSIsInJlbmRlckNoZWNrYm94JDEiLCJub1Jvd3NGYWxsYmFjayIsInNldFNjcm9sbFRvcCIsInNldFNjcm9sbExlZnQiLCJjb3BpZWRDZWxsIiwic2V0Q29waWVkQ2VsbCIsImRyYWdnZWRPdmVyUm93SWR4Iiwic2V0T3ZlclJvd0lkeCIsInNldFNjcm9sbFRvUG9zaXRpb24iLCJncmlkSGVpZ2h0IiwiYm90dG9tU3VtbWFyeVJvd3NDb3VudCIsInN1bW1hcnlSb3dzQ291bnQiLCJoZWFkZXJBbmRUb3BTdW1tYXJ5Um93c0NvdW50IiwiZ3JvdXBlZENvbHVtbkhlYWRlclJvd3NDb3VudCIsInNldFNlbGVjdGVkUG9zaXRpb24iLCJwcmV2U2VsZWN0ZWRQb3NpdGlvbiIsImxhc3RTZWxlY3RlZFJvd0lkeCIsImZvY3VzU2lua1JlZiIsInNob3VsZEZvY3VzQ2VsbFJlZiIsImlzVHJlZUdyaWQiLCJoZWFkZXJSb3dzSGVpZ2h0Iiwic3VtbWFyeVJvd3NIZWlnaHQiLCJpc1NlbGVjdGFibGUiLCJsZWZ0S2V5IiwicmlnaHRLZXkiLCJhcmlhUm93Q291bnQiLCJkZWZhdWx0R3JpZENvbXBvbmVudHMiLCJhbGxSb3dzU2VsZWN0ZWQiLCJldmVyeSIsIm1pbkNvbElkeCIsInNlbGVjdGVkQ2VsbElzV2l0aGluU2VsZWN0aW9uQm91bmRzIiwiaXNDZWxsV2l0aGluU2VsZWN0aW9uQm91bmRzIiwic2VsZWN0ZWRDZWxsSXNXaXRoaW5WaWV3cG9ydEJvdW5kcyIsImlzQ2VsbFdpdGhpblZpZXdwb3J0Qm91bmRzIiwic2Nyb2xsSGVpZ2h0IiwiaGFuZGxlQ29sdW1uUmVzaXplTGF0ZXN0Iiwib25Db2x1bW5zUmVvcmRlckxhc3Rlc3QiLCJvblNvcnRDb2x1bW5zQ2hhbmdlTGF0ZXN0Iiwib25DZWxsQ2xpY2tMYXRlc3QiLCJvbkNlbGxEb3VibGVDbGlja0xhdGVzdCIsIm9uQ2VsbENvbnRleHRNZW51TGF0ZXN0Iiwic2VsZWN0Um93TGF0ZXN0Iiwic2VsZWN0Um93IiwiaGFuZGxlRm9ybWF0dGVyUm93Q2hhbmdlTGF0ZXN0IiwidXBkYXRlUm93Iiwic2VsZWN0Q2VsbExhdGVzdCIsInNlbGVjdEhlYWRlckNlbGxMYXRlc3QiLCJpc1NhbWVQb3NpdGlvbiIsImZvY3VzIiwicHJldmVudFNjcm9sbCIsImZvY3VzQ2VsbE9yQ2VsbENvbnRlbnQiLCJzY3JvbGxUb0NlbGwiLCJzY3JvbGxUb0lkeCIsInNjcm9sbFRvUm93SWR4IiwiaXNSb3dJZHhXaXRoaW5WaWV3cG9ydEJvdW5kcyIsIm5ld1NlbGVjdGVkUm93cyIsInJvd0tleSIsInByZXZpb3VzUm93SWR4IiwiaW5kZXhPZiIsInN0ZXAiLCJFbGVtZW50IiwiaXNDZWxsRXZlbnQiLCJpc1Jvd0V2ZW50IiwiY0tleSIsImdldFNlbGVjdGlvbiIsImlzQ29sbGFwc2VkIiwiaGFuZGxlQ29weSIsImhhbmRsZVBhc3RlIiwiaGFuZGxlQ2VsbElucHV0IiwiaGFuZGxlU2Nyb2xsIiwiY29tbWl0RWRpdG9yQ2hhbmdlcyIsInNvdXJjZUNvbHVtbktleSIsInRhcmdldENvbHVtbiIsInVwZGF0ZWRUYXJnZXRSb3ciLCJ0YXJnZXRDb2x1bW5LZXkiLCJvcmlnaW5hbFJvdyIsImlzQ29sSWR4V2l0aGluU2VsZWN0aW9uQm91bmRzIiwiaXNDZWxsV2l0aGluRWRpdEJvdW5kcyIsImVuYWJsZUVkaXRvciIsInNhbWVQb3NpdGlvbiIsImdldENlbGxUb1Njcm9sbCIsImdldE5leHRQb3NpdGlvbiIsIm5leHRSb3dZIiwibmV4dFNlbGVjdGVkQ2VsbFBvc2l0aW9uIiwiZ2V0RHJhZ2dlZE92ZXJDZWxsSWR4IiwiZWxlbWVudFRvRm9jdXMiLCJyZW5kZXJEcmFnSGFuZGxlIiwiZ2V0Q2VsbEVkaXRvciIsImdldFJvd1ZpZXdwb3J0Q29sdW1ucyIsInNlbGVjdGVkQ29sdW1uIiwic2xpY2UiLCJnZXRWaWV3cG9ydFJvd3MiLCJyb3dFbGVtZW50cyIsInNlbGVjdGVkSWR4Iiwic2VsZWN0ZWRSb3dJZHgiLCJ2aWV3cG9ydFJvd0lkeCIsImlzUm93T3V0c2lkZVZpZXdwb3J0Iiwicm93Q29sdW1ucyIsImMiLCJ0ZW1wbGF0ZVJvd3MiLCJpc0dyb3VwUm93Rm9jdXNlZCIsInNjcm9sbFBhZGRpbmdJbmxpbmVTdGFydCIsInNjcm9sbFBhZGRpbmdCbG9jayIsImRpciIsIkFycmF5IiwiZnJvbSIsIl8iLCJzdW1tYXJ5Um93SWR4IiwiaXNTdW1tYXJ5Um93U2VsZWN0ZWQiLCJncmlkRWwiLCJwMSIsInAyIiwiRGF0YUdyaWQkMSIsIkdyb3VwQ2VsbCIsImlkIiwiY2hpbGRSb3dzIiwiZ3JvdXBDb2x1bW5JbmRleCIsImlzR3JvdXBCeUNvbHVtbiIsInRvZ2dsZUdyb3VwV3JhcHBlciIsImlzTGV2ZWxNYXRjaGluZyIsImN1cnNvciIsIkdyb3VwQ2VsbCQxIiwiZ3JvdXBSb3ciLCJncm91cFJvd0NsYXNzbmFtZSIsIkdyb3VwZWRSb3ciLCJncm91cEJ5IiwiaGFuZGxlU2VsZWN0R3JvdXAiLCJzZXRTaXplIiwicG9zSW5TZXQiLCJHcm91cGVkUm93JDEiLCJUcmVlRGF0YUdyaWQiLCJyYXdSb3dzIiwicmF3Um93S2V5R2V0dGVyIiwicmF3T25DZWxsS2V5RG93biIsInJhd1NlbGVjdGVkUm93cyIsInJhd09uU2VsZWN0ZWRSb3dzQ2hhbmdlIiwicmF3R3JvdXBCeSIsInJvd0dyb3VwZXIiLCJleHBhbmRlZEdyb3VwSWRzIiwib25FeHBhbmRlZEdyb3VwSWRzQ2hhbmdlIiwicmF3UmVuZGVyUm93IiwidG9nZ2xlR3JvdXBMYXRlc3QiLCJncm91cGVkUm93cyIsInJvd3NDb3VudCIsImdyb3VwUm93cyIsImdyb3VwQnlLZXkiLCJyZW1haW5pbmdHcm91cEJ5S2V5cyIsImdyb3VwUm93c0NvdW50IiwiZ3JvdXBzIiwiY2hpbGRHcm91cHMiLCJjaGlsZFJvd3NDb3VudCIsImlzR3JvdXBSb3ciLCJhbGxHcm91cFJvd3MiLCJmbGF0dGVuZWRSb3dzIiwiZXhwYW5kR3JvdXAiLCJwYXJlbnRJZCIsImlzUmVhZG9ubHlBcnJheSIsImtleXMiLCJnZXRQYXJlbnRSb3dBbmRJbmRleCIsInBhcmVudFJvdyIsInBhcmVudFJvd0FuZEluZGV4IiwiZ3JvdXBJbmRleCIsImlzR3JvdXBSb3dTZWxlY3RlZCIsImNyIiwibmV3UmF3U2VsZWN0ZWRSb3dzIiwiaGFuZGxlUm93c0NoYW5nZSIsInVwZGF0ZWRSYXdSb3dzIiwicmF3SW5kZXhlcyIsInJhd0luZGV4IiwiZ3JvdXBJZCIsIm5ld0V4cGFuZGVkR3JvdXBJZHMiLCJyb3dQcm9wcyIsImFyciIsImlzQXJyYXkiLCJUcmVlRGF0YUdyaWQkMSIsInRleHRFZGl0b3JJbnRlcm5hbENsYXNzbmFtZSIsInRleHRFZGl0b3JDbGFzc25hbWUiLCJhdXRvRm9jdXNBbmRTZWxlY3QiLCJpbnB1dCIsInNlbGVjdCIsInRleHRFZGl0b3IiLCJvbkJsdXIiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-data-grid/lib/bundle.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fnekhavhambemartin%2FDesktop%2Finsnip%20copy%2Fapp%2Ftable%2Fpage.tsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);