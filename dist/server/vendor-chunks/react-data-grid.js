"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-data-grid";
exports.ids = ["vendor-chunks/react-data-grid"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-data-grid/lib/bundle.js":
/*!****************************************************!*\
  !*** ./node_modules/react-data-grid/lib/bundle.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataGridDefaultRenderersProvider: () => (/* binding */ DataGridDefaultRenderersProvider),\n/* harmony export */   Row: () => (/* binding */ RowComponent$1),\n/* harmony export */   SELECT_COLUMN_KEY: () => (/* binding */ SELECT_COLUMN_KEY),\n/* harmony export */   SelectCellFormatter: () => (/* binding */ SelectCellFormatter),\n/* harmony export */   SelectColumn: () => (/* binding */ SelectColumn),\n/* harmony export */   ToggleGroup: () => (/* binding */ ToggleGroup),\n/* harmony export */   TreeDataGrid: () => (/* binding */ TreeDataGrid$1),\n/* harmony export */   \"default\": () => (/* binding */ DataGrid$1),\n/* harmony export */   renderCheckbox: () => (/* binding */ renderCheckbox),\n/* harmony export */   renderHeaderCell: () => (/* binding */ renderHeaderCell),\n/* harmony export */   renderSortIcon: () => (/* binding */ renderSortIcon),\n/* harmony export */   renderSortPriority: () => (/* binding */ renderSortPriority),\n/* harmony export */   renderToggleGroup: () => (/* binding */ renderToggleGroup),\n/* harmony export */   renderValue: () => (/* binding */ renderValue),\n/* harmony export */   textEditor: () => (/* binding */ textEditor),\n/* harmony export */   useRowSelection: () => (/* binding */ useRowSelection)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n\n\n\n\nfunction getColSpan(column, lastFrozenColumnIndex, args) {\n    const colSpan = typeof column.colSpan === \"function\" ? column.colSpan(args) : 1;\n    if (Number.isInteger(colSpan) && colSpan > 1 && (!column.frozen || column.idx + colSpan - 1 <= lastFrozenColumnIndex)) {\n        return colSpan;\n    }\n    return undefined;\n}\nfunction stopPropagation(event) {\n    event.stopPropagation();\n}\nfunction scrollIntoView(element) {\n    element?.scrollIntoView({\n        inline: \"nearest\",\n        block: \"nearest\"\n    });\n}\nfunction createCellEvent(event) {\n    let defaultPrevented = false;\n    const cellEvent = {\n        ...event,\n        preventGridDefault () {\n            defaultPrevented = true;\n        },\n        isGridDefaultPrevented () {\n            return defaultPrevented;\n        }\n    };\n    Object.setPrototypeOf(cellEvent, Object.getPrototypeOf(event));\n    return cellEvent;\n}\nconst nonInputKeys = new Set([\n    \"Unidentified\",\n    \"Alt\",\n    \"AltGraph\",\n    \"CapsLock\",\n    \"Control\",\n    \"Fn\",\n    \"FnLock\",\n    \"Meta\",\n    \"NumLock\",\n    \"ScrollLock\",\n    \"Shift\",\n    \"Tab\",\n    \"ArrowDown\",\n    \"ArrowLeft\",\n    \"ArrowRight\",\n    \"ArrowUp\",\n    \"End\",\n    \"Home\",\n    \"PageDown\",\n    \"PageUp\",\n    \"Insert\",\n    \"ContextMenu\",\n    \"Escape\",\n    \"Pause\",\n    \"Play\",\n    \"PrintScreen\",\n    \"F1\",\n    \"F3\",\n    \"F4\",\n    \"F5\",\n    \"F6\",\n    \"F7\",\n    \"F8\",\n    \"F9\",\n    \"F10\",\n    \"F11\",\n    \"F12\"\n]);\nfunction isCtrlKeyHeldDown(e) {\n    return (e.ctrlKey || e.metaKey) && e.key !== \"Control\";\n}\nfunction isDefaultCellInput(event) {\n    const vKey = 86;\n    if (isCtrlKeyHeldDown(event) && event.keyCode !== vKey) return false;\n    return !nonInputKeys.has(event.key);\n}\nfunction onEditorNavigation({ key, target }) {\n    if (key === \"Tab\" && (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement || target instanceof HTMLSelectElement)) {\n        return target.closest(\".rdg-editor-container\")?.querySelectorAll(\"input, textarea, select\").length === 1;\n    }\n    return false;\n}\nconst measuringCellClassname = \"mlln6zg7-0-0-beta-46\";\nfunction renderMeasuringCells(viewportColumns) {\n    return viewportColumns.map(({ key, idx, minWidth, maxWidth })=>/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n            className: measuringCellClassname,\n            style: {\n                gridColumnStart: idx + 1,\n                minWidth,\n                maxWidth\n            },\n            \"data-measuring-cell-key\": key\n        }, key));\n}\nfunction isSelectedCellEditable({ selectedPosition, columns, rows }) {\n    const column = columns[selectedPosition.idx];\n    const row = rows[selectedPosition.rowIdx];\n    return isCellEditableUtil(column, row);\n}\nfunction isCellEditableUtil(column, row) {\n    return column.renderEditCell != null && (typeof column.editable === \"function\" ? column.editable(row) : column.editable) !== false;\n}\nfunction getSelectedCellColSpan({ rows, topSummaryRows, bottomSummaryRows, rowIdx, mainHeaderRowIdx, lastFrozenColumnIndex, column }) {\n    const topSummaryRowsCount = topSummaryRows?.length ?? 0;\n    if (rowIdx === mainHeaderRowIdx) {\n        return getColSpan(column, lastFrozenColumnIndex, {\n            type: \"HEADER\"\n        });\n    }\n    if (topSummaryRows && rowIdx > mainHeaderRowIdx && rowIdx <= topSummaryRowsCount + mainHeaderRowIdx) {\n        return getColSpan(column, lastFrozenColumnIndex, {\n            type: \"SUMMARY\",\n            row: topSummaryRows[rowIdx + topSummaryRowsCount]\n        });\n    }\n    if (rowIdx >= 0 && rowIdx < rows.length) {\n        const row = rows[rowIdx];\n        return getColSpan(column, lastFrozenColumnIndex, {\n            type: \"ROW\",\n            row\n        });\n    }\n    if (bottomSummaryRows) {\n        return getColSpan(column, lastFrozenColumnIndex, {\n            type: \"SUMMARY\",\n            row: bottomSummaryRows[rowIdx - rows.length]\n        });\n    }\n    return undefined;\n}\nfunction getNextSelectedCellPosition({ moveUp, moveNext, cellNavigationMode, columns, colSpanColumns, rows, topSummaryRows, bottomSummaryRows, minRowIdx, mainHeaderRowIdx, maxRowIdx, currentPosition: { idx: currentIdx, rowIdx: currentRowIdx }, nextPosition, lastFrozenColumnIndex, isCellWithinBounds }) {\n    let { idx: nextIdx, rowIdx: nextRowIdx } = nextPosition;\n    const columnsCount = columns.length;\n    const setColSpan = (moveNext)=>{\n        for (const column of colSpanColumns){\n            const colIdx = column.idx;\n            if (colIdx > nextIdx) break;\n            const colSpan = getSelectedCellColSpan({\n                rows,\n                topSummaryRows,\n                bottomSummaryRows,\n                rowIdx: nextRowIdx,\n                mainHeaderRowIdx,\n                lastFrozenColumnIndex,\n                column\n            });\n            if (colSpan && nextIdx > colIdx && nextIdx < colSpan + colIdx) {\n                nextIdx = colIdx + (moveNext ? colSpan : 0);\n                break;\n            }\n        }\n    };\n    const getParentRowIdx = (parent)=>{\n        return parent.level + mainHeaderRowIdx;\n    };\n    const setHeaderGroupColAndRowSpan = ()=>{\n        if (moveNext) {\n            const nextColumn = columns[nextIdx];\n            let parent = nextColumn.parent;\n            while(parent !== undefined){\n                const parentRowIdx = getParentRowIdx(parent);\n                if (nextRowIdx === parentRowIdx) {\n                    nextIdx = parent.idx + parent.colSpan;\n                    break;\n                }\n                parent = parent.parent;\n            }\n        } else if (moveUp) {\n            const nextColumn = columns[nextIdx];\n            let parent = nextColumn.parent;\n            let found = false;\n            while(parent !== undefined){\n                const parentRowIdx = getParentRowIdx(parent);\n                if (nextRowIdx >= parentRowIdx) {\n                    nextIdx = parent.idx;\n                    nextRowIdx = parentRowIdx;\n                    found = true;\n                    break;\n                }\n                parent = parent.parent;\n            }\n            if (!found) {\n                nextIdx = currentIdx;\n                nextRowIdx = currentRowIdx;\n            }\n        }\n    };\n    if (isCellWithinBounds(nextPosition)) {\n        setColSpan(moveNext);\n        if (nextRowIdx < mainHeaderRowIdx) {\n            setHeaderGroupColAndRowSpan();\n        }\n    }\n    if (cellNavigationMode === \"CHANGE_ROW\") {\n        const isAfterLastColumn = nextIdx === columnsCount;\n        const isBeforeFirstColumn = nextIdx === -1;\n        if (isAfterLastColumn) {\n            const isLastRow = nextRowIdx === maxRowIdx;\n            if (!isLastRow) {\n                nextIdx = 0;\n                nextRowIdx += 1;\n            }\n        } else if (isBeforeFirstColumn) {\n            const isFirstRow = nextRowIdx === minRowIdx;\n            if (!isFirstRow) {\n                nextRowIdx -= 1;\n                nextIdx = columnsCount - 1;\n            }\n            setColSpan(false);\n        }\n    }\n    if (nextRowIdx < mainHeaderRowIdx) {\n        const nextColumn = columns[nextIdx];\n        let parent = nextColumn.parent;\n        const nextParentRowIdx = nextRowIdx;\n        nextRowIdx = mainHeaderRowIdx;\n        while(parent !== undefined){\n            const parentRowIdx = getParentRowIdx(parent);\n            if (parentRowIdx >= nextParentRowIdx) {\n                nextRowIdx = parentRowIdx;\n                nextIdx = parent.idx;\n            }\n            parent = parent.parent;\n        }\n    }\n    return {\n        idx: nextIdx,\n        rowIdx: nextRowIdx\n    };\n}\nfunction canExitGrid({ maxColIdx, minRowIdx, maxRowIdx, selectedPosition: { rowIdx, idx }, shiftKey }) {\n    const atLastCellInRow = idx === maxColIdx;\n    const atFirstCellInRow = idx === 0;\n    const atLastRow = rowIdx === maxRowIdx;\n    const atFirstRow = rowIdx === minRowIdx;\n    return shiftKey ? atFirstCellInRow && atFirstRow : atLastCellInRow && atLastRow;\n}\nconst cell = \"cj343x07-0-0-beta-46\";\nconst cellClassname = `rdg-cell ${cell}`;\nconst cellFrozen = \"csofj7r7-0-0-beta-46\";\nconst cellFrozenClassname = `rdg-cell-frozen ${cellFrozen}`;\nfunction getRowStyle(rowIdx) {\n    return {\n        \"--rdg-grid-row-start\": rowIdx\n    };\n}\nfunction getHeaderCellStyle(column, rowIdx, rowSpan) {\n    const gridRowEnd = rowIdx + 1;\n    const paddingBlockStart = `calc(${rowSpan - 1} * var(--rdg-header-row-height))`;\n    if (column.parent === undefined) {\n        return {\n            insetBlockStart: 0,\n            gridRowStart: 1,\n            gridRowEnd,\n            paddingBlockStart\n        };\n    }\n    return {\n        insetBlockStart: `calc(${rowIdx - rowSpan} * var(--rdg-header-row-height))`,\n        gridRowStart: gridRowEnd - rowSpan,\n        gridRowEnd,\n        paddingBlockStart\n    };\n}\nfunction getCellStyle(column, colSpan = 1) {\n    const index = column.idx + 1;\n    return {\n        gridColumnStart: index,\n        gridColumnEnd: index + colSpan,\n        insetInlineStart: column.frozen ? `var(--rdg-frozen-left-${column.idx})` : undefined\n    };\n}\nfunction getCellClassname(column, ...extraClasses) {\n    return (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(cellClassname, ...extraClasses, column.frozen && cellFrozenClassname);\n}\nconst { min, max, floor, sign, abs } = Math;\nfunction assertIsValidKeyGetter(keyGetter) {\n    if (typeof keyGetter !== \"function\") {\n        throw new Error(\"Please specify the rowKeyGetter prop to use selection\");\n    }\n}\nfunction clampColumnWidth(width, { minWidth, maxWidth }) {\n    width = max(width, minWidth);\n    if (typeof maxWidth === \"number\" && maxWidth >= minWidth) {\n        return min(width, maxWidth);\n    }\n    return width;\n}\nfunction getHeaderCellRowSpan(column, rowIdx) {\n    return column.parent === undefined ? rowIdx : column.level - column.parent.level;\n}\nconst checkboxContainer = \"c1bn88vv7-0-0-beta-46\";\nconst checkbox = \"c1qt073l7-0-0-beta-46\";\nconst checkboxClassname = `rdg-checkbox-input ${checkbox}`;\nfunction renderCheckbox({ onChange, ...props }) {\n    function handleChange(e) {\n        onChange(e.target.checked, e.nativeEvent.shiftKey);\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        className: checkboxContainer,\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"input\", {\n            type: \"checkbox\",\n            ...props,\n            className: checkboxClassname,\n            onChange: handleChange\n        })\n    });\n}\nconst groupCellContent = \"g1s9ylgp7-0-0-beta-46\";\nconst groupCellContentClassname = `rdg-group-cell-content ${groupCellContent}`;\nconst caret = \"cz54e4y7-0-0-beta-46\";\nconst caretClassname = `rdg-caret ${caret}`;\nfunction renderToggleGroup(props) {\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(ToggleGroup, {\n        ...props\n    });\n}\nfunction ToggleGroup({ groupKey, isExpanded, tabIndex, toggleGroup }) {\n    function handleKeyDown({ key }) {\n        if (key === \"Enter\") {\n            toggleGroup();\n        }\n    }\n    const d = isExpanded ? \"M1 1 L 7 7 L 13 1\" : \"M1 7 L 7 1 L 13 7\";\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(\"span\", {\n        className: groupCellContentClassname,\n        tabIndex: tabIndex,\n        onKeyDown: handleKeyDown,\n        children: [\n            groupKey,\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"svg\", {\n                viewBox: \"0 0 14 8\",\n                width: \"14\",\n                height: \"8\",\n                className: caretClassname,\n                \"aria-hidden\": true,\n                children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"path\", {\n                    d: d\n                })\n            })\n        ]\n    });\n}\nfunction renderValue(props) {\n    try {\n        return props.row[props.column.key];\n    } catch  {\n        return null;\n    }\n}\nconst DataGridDefaultRenderersContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\nconst DataGridDefaultRenderersProvider = DataGridDefaultRenderersContext.Provider;\nfunction useDefaultRenderers() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DataGridDefaultRenderersContext);\n}\nfunction SelectCellFormatter({ value, tabIndex, disabled, onChange, \"aria-label\": ariaLabel, \"aria-labelledby\": ariaLabelledBy }) {\n    const renderCheckbox = useDefaultRenderers().renderCheckbox;\n    return renderCheckbox({\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": ariaLabelledBy,\n        tabIndex,\n        disabled,\n        checked: value,\n        onChange\n    });\n}\nconst RowSelectionContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\nconst RowSelectionProvider = RowSelectionContext.Provider;\nconst RowSelectionChangeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\nconst RowSelectionChangeProvider = RowSelectionChangeContext.Provider;\nfunction useRowSelection() {\n    const rowSelectionContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RowSelectionContext);\n    const rowSelectionChangeContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RowSelectionChangeContext);\n    if (rowSelectionContext === undefined || rowSelectionChangeContext === undefined) {\n        throw new Error(\"useRowSelection must be used within DataGrid cells\");\n    }\n    return [\n        rowSelectionContext,\n        rowSelectionChangeContext\n    ];\n}\nconst SELECT_COLUMN_KEY = \"select-row\";\nfunction HeaderRenderer(props) {\n    const [isRowSelected, onRowSelectionChange] = useRowSelection();\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(SelectCellFormatter, {\n        \"aria-label\": \"Select All\",\n        tabIndex: props.tabIndex,\n        value: isRowSelected,\n        onChange: (checked)=>{\n            onRowSelectionChange({\n                type: \"HEADER\",\n                checked\n            });\n        }\n    });\n}\nfunction SelectFormatter(props) {\n    const [isRowSelected, onRowSelectionChange] = useRowSelection();\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(SelectCellFormatter, {\n        \"aria-label\": \"Select\",\n        tabIndex: props.tabIndex,\n        value: isRowSelected,\n        onChange: (checked, isShiftClick)=>{\n            onRowSelectionChange({\n                type: \"ROW\",\n                row: props.row,\n                checked,\n                isShiftClick\n            });\n        }\n    });\n}\nfunction SelectGroupFormatter(props) {\n    const [isRowSelected, onRowSelectionChange] = useRowSelection();\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(SelectCellFormatter, {\n        \"aria-label\": \"Select Group\",\n        tabIndex: props.tabIndex,\n        value: isRowSelected,\n        onChange: (checked)=>{\n            onRowSelectionChange({\n                type: \"ROW\",\n                row: props.row,\n                checked,\n                isShiftClick: false\n            });\n        }\n    });\n}\nconst SelectColumn = {\n    key: SELECT_COLUMN_KEY,\n    name: \"\",\n    width: 35,\n    minWidth: 35,\n    maxWidth: 35,\n    resizable: false,\n    sortable: false,\n    frozen: true,\n    renderHeaderCell (props) {\n        return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(HeaderRenderer, {\n            ...props\n        });\n    },\n    renderCell (props) {\n        return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(SelectFormatter, {\n            ...props\n        });\n    },\n    renderGroupCell (props) {\n        return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(SelectGroupFormatter, {\n            ...props\n        });\n    }\n};\nconst DEFAULT_COLUMN_WIDTH = \"auto\";\nconst DEFAULT_COLUMN_MIN_WIDTH = 50;\nfunction useCalculatedColumns({ rawColumns, defaultColumnOptions, getColumnWidth, viewportWidth, scrollLeft, enableVirtualization }) {\n    const defaultWidth = defaultColumnOptions?.width ?? DEFAULT_COLUMN_WIDTH;\n    const defaultMinWidth = defaultColumnOptions?.minWidth ?? DEFAULT_COLUMN_MIN_WIDTH;\n    const defaultMaxWidth = defaultColumnOptions?.maxWidth ?? undefined;\n    const defaultCellRenderer = defaultColumnOptions?.renderCell ?? renderValue;\n    const defaultSortable = defaultColumnOptions?.sortable ?? false;\n    const defaultResizable = defaultColumnOptions?.resizable ?? false;\n    const defaultDraggable = defaultColumnOptions?.draggable ?? false;\n    const { columns, colSpanColumns, lastFrozenColumnIndex, headerRowsCount } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let lastFrozenColumnIndex = -1;\n        let headerRowsCount = 1;\n        const columns = [];\n        collectColumns(rawColumns, 1);\n        function collectColumns(rawColumns, level, parent) {\n            for (const rawColumn of rawColumns){\n                if (\"children\" in rawColumn) {\n                    const calculatedColumnParent = {\n                        name: rawColumn.name,\n                        parent,\n                        idx: -1,\n                        colSpan: 0,\n                        level: 0,\n                        headerCellClass: rawColumn.headerCellClass\n                    };\n                    collectColumns(rawColumn.children, level + 1, calculatedColumnParent);\n                    continue;\n                }\n                const frozen = rawColumn.frozen ?? false;\n                const column = {\n                    ...rawColumn,\n                    parent,\n                    idx: 0,\n                    level: 0,\n                    frozen,\n                    width: rawColumn.width ?? defaultWidth,\n                    minWidth: rawColumn.minWidth ?? defaultMinWidth,\n                    maxWidth: rawColumn.maxWidth ?? defaultMaxWidth,\n                    sortable: rawColumn.sortable ?? defaultSortable,\n                    resizable: rawColumn.resizable ?? defaultResizable,\n                    draggable: rawColumn.draggable ?? defaultDraggable,\n                    renderCell: rawColumn.renderCell ?? defaultCellRenderer\n                };\n                columns.push(column);\n                if (frozen) {\n                    lastFrozenColumnIndex++;\n                }\n                if (level > headerRowsCount) {\n                    headerRowsCount = level;\n                }\n            }\n        }\n        columns.sort(({ key: aKey, frozen: frozenA }, { key: bKey, frozen: frozenB })=>{\n            if (aKey === SELECT_COLUMN_KEY) return -1;\n            if (bKey === SELECT_COLUMN_KEY) return 1;\n            if (frozenA) {\n                if (frozenB) return 0;\n                return -1;\n            }\n            if (frozenB) return 1;\n            return 0;\n        });\n        const colSpanColumns = [];\n        columns.forEach((column, idx)=>{\n            column.idx = idx;\n            updateColumnParent(column, idx, 0);\n            if (column.colSpan != null) {\n                colSpanColumns.push(column);\n            }\n        });\n        return {\n            columns,\n            colSpanColumns,\n            lastFrozenColumnIndex,\n            headerRowsCount\n        };\n    }, [\n        rawColumns,\n        defaultWidth,\n        defaultMinWidth,\n        defaultMaxWidth,\n        defaultCellRenderer,\n        defaultResizable,\n        defaultSortable,\n        defaultDraggable\n    ]);\n    const { templateColumns, layoutCssVars, totalFrozenColumnWidth, columnMetrics } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const columnMetrics = new Map();\n        let left = 0;\n        let totalFrozenColumnWidth = 0;\n        const templateColumns = [];\n        for (const column of columns){\n            let width = getColumnWidth(column);\n            if (typeof width === \"number\") {\n                width = clampColumnWidth(width, column);\n            } else {\n                width = column.minWidth;\n            }\n            templateColumns.push(`${width}px`);\n            columnMetrics.set(column, {\n                width,\n                left\n            });\n            left += width;\n        }\n        if (lastFrozenColumnIndex !== -1) {\n            const columnMetric = columnMetrics.get(columns[lastFrozenColumnIndex]);\n            totalFrozenColumnWidth = columnMetric.left + columnMetric.width;\n        }\n        const layoutCssVars = {};\n        for(let i = 0; i <= lastFrozenColumnIndex; i++){\n            const column = columns[i];\n            layoutCssVars[`--rdg-frozen-left-${column.idx}`] = `${columnMetrics.get(column).left}px`;\n        }\n        return {\n            templateColumns,\n            layoutCssVars,\n            totalFrozenColumnWidth,\n            columnMetrics\n        };\n    }, [\n        getColumnWidth,\n        columns,\n        lastFrozenColumnIndex\n    ]);\n    const [colOverscanStartIdx, colOverscanEndIdx] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (!enableVirtualization) {\n            return [\n                0,\n                columns.length - 1\n            ];\n        }\n        const viewportLeft = scrollLeft + totalFrozenColumnWidth;\n        const viewportRight = scrollLeft + viewportWidth;\n        const lastColIdx = columns.length - 1;\n        const firstUnfrozenColumnIdx = min(lastFrozenColumnIndex + 1, lastColIdx);\n        if (viewportLeft >= viewportRight) {\n            return [\n                firstUnfrozenColumnIdx,\n                firstUnfrozenColumnIdx\n            ];\n        }\n        let colVisibleStartIdx = firstUnfrozenColumnIdx;\n        while(colVisibleStartIdx < lastColIdx){\n            const { left, width } = columnMetrics.get(columns[colVisibleStartIdx]);\n            if (left + width > viewportLeft) {\n                break;\n            }\n            colVisibleStartIdx++;\n        }\n        let colVisibleEndIdx = colVisibleStartIdx;\n        while(colVisibleEndIdx < lastColIdx){\n            const { left, width } = columnMetrics.get(columns[colVisibleEndIdx]);\n            if (left + width >= viewportRight) {\n                break;\n            }\n            colVisibleEndIdx++;\n        }\n        const colOverscanStartIdx = max(firstUnfrozenColumnIdx, colVisibleStartIdx - 1);\n        const colOverscanEndIdx = min(lastColIdx, colVisibleEndIdx + 1);\n        return [\n            colOverscanStartIdx,\n            colOverscanEndIdx\n        ];\n    }, [\n        columnMetrics,\n        columns,\n        lastFrozenColumnIndex,\n        scrollLeft,\n        totalFrozenColumnWidth,\n        viewportWidth,\n        enableVirtualization\n    ]);\n    return {\n        columns,\n        colSpanColumns,\n        colOverscanStartIdx,\n        colOverscanEndIdx,\n        templateColumns,\n        layoutCssVars,\n        headerRowsCount,\n        lastFrozenColumnIndex,\n        totalFrozenColumnWidth\n    };\n}\nfunction updateColumnParent(column, index, level) {\n    if (level < column.level) {\n        column.level = level;\n    }\n    if (column.parent !== undefined) {\n        const { parent } = column;\n        if (parent.idx === -1) {\n            parent.idx = index;\n        }\n        parent.colSpan += 1;\n        updateColumnParent(parent, index, level - 1);\n    }\n}\nconst useLayoutEffect =  true ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : 0;\nfunction useColumnWidths(columns, viewportColumns, templateColumns, gridRef, gridWidth, resizedColumnWidths, measuredColumnWidths, setResizedColumnWidths, setMeasuredColumnWidths, onColumnResize) {\n    const prevGridWidthRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(gridWidth);\n    const columnsCanFlex = columns.length === viewportColumns.length;\n    const ignorePreviouslyMeasuredColumns = columnsCanFlex && gridWidth !== prevGridWidthRef.current;\n    const newTemplateColumns = [\n        ...templateColumns\n    ];\n    const columnsToMeasure = [];\n    for (const { key, idx, width } of viewportColumns){\n        if (typeof width === \"string\" && (ignorePreviouslyMeasuredColumns || !measuredColumnWidths.has(key)) && !resizedColumnWidths.has(key)) {\n            newTemplateColumns[idx] = width;\n            columnsToMeasure.push(key);\n        }\n    }\n    const gridTemplateColumns = newTemplateColumns.join(\" \");\n    useLayoutEffect(()=>{\n        prevGridWidthRef.current = gridWidth;\n        updateMeasuredWidths(columnsToMeasure);\n    });\n    function updateMeasuredWidths(columnsToMeasure) {\n        if (columnsToMeasure.length === 0) return;\n        setMeasuredColumnWidths((measuredColumnWidths)=>{\n            const newMeasuredColumnWidths = new Map(measuredColumnWidths);\n            let hasChanges = false;\n            for (const key of columnsToMeasure){\n                const measuredWidth = measureColumnWidth(gridRef, key);\n                hasChanges ||= measuredWidth !== measuredColumnWidths.get(key);\n                if (measuredWidth === undefined) {\n                    newMeasuredColumnWidths.delete(key);\n                } else {\n                    newMeasuredColumnWidths.set(key, measuredWidth);\n                }\n            }\n            return hasChanges ? newMeasuredColumnWidths : measuredColumnWidths;\n        });\n    }\n    function handleColumnResize(column, nextWidth) {\n        const { key: resizingKey } = column;\n        const newTemplateColumns = [\n            ...templateColumns\n        ];\n        const columnsToMeasure = [];\n        for (const { key, idx, width } of viewportColumns){\n            if (resizingKey === key) {\n                const width = typeof nextWidth === \"number\" ? `${nextWidth}px` : nextWidth;\n                newTemplateColumns[idx] = width;\n            } else if (columnsCanFlex && typeof width === \"string\" && !resizedColumnWidths.has(key)) {\n                newTemplateColumns[idx] = width;\n                columnsToMeasure.push(key);\n            }\n        }\n        gridRef.current.style.gridTemplateColumns = newTemplateColumns.join(\" \");\n        const measuredWidth = typeof nextWidth === \"number\" ? nextWidth : measureColumnWidth(gridRef, resizingKey);\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>{\n            setResizedColumnWidths((resizedColumnWidths)=>{\n                const newResizedColumnWidths = new Map(resizedColumnWidths);\n                newResizedColumnWidths.set(resizingKey, measuredWidth);\n                return newResizedColumnWidths;\n            });\n            updateMeasuredWidths(columnsToMeasure);\n        });\n        onColumnResize?.(column.idx, measuredWidth);\n    }\n    return {\n        gridTemplateColumns,\n        handleColumnResize\n    };\n}\nfunction measureColumnWidth(gridRef, key) {\n    const selector = `[data-measuring-cell-key=\"${CSS.escape(key)}\"]`;\n    const measuringCell = gridRef.current?.querySelector(selector);\n    return measuringCell?.getBoundingClientRect().width;\n}\nfunction useGridDimensions() {\n    const gridRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [inlineSize, setInlineSize] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n    const [blockSize, setBlockSize] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n    const [horizontalScrollbarHeight, setHorizontalScrollbarHeight] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    useLayoutEffect(()=>{\n        const { ResizeObserver } = window;\n        if (ResizeObserver == null) return;\n        const { clientWidth, clientHeight, offsetWidth, offsetHeight } = gridRef.current;\n        const { width, height } = gridRef.current.getBoundingClientRect();\n        const initialHorizontalScrollbarHeight = offsetHeight - clientHeight;\n        const initialWidth = width - offsetWidth + clientWidth;\n        const initialHeight = height - initialHorizontalScrollbarHeight;\n        setInlineSize(initialWidth);\n        setBlockSize(initialHeight);\n        setHorizontalScrollbarHeight(initialHorizontalScrollbarHeight);\n        const resizeObserver = new ResizeObserver((entries)=>{\n            const size = entries[0].contentBoxSize[0];\n            const { clientHeight, offsetHeight } = gridRef.current;\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>{\n                setInlineSize(size.inlineSize);\n                setBlockSize(size.blockSize);\n                setHorizontalScrollbarHeight(offsetHeight - clientHeight);\n            });\n        });\n        resizeObserver.observe(gridRef.current);\n        return ()=>{\n            resizeObserver.disconnect();\n        };\n    }, []);\n    return [\n        gridRef,\n        inlineSize,\n        blockSize,\n        horizontalScrollbarHeight\n    ];\n}\nfunction useLatestFunc(fn) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(fn);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = fn;\n    });\n    const callbackFn = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args)=>{\n        ref.current(...args);\n    }, []);\n    return fn ? callbackFn : fn;\n}\nfunction useRovingTabIndex(isSelected) {\n    const [isChildFocused, setIsChildFocused] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    if (isChildFocused && !isSelected) {\n        setIsChildFocused(false);\n    }\n    function onFocus(event) {\n        if (event.target !== event.currentTarget) {\n            setIsChildFocused(true);\n        }\n    }\n    const isFocusable = isSelected && !isChildFocused;\n    return {\n        tabIndex: isFocusable ? 0 : -1,\n        childTabIndex: isSelected ? 0 : -1,\n        onFocus: isSelected ? onFocus : undefined\n    };\n}\nfunction useViewportColumns({ columns, colSpanColumns, rows, topSummaryRows, bottomSummaryRows, colOverscanStartIdx, colOverscanEndIdx, lastFrozenColumnIndex, rowOverscanStartIdx, rowOverscanEndIdx }) {\n    const startIdx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (colOverscanStartIdx === 0) return 0;\n        let startIdx = colOverscanStartIdx;\n        const updateStartIdx = (colIdx, colSpan)=>{\n            if (colSpan !== undefined && colIdx + colSpan > colOverscanStartIdx) {\n                startIdx = colIdx;\n                return true;\n            }\n            return false;\n        };\n        for (const column of colSpanColumns){\n            const colIdx = column.idx;\n            if (colIdx >= startIdx) break;\n            if (updateStartIdx(colIdx, getColSpan(column, lastFrozenColumnIndex, {\n                type: \"HEADER\"\n            }))) {\n                break;\n            }\n            for(let rowIdx = rowOverscanStartIdx; rowIdx <= rowOverscanEndIdx; rowIdx++){\n                const row = rows[rowIdx];\n                if (updateStartIdx(colIdx, getColSpan(column, lastFrozenColumnIndex, {\n                    type: \"ROW\",\n                    row\n                }))) {\n                    break;\n                }\n            }\n            if (topSummaryRows != null) {\n                for (const row of topSummaryRows){\n                    if (updateStartIdx(colIdx, getColSpan(column, lastFrozenColumnIndex, {\n                        type: \"SUMMARY\",\n                        row\n                    }))) {\n                        break;\n                    }\n                }\n            }\n            if (bottomSummaryRows != null) {\n                for (const row of bottomSummaryRows){\n                    if (updateStartIdx(colIdx, getColSpan(column, lastFrozenColumnIndex, {\n                        type: \"SUMMARY\",\n                        row\n                    }))) {\n                        break;\n                    }\n                }\n            }\n        }\n        return startIdx;\n    }, [\n        rowOverscanStartIdx,\n        rowOverscanEndIdx,\n        rows,\n        topSummaryRows,\n        bottomSummaryRows,\n        colOverscanStartIdx,\n        lastFrozenColumnIndex,\n        colSpanColumns\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const viewportColumns = [];\n        for(let colIdx = 0; colIdx <= colOverscanEndIdx; colIdx++){\n            const column = columns[colIdx];\n            if (colIdx < startIdx && !column.frozen) continue;\n            viewportColumns.push(column);\n        }\n        return viewportColumns;\n    }, [\n        startIdx,\n        colOverscanEndIdx,\n        columns\n    ]);\n}\nfunction useViewportRows({ rows, rowHeight, clientHeight, scrollTop, enableVirtualization }) {\n    const { totalRowHeight, gridTemplateRows, getRowTop, getRowHeight, findRowIdx } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (typeof rowHeight === \"number\") {\n            return {\n                totalRowHeight: rowHeight * rows.length,\n                gridTemplateRows: ` repeat(${rows.length}, ${rowHeight}px)`,\n                getRowTop: (rowIdx)=>rowIdx * rowHeight,\n                getRowHeight: ()=>rowHeight,\n                findRowIdx: (offset)=>floor(offset / rowHeight)\n            };\n        }\n        let totalRowHeight = 0;\n        let gridTemplateRows = \" \";\n        const rowPositions = rows.map((row)=>{\n            const currentRowHeight = rowHeight(row);\n            const position = {\n                top: totalRowHeight,\n                height: currentRowHeight\n            };\n            gridTemplateRows += `${currentRowHeight}px `;\n            totalRowHeight += currentRowHeight;\n            return position;\n        });\n        const validateRowIdx = (rowIdx)=>{\n            return max(0, min(rows.length - 1, rowIdx));\n        };\n        return {\n            totalRowHeight,\n            gridTemplateRows,\n            getRowTop: (rowIdx)=>rowPositions[validateRowIdx(rowIdx)].top,\n            getRowHeight: (rowIdx)=>rowPositions[validateRowIdx(rowIdx)].height,\n            findRowIdx (offset) {\n                let start = 0;\n                let end = rowPositions.length - 1;\n                while(start <= end){\n                    const middle = start + floor((end - start) / 2);\n                    const currentOffset = rowPositions[middle].top;\n                    if (currentOffset === offset) return middle;\n                    if (currentOffset < offset) {\n                        start = middle + 1;\n                    } else if (currentOffset > offset) {\n                        end = middle - 1;\n                    }\n                    if (start > end) return end;\n                }\n                return 0;\n            }\n        };\n    }, [\n        rowHeight,\n        rows\n    ]);\n    let rowOverscanStartIdx = 0;\n    let rowOverscanEndIdx = rows.length - 1;\n    if (enableVirtualization) {\n        const overscanThreshold = 4;\n        const rowVisibleStartIdx = findRowIdx(scrollTop);\n        const rowVisibleEndIdx = findRowIdx(scrollTop + clientHeight);\n        rowOverscanStartIdx = max(0, rowVisibleStartIdx - overscanThreshold);\n        rowOverscanEndIdx = min(rows.length - 1, rowVisibleEndIdx + overscanThreshold);\n    }\n    return {\n        rowOverscanStartIdx,\n        rowOverscanEndIdx,\n        totalRowHeight,\n        gridTemplateRows,\n        getRowTop,\n        getRowHeight,\n        findRowIdx\n    };\n}\nconst cellDragHandle = \"c1w9bbhr7-0-0-beta-46\";\nconst cellDragHandleFrozenClassname = \"c1creorc7-0-0-beta-46\";\nconst cellDragHandleClassname = `rdg-cell-drag-handle ${cellDragHandle}`;\nfunction DragHandle({ gridRowStart, rows, column, columnWidth, maxColIdx, isLastRow, selectedPosition, latestDraggedOverRowIdx, isCellEditable, onRowsChange, onFill, onClick, setDragging, setDraggedOverRowIdx }) {\n    const { idx, rowIdx } = selectedPosition;\n    function handleMouseDown(event) {\n        event.preventDefault();\n        if (event.buttons !== 1) return;\n        setDragging(true);\n        window.addEventListener(\"mouseover\", onMouseOver);\n        window.addEventListener(\"mouseup\", onMouseUp);\n        function onMouseOver(event) {\n            if (event.buttons !== 1) onMouseUp();\n        }\n        function onMouseUp() {\n            window.removeEventListener(\"mouseover\", onMouseOver);\n            window.removeEventListener(\"mouseup\", onMouseUp);\n            setDragging(false);\n            handleDragEnd();\n        }\n    }\n    function handleDragEnd() {\n        const overRowIdx = latestDraggedOverRowIdx.current;\n        if (overRowIdx === undefined) return;\n        const startRowIndex = rowIdx < overRowIdx ? rowIdx + 1 : overRowIdx;\n        const endRowIndex = rowIdx < overRowIdx ? overRowIdx + 1 : rowIdx;\n        updateRows(startRowIndex, endRowIndex);\n        setDraggedOverRowIdx(undefined);\n    }\n    function handleDoubleClick(event) {\n        event.stopPropagation();\n        updateRows(rowIdx + 1, rows.length);\n    }\n    function updateRows(startRowIdx, endRowIdx) {\n        const sourceRow = rows[rowIdx];\n        const updatedRows = [\n            ...rows\n        ];\n        const indexes = [];\n        for(let i = startRowIdx; i < endRowIdx; i++){\n            if (isCellEditable({\n                rowIdx: i,\n                idx\n            })) {\n                const updatedRow = onFill({\n                    columnKey: column.key,\n                    sourceRow,\n                    targetRow: rows[i]\n                });\n                if (updatedRow !== rows[i]) {\n                    updatedRows[i] = updatedRow;\n                    indexes.push(i);\n                }\n            }\n        }\n        if (indexes.length > 0) {\n            onRowsChange?.(updatedRows, {\n                indexes,\n                column\n            });\n        }\n    }\n    function getStyle() {\n        const colSpan = column.colSpan?.({\n            type: \"ROW\",\n            row: rows[rowIdx]\n        }) ?? 1;\n        const { insetInlineStart, ...style } = getCellStyle(column, colSpan);\n        const marginEnd = \"calc(var(--rdg-drag-handle-size) * -0.5 + 1px)\";\n        const isLastColumn = column.idx + colSpan - 1 === maxColIdx;\n        return {\n            ...style,\n            gridRowStart,\n            marginInlineEnd: isLastColumn ? undefined : marginEnd,\n            marginBlockEnd: isLastRow ? undefined : marginEnd,\n            insetInlineStart: insetInlineStart ? `calc(${insetInlineStart} + ${columnWidth}px + var(--rdg-drag-handle-size) * -0.5 - 1px)` : undefined\n        };\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        style: getStyle(),\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(cellDragHandleClassname, column.frozen && cellDragHandleFrozenClassname),\n        onClick: onClick,\n        onMouseDown: handleMouseDown,\n        onDoubleClick: handleDoubleClick\n    });\n}\nconst cellEditing = \"cis5rrm7-0-0-beta-46\";\nfunction EditCell({ column, colSpan, row, rowIdx, onRowChange, closeEditor, onKeyDown, navigate }) {\n    const frameRequestRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n    const commitOnOutsideClick = column.editorOptions?.commitOnOutsideClick !== false;\n    const commitOnOutsideMouseDown = useLatestFunc(()=>{\n        onClose(true, false);\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!commitOnOutsideClick) return;\n        function onWindowCaptureMouseDown() {\n            frameRequestRef.current = requestAnimationFrame(commitOnOutsideMouseDown);\n        }\n        addEventListener(\"mousedown\", onWindowCaptureMouseDown, {\n            capture: true\n        });\n        return ()=>{\n            removeEventListener(\"mousedown\", onWindowCaptureMouseDown, {\n                capture: true\n            });\n            cancelFrameRequest();\n        };\n    }, [\n        commitOnOutsideClick,\n        commitOnOutsideMouseDown\n    ]);\n    function cancelFrameRequest() {\n        cancelAnimationFrame(frameRequestRef.current);\n    }\n    function handleKeyDown(event) {\n        if (onKeyDown) {\n            const cellEvent = createCellEvent(event);\n            onKeyDown({\n                mode: \"EDIT\",\n                row,\n                column,\n                rowIdx,\n                navigate () {\n                    navigate(event);\n                },\n                onClose\n            }, cellEvent);\n            if (cellEvent.isGridDefaultPrevented()) return;\n        }\n        if (event.key === \"Escape\") {\n            onClose();\n        } else if (event.key === \"Enter\") {\n            onClose(true);\n        } else if (onEditorNavigation(event)) {\n            navigate(event);\n        }\n    }\n    function onClose(commitChanges = false, shouldFocusCell = true) {\n        if (commitChanges) {\n            onRowChange(row, true, shouldFocusCell);\n        } else {\n            closeEditor(shouldFocusCell);\n        }\n    }\n    function onEditorRowChange(row, commitChangesAndFocus = false) {\n        onRowChange(row, commitChangesAndFocus, commitChangesAndFocus);\n    }\n    const { cellClass } = column;\n    const className = getCellClassname(column, \"rdg-editor-container\", typeof cellClass === \"function\" ? cellClass(row) : cellClass, !column.editorOptions?.displayCellContent && cellEditing);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        role: \"gridcell\",\n        \"aria-colindex\": column.idx + 1,\n        \"aria-colspan\": colSpan,\n        \"aria-selected\": true,\n        className: className,\n        style: getCellStyle(column, colSpan),\n        onKeyDown: handleKeyDown,\n        onMouseDownCapture: cancelFrameRequest,\n        children: column.renderEditCell != null && /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, {\n            children: [\n                column.renderEditCell({\n                    column,\n                    row,\n                    rowIdx,\n                    onRowChange: onEditorRowChange,\n                    onClose\n                }),\n                column.editorOptions?.displayCellContent && column.renderCell({\n                    column,\n                    row,\n                    rowIdx,\n                    isCellEditable: true,\n                    tabIndex: -1,\n                    onRowChange: onEditorRowChange\n                })\n            ]\n        })\n    });\n}\nfunction GroupedColumnHeaderCell({ column, rowIdx, isCellSelected, selectCell }) {\n    const { tabIndex, onFocus } = useRovingTabIndex(isCellSelected);\n    const { colSpan } = column;\n    const rowSpan = getHeaderCellRowSpan(column, rowIdx);\n    const index = column.idx + 1;\n    function onClick() {\n        selectCell({\n            idx: column.idx,\n            rowIdx\n        });\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        role: \"columnheader\",\n        \"aria-colindex\": index,\n        \"aria-colspan\": colSpan,\n        \"aria-rowspan\": rowSpan,\n        \"aria-selected\": isCellSelected,\n        tabIndex: tabIndex,\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(cellClassname, column.headerCellClass),\n        style: {\n            ...getHeaderCellStyle(column, rowIdx, rowSpan),\n            gridColumnStart: index,\n            gridColumnEnd: index + colSpan\n        },\n        onFocus: onFocus,\n        onClick: onClick,\n        children: column.name\n    });\n}\nconst headerSortCellClassname = \"h44jtk67-0-0-beta-46\";\nconst headerSortName = \"hcgkhxz7-0-0-beta-46\";\nconst headerSortNameClassname = `rdg-header-sort-name ${headerSortName}`;\nfunction renderHeaderCell({ column, sortDirection, priority }) {\n    if (!column.sortable) return column.name;\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(SortableHeaderCell, {\n        sortDirection: sortDirection,\n        priority: priority,\n        children: column.name\n    });\n}\nfunction SortableHeaderCell({ sortDirection, priority, children }) {\n    const renderSortStatus = useDefaultRenderers().renderSortStatus;\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(\"span\", {\n        className: headerSortCellClassname,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"span\", {\n                className: headerSortNameClassname,\n                children: children\n            }),\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"span\", {\n                children: renderSortStatus({\n                    sortDirection,\n                    priority\n                })\n            })\n        ]\n    });\n}\nconst cellSortableClassname = \"c6l2wv17-0-0-beta-46\";\nconst cellResizable = \"c1kqdw7y7-0-0-beta-46\";\nconst cellResizableClassname = `rdg-cell-resizable ${cellResizable}`;\nconst resizeHandleClassname = \"r1y6ywlx7-0-0-beta-46\";\nconst cellDraggableClassname = \"rdg-cell-draggable\";\nconst cellDragging = \"c1bezg5o7-0-0-beta-46\";\nconst cellDraggingClassname = `rdg-cell-dragging ${cellDragging}`;\nconst cellOver = \"c1vc96037-0-0-beta-46\";\nconst cellOverClassname = `rdg-cell-drag-over ${cellOver}`;\nfunction HeaderCell({ column, colSpan, rowIdx, isCellSelected, onColumnResize, onColumnsReorder, sortColumns, onSortColumnsChange, selectCell, shouldFocusGrid, direction, dragDropKey }) {\n    const [isDragging, setIsDragging] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isOver, setIsOver] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const isRtl = direction === \"rtl\";\n    const rowSpan = getHeaderCellRowSpan(column, rowIdx);\n    const { tabIndex, childTabIndex, onFocus } = useRovingTabIndex(isCellSelected);\n    const sortIndex = sortColumns?.findIndex((sort)=>sort.columnKey === column.key);\n    const sortColumn = sortIndex !== undefined && sortIndex > -1 ? sortColumns[sortIndex] : undefined;\n    const sortDirection = sortColumn?.direction;\n    const priority = sortColumn !== undefined && sortColumns.length > 1 ? sortIndex + 1 : undefined;\n    const ariaSort = sortDirection && !priority ? sortDirection === \"ASC\" ? \"ascending\" : \"descending\" : undefined;\n    const { sortable, resizable, draggable } = column;\n    const className = getCellClassname(column, column.headerCellClass, sortable && cellSortableClassname, resizable && cellResizableClassname, draggable && cellDraggableClassname, isDragging && cellDraggingClassname, isOver && cellOverClassname);\n    const renderHeaderCell$1 = column.renderHeaderCell ?? renderHeaderCell;\n    function onPointerDown(event) {\n        if (event.pointerType === \"mouse\" && event.buttons !== 1) {\n            return;\n        }\n        event.preventDefault();\n        const { currentTarget, pointerId } = event;\n        const headerCell = currentTarget.parentElement;\n        const { right, left } = headerCell.getBoundingClientRect();\n        const offset = isRtl ? event.clientX - left : right - event.clientX;\n        function onPointerMove(event) {\n            const { right, left } = headerCell.getBoundingClientRect();\n            const width = isRtl ? right + offset - event.clientX : event.clientX + offset - left;\n            if (width > 0) {\n                onColumnResize(column, clampColumnWidth(width, column));\n            }\n        }\n        function onLostPointerCapture() {\n            currentTarget.removeEventListener(\"pointermove\", onPointerMove);\n            currentTarget.removeEventListener(\"lostpointercapture\", onLostPointerCapture);\n        }\n        currentTarget.setPointerCapture(pointerId);\n        currentTarget.addEventListener(\"pointermove\", onPointerMove);\n        currentTarget.addEventListener(\"lostpointercapture\", onLostPointerCapture);\n    }\n    function onSort(ctrlClick) {\n        if (onSortColumnsChange == null) return;\n        const { sortDescendingFirst } = column;\n        if (sortColumn === undefined) {\n            const nextSort = {\n                columnKey: column.key,\n                direction: sortDescendingFirst ? \"DESC\" : \"ASC\"\n            };\n            onSortColumnsChange(sortColumns && ctrlClick ? [\n                ...sortColumns,\n                nextSort\n            ] : [\n                nextSort\n            ]);\n        } else {\n            let nextSortColumn;\n            if (sortDescendingFirst === true && sortDirection === \"DESC\" || sortDescendingFirst !== true && sortDirection === \"ASC\") {\n                nextSortColumn = {\n                    columnKey: column.key,\n                    direction: sortDirection === \"ASC\" ? \"DESC\" : \"ASC\"\n                };\n            }\n            if (ctrlClick) {\n                const nextSortColumns = [\n                    ...sortColumns\n                ];\n                if (nextSortColumn) {\n                    nextSortColumns[sortIndex] = nextSortColumn;\n                } else {\n                    nextSortColumns.splice(sortIndex, 1);\n                }\n                onSortColumnsChange(nextSortColumns);\n            } else {\n                onSortColumnsChange(nextSortColumn ? [\n                    nextSortColumn\n                ] : []);\n            }\n        }\n    }\n    function onClick(event) {\n        selectCell({\n            idx: column.idx,\n            rowIdx\n        });\n        if (sortable) {\n            onSort(event.ctrlKey || event.metaKey);\n        }\n    }\n    function onDoubleClick() {\n        onColumnResize(column, \"max-content\");\n    }\n    function handleFocus(event) {\n        onFocus?.(event);\n        if (shouldFocusGrid) {\n            selectCell({\n                idx: 0,\n                rowIdx\n            });\n        }\n    }\n    function onKeyDown(event) {\n        if (event.key === \" \" || event.key === \"Enter\") {\n            event.preventDefault();\n            onSort(event.ctrlKey || event.metaKey);\n        }\n    }\n    function onDragStart(event) {\n        event.dataTransfer.setData(dragDropKey, column.key);\n        event.dataTransfer.dropEffect = \"move\";\n        setIsDragging(true);\n    }\n    function onDragEnd() {\n        setIsDragging(false);\n    }\n    function onDragOver(event) {\n        event.preventDefault();\n        event.dataTransfer.dropEffect = \"move\";\n    }\n    function onDrop(event) {\n        setIsOver(false);\n        if (event.dataTransfer.types.includes(dragDropKey)) {\n            const sourceKey = event.dataTransfer.getData(dragDropKey);\n            if (sourceKey !== column.key) {\n                event.preventDefault();\n                onColumnsReorder?.(sourceKey, column.key);\n            }\n        }\n    }\n    function onDragEnter(event) {\n        if (isEventPertinent(event)) {\n            setIsOver(true);\n        }\n    }\n    function onDragLeave(event) {\n        if (isEventPertinent(event)) {\n            setIsOver(false);\n        }\n    }\n    let draggableProps;\n    if (draggable) {\n        draggableProps = {\n            draggable: true,\n            onDragStart,\n            onDragEnd,\n            onDragOver,\n            onDragEnter,\n            onDragLeave,\n            onDrop\n        };\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(\"div\", {\n        role: \"columnheader\",\n        \"aria-colindex\": column.idx + 1,\n        \"aria-colspan\": colSpan,\n        \"aria-rowspan\": rowSpan,\n        \"aria-selected\": isCellSelected,\n        \"aria-sort\": ariaSort,\n        tabIndex: shouldFocusGrid ? 0 : tabIndex,\n        className: className,\n        style: {\n            ...getHeaderCellStyle(column, rowIdx, rowSpan),\n            ...getCellStyle(column, colSpan)\n        },\n        onFocus: handleFocus,\n        onClick: onClick,\n        onKeyDown: sortable ? onKeyDown : undefined,\n        ...draggableProps,\n        children: [\n            renderHeaderCell$1({\n                column,\n                sortDirection,\n                priority,\n                tabIndex: childTabIndex\n            }),\n            resizable && /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n                className: resizeHandleClassname,\n                onClick: stopPropagation,\n                onDoubleClick: onDoubleClick,\n                onPointerDown: onPointerDown\n            })\n        ]\n    });\n}\nfunction isEventPertinent(event) {\n    const relatedTarget = event.relatedTarget;\n    return !event.currentTarget.contains(relatedTarget);\n}\nconst row = \"r1upfr807-0-0-beta-46\";\nconst rowClassname = `rdg-row ${row}`;\nconst rowSelected = \"r190mhd37-0-0-beta-46\";\nconst rowSelectedClassname = \"rdg-row-selected\";\nconst rowSelectedWithFrozenCell = \"r139qu9m7-0-0-beta-46\";\nconst topSummaryRowClassname = \"rdg-top-summary-row\";\nconst bottomSummaryRowClassname = \"rdg-bottom-summary-row\";\nconst headerRow = \"h10tskcx7-0-0-beta-46\";\nconst headerRowClassname = `rdg-header-row ${headerRow}`;\nfunction HeaderRow({ rowIdx, columns, onColumnResize, onColumnsReorder, sortColumns, onSortColumnsChange, lastFrozenColumnIndex, selectedCellIdx, selectCell, shouldFocusGrid, direction }) {\n    const dragDropKey = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const cells = [];\n    for(let index = 0; index < columns.length; index++){\n        const column = columns[index];\n        const colSpan = getColSpan(column, lastFrozenColumnIndex, {\n            type: \"HEADER\"\n        });\n        if (colSpan !== undefined) {\n            index += colSpan - 1;\n        }\n        cells.push(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(HeaderCell, {\n            column: column,\n            colSpan: colSpan,\n            rowIdx: rowIdx,\n            isCellSelected: selectedCellIdx === column.idx,\n            onColumnResize: onColumnResize,\n            onColumnsReorder: onColumnsReorder,\n            onSortColumnsChange: onSortColumnsChange,\n            sortColumns: sortColumns,\n            selectCell: selectCell,\n            shouldFocusGrid: shouldFocusGrid && index === 0,\n            direction: direction,\n            dragDropKey: dragDropKey\n        }, column.key));\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        role: \"row\",\n        \"aria-rowindex\": rowIdx,\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(headerRowClassname, selectedCellIdx === -1 && rowSelectedClassname),\n        children: cells\n    });\n}\nconst HeaderRow$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(HeaderRow);\nfunction GroupedColumnHeaderRow({ rowIdx, level, columns, selectedCellIdx, selectCell }) {\n    const cells = [];\n    const renderedParents = new Set();\n    for (const column of columns){\n        let { parent } = column;\n        if (parent === undefined) continue;\n        while(parent.level > level){\n            if (parent.parent === undefined) break;\n            parent = parent.parent;\n        }\n        if (parent.level === level && !renderedParents.has(parent)) {\n            renderedParents.add(parent);\n            const { idx } = parent;\n            cells.push(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(GroupedColumnHeaderCell, {\n                column: parent,\n                rowIdx: rowIdx,\n                isCellSelected: selectedCellIdx === idx,\n                selectCell: selectCell\n            }, idx));\n        }\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        role: \"row\",\n        \"aria-rowindex\": rowIdx,\n        className: headerRowClassname,\n        children: cells\n    });\n}\nconst GroupedColumnHeaderRow$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(GroupedColumnHeaderRow);\nconst cellCopied = \"c6ra8a37-0-0-beta-46\";\nconst cellCopiedClassname = `rdg-cell-copied ${cellCopied}`;\nconst cellDraggedOver = \"cq910m07-0-0-beta-46\";\nconst cellDraggedOverClassname = `rdg-cell-dragged-over ${cellDraggedOver}`;\nfunction Cell({ column, colSpan, isCellSelected, isCopied, isDraggedOver, row, rowIdx, onClick, onDoubleClick, onContextMenu, onRowChange, selectCell, ...props }) {\n    const { tabIndex, childTabIndex, onFocus } = useRovingTabIndex(isCellSelected);\n    const { cellClass } = column;\n    const className = getCellClassname(column, typeof cellClass === \"function\" ? cellClass(row) : cellClass, isCopied && cellCopiedClassname, isDraggedOver && cellDraggedOverClassname);\n    const isEditable = isCellEditableUtil(column, row);\n    function selectCellWrapper(openEditor) {\n        selectCell({\n            rowIdx,\n            idx: column.idx\n        }, openEditor);\n    }\n    function handleClick(event) {\n        if (onClick) {\n            const cellEvent = createCellEvent(event);\n            onClick({\n                row,\n                column,\n                selectCell: selectCellWrapper\n            }, cellEvent);\n            if (cellEvent.isGridDefaultPrevented()) return;\n        }\n        selectCellWrapper();\n    }\n    function handleContextMenu(event) {\n        if (onContextMenu) {\n            const cellEvent = createCellEvent(event);\n            onContextMenu({\n                row,\n                column,\n                selectCell: selectCellWrapper\n            }, cellEvent);\n            if (cellEvent.isGridDefaultPrevented()) return;\n        }\n        selectCellWrapper();\n    }\n    function handleDoubleClick(event) {\n        if (onDoubleClick) {\n            const cellEvent = createCellEvent(event);\n            onDoubleClick({\n                row,\n                column,\n                selectCell: selectCellWrapper\n            }, cellEvent);\n            if (cellEvent.isGridDefaultPrevented()) return;\n        }\n        selectCellWrapper(true);\n    }\n    function handleRowChange(newRow) {\n        onRowChange(column, newRow);\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        role: \"gridcell\",\n        \"aria-colindex\": column.idx + 1,\n        \"aria-colspan\": colSpan,\n        \"aria-selected\": isCellSelected,\n        \"aria-readonly\": !isEditable || undefined,\n        tabIndex: tabIndex,\n        className: className,\n        style: getCellStyle(column, colSpan),\n        onClick: handleClick,\n        onDoubleClick: handleDoubleClick,\n        onContextMenu: handleContextMenu,\n        onFocus: onFocus,\n        ...props,\n        children: column.renderCell({\n            column,\n            row,\n            rowIdx,\n            isCellEditable: isEditable,\n            tabIndex: childTabIndex,\n            onRowChange: handleRowChange\n        })\n    });\n}\nconst Cell$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(Cell);\nfunction Row({ className, rowIdx, gridRowStart, selectedCellIdx, isRowSelected, copiedCellIdx, draggedOverCellIdx, lastFrozenColumnIndex, row, viewportColumns, selectedCellEditor, onCellClick, onCellDoubleClick, onCellContextMenu, rowClass, setDraggedOverRowIdx, onMouseEnter, onRowChange, selectCell, ...props }, ref) {\n    const handleRowChange = useLatestFunc((column, newRow)=>{\n        onRowChange(column, rowIdx, newRow);\n    });\n    function handleDragEnter(event) {\n        setDraggedOverRowIdx?.(rowIdx);\n        onMouseEnter?.(event);\n    }\n    className = (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(rowClassname, `rdg-row-${rowIdx % 2 === 0 ? \"even\" : \"odd\"}`, rowClass?.(row, rowIdx), className, selectedCellIdx === -1 && rowSelectedClassname);\n    const cells = [];\n    for(let index = 0; index < viewportColumns.length; index++){\n        const column = viewportColumns[index];\n        const { idx } = column;\n        const colSpan = getColSpan(column, lastFrozenColumnIndex, {\n            type: \"ROW\",\n            row\n        });\n        if (colSpan !== undefined) {\n            index += colSpan - 1;\n        }\n        const isCellSelected = selectedCellIdx === idx;\n        if (isCellSelected && selectedCellEditor) {\n            cells.push(selectedCellEditor);\n        } else {\n            cells.push(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(Cell$1, {\n                column: column,\n                colSpan: colSpan,\n                row: row,\n                rowIdx: rowIdx,\n                isCopied: copiedCellIdx === idx,\n                isDraggedOver: draggedOverCellIdx === idx,\n                isCellSelected: isCellSelected,\n                onClick: onCellClick,\n                onDoubleClick: onCellDoubleClick,\n                onContextMenu: onCellContextMenu,\n                onRowChange: handleRowChange,\n                selectCell: selectCell\n            }, column.key));\n        }\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(RowSelectionProvider, {\n        value: isRowSelected,\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n            role: \"row\",\n            ref: ref,\n            className: className,\n            onMouseEnter: handleDragEnter,\n            style: getRowStyle(gridRowStart),\n            ...props,\n            children: cells\n        })\n    });\n}\nconst RowComponent = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(Row));\nconst RowComponent$1 = RowComponent;\nfunction defaultRenderRow(key, props) {\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(RowComponent, {\n        ...props\n    }, key);\n}\nfunction ScrollToCell({ scrollToPosition: { idx, rowIdx }, gridElement, setScrollToCellPosition }) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    useLayoutEffect(()=>{\n        scrollIntoView(ref.current);\n    });\n    useLayoutEffect(()=>{\n        function removeScrollToCell() {\n            setScrollToCellPosition(null);\n        }\n        const observer = new IntersectionObserver(removeScrollToCell, {\n            root: gridElement,\n            threshold: 1.0\n        });\n        observer.observe(ref.current);\n        return ()=>{\n            observer.disconnect();\n        };\n    }, [\n        gridElement,\n        setScrollToCellPosition\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        ref: ref,\n        style: {\n            gridColumn: idx === undefined ? \"1/-1\" : idx + 1,\n            gridRow: rowIdx === undefined ? \"1/-1\" : rowIdx + 2\n        }\n    });\n}\nconst arrow = \"a3ejtar7-0-0-beta-46\";\nconst arrowClassname = `rdg-sort-arrow ${arrow}`;\nfunction renderSortStatus({ sortDirection, priority }) {\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, {\n        children: [\n            renderSortIcon({\n                sortDirection\n            }),\n            renderSortPriority({\n                priority\n            })\n        ]\n    });\n}\nfunction renderSortIcon({ sortDirection }) {\n    if (sortDirection === undefined) return null;\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"svg\", {\n        viewBox: \"0 0 12 8\",\n        width: \"12\",\n        height: \"8\",\n        className: arrowClassname,\n        \"aria-hidden\": true,\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"path\", {\n            d: sortDirection === \"ASC\" ? \"M0 8 6 0 12 8\" : \"M0 0 6 8 12 0\"\n        })\n    });\n}\nfunction renderSortPriority({ priority }) {\n    return priority;\n}\nconst root = \"rnvodz57-0-0-beta-46\";\nconst rootClassname = `rdg ${root}`;\nconst viewportDragging = \"vlqv91k7-0-0-beta-46\";\nconst viewportDraggingClassname = `rdg-viewport-dragging ${viewportDragging}`;\nconst focusSinkClassname = \"f1lsfrzw7-0-0-beta-46\";\nconst focusSinkHeaderAndSummaryClassname = \"f1cte0lg7-0-0-beta-46\";\nconst summaryCellClassname = \"s8wc6fl7-0-0-beta-46\";\nfunction SummaryCell({ column, colSpan, row, rowIdx, isCellSelected, selectCell }) {\n    const { tabIndex, childTabIndex, onFocus } = useRovingTabIndex(isCellSelected);\n    const { summaryCellClass } = column;\n    const className = getCellClassname(column, summaryCellClassname, typeof summaryCellClass === \"function\" ? summaryCellClass(row) : summaryCellClass);\n    function onClick() {\n        selectCell({\n            rowIdx,\n            idx: column.idx\n        });\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        role: \"gridcell\",\n        \"aria-colindex\": column.idx + 1,\n        \"aria-colspan\": colSpan,\n        \"aria-selected\": isCellSelected,\n        tabIndex: tabIndex,\n        className: className,\n        style: getCellStyle(column, colSpan),\n        onClick: onClick,\n        onFocus: onFocus,\n        children: column.renderSummaryCell?.({\n            column,\n            row,\n            tabIndex: childTabIndex\n        })\n    });\n}\nconst SummaryCell$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(SummaryCell);\nconst summaryRow = \"skuhp557-0-0-beta-46\";\nconst topSummaryRow = \"tf8l5ub7-0-0-beta-46\";\nconst summaryRowClassname = `rdg-summary-row ${summaryRow}`;\nfunction SummaryRow({ rowIdx, gridRowStart, row, viewportColumns, top, bottom, lastFrozenColumnIndex, selectedCellIdx, isTop, selectCell, \"aria-rowindex\": ariaRowIndex }) {\n    const cells = [];\n    for(let index = 0; index < viewportColumns.length; index++){\n        const column = viewportColumns[index];\n        const colSpan = getColSpan(column, lastFrozenColumnIndex, {\n            type: \"SUMMARY\",\n            row\n        });\n        if (colSpan !== undefined) {\n            index += colSpan - 1;\n        }\n        const isCellSelected = selectedCellIdx === column.idx;\n        cells.push(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(SummaryCell$1, {\n            column: column,\n            colSpan: colSpan,\n            row: row,\n            rowIdx: rowIdx,\n            isCellSelected: isCellSelected,\n            selectCell: selectCell\n        }, column.key));\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        role: \"row\",\n        \"aria-rowindex\": ariaRowIndex,\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(rowClassname, `rdg-row-${rowIdx % 2 === 0 ? \"even\" : \"odd\"}`, summaryRowClassname, isTop ? `${topSummaryRowClassname} ${topSummaryRow}` : bottomSummaryRowClassname, selectedCellIdx === -1 && rowSelectedClassname),\n        style: {\n            ...getRowStyle(gridRowStart),\n            \"--rdg-summary-row-top\": top !== undefined ? `${top}px` : undefined,\n            \"--rdg-summary-row-bottom\": bottom !== undefined ? `${bottom}px` : undefined\n        },\n        children: cells\n    });\n}\nconst SummaryRow$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(SummaryRow);\nfunction DataGrid(props, ref) {\n    const { columns: rawColumns, rows, topSummaryRows, bottomSummaryRows, rowKeyGetter, onRowsChange, rowHeight: rawRowHeight, headerRowHeight: rawHeaderRowHeight, summaryRowHeight: rawSummaryRowHeight, selectedRows, onSelectedRowsChange, sortColumns, onSortColumnsChange, defaultColumnOptions, onCellClick, onCellDoubleClick, onCellContextMenu, onCellKeyDown, onSelectedCellChange, onScroll, onColumnResize, onColumnsReorder, onFill, onCopy, onPaste, enableVirtualization: rawEnableVirtualization, renderers, className, style, rowClass, direction: rawDirection, role: rawRole, \"aria-label\": ariaLabel, \"aria-labelledby\": ariaLabelledBy, \"aria-describedby\": ariaDescribedBy, \"aria-rowcount\": rawAriaRowCount, \"data-testid\": testId } = props;\n    const defaultRenderers = useDefaultRenderers();\n    const role = rawRole ?? \"grid\";\n    const rowHeight = rawRowHeight ?? 35;\n    const headerRowHeight = rawHeaderRowHeight ?? (typeof rowHeight === \"number\" ? rowHeight : 35);\n    const summaryRowHeight = rawSummaryRowHeight ?? (typeof rowHeight === \"number\" ? rowHeight : 35);\n    const renderRow = renderers?.renderRow ?? defaultRenderers?.renderRow ?? defaultRenderRow;\n    const renderSortStatus$1 = renderers?.renderSortStatus ?? defaultRenderers?.renderSortStatus ?? renderSortStatus;\n    const renderCheckbox$1 = renderers?.renderCheckbox ?? defaultRenderers?.renderCheckbox ?? renderCheckbox;\n    const noRowsFallback = renderers?.noRowsFallback ?? defaultRenderers?.noRowsFallback;\n    const enableVirtualization = rawEnableVirtualization ?? true;\n    const direction = rawDirection ?? \"ltr\";\n    const [scrollTop, setScrollTop] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [scrollLeft, setScrollLeft] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [resizedColumnWidths, setResizedColumnWidths] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>new Map());\n    const [measuredColumnWidths, setMeasuredColumnWidths] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>new Map());\n    const [copiedCell, setCopiedCell] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isDragging, setDragging] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [draggedOverRowIdx, setOverRowIdx] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(undefined);\n    const [scrollToPosition, setScrollToPosition] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const getColumnWidth = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((column)=>{\n        return resizedColumnWidths.get(column.key) ?? measuredColumnWidths.get(column.key) ?? column.width;\n    }, [\n        measuredColumnWidths,\n        resizedColumnWidths\n    ]);\n    const [gridRef, gridWidth, gridHeight, horizontalScrollbarHeight] = useGridDimensions();\n    const { columns, colSpanColumns, lastFrozenColumnIndex, headerRowsCount, colOverscanStartIdx, colOverscanEndIdx, templateColumns, layoutCssVars, totalFrozenColumnWidth } = useCalculatedColumns({\n        rawColumns,\n        defaultColumnOptions,\n        getColumnWidth,\n        scrollLeft,\n        viewportWidth: gridWidth,\n        enableVirtualization\n    });\n    const topSummaryRowsCount = topSummaryRows?.length ?? 0;\n    const bottomSummaryRowsCount = bottomSummaryRows?.length ?? 0;\n    const summaryRowsCount = topSummaryRowsCount + bottomSummaryRowsCount;\n    const headerAndTopSummaryRowsCount = headerRowsCount + topSummaryRowsCount;\n    const groupedColumnHeaderRowsCount = headerRowsCount - 1;\n    const minRowIdx = -headerAndTopSummaryRowsCount;\n    const mainHeaderRowIdx = minRowIdx + groupedColumnHeaderRowsCount;\n    const maxRowIdx = rows.length + bottomSummaryRowsCount - 1;\n    const [selectedPosition, setSelectedPosition] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>({\n            idx: -1,\n            rowIdx: minRowIdx - 1,\n            mode: \"SELECT\"\n        }));\n    const prevSelectedPosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(selectedPosition);\n    const latestDraggedOverRowIdx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(draggedOverRowIdx);\n    const lastSelectedRowIdx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(-1);\n    const focusSinkRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const shouldFocusCellRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const isTreeGrid = role === \"treegrid\";\n    const headerRowsHeight = headerRowsCount * headerRowHeight;\n    const summaryRowsHeight = summaryRowsCount * summaryRowHeight;\n    const clientHeight = gridHeight - headerRowsHeight - summaryRowsHeight;\n    const isSelectable = selectedRows != null && onSelectedRowsChange != null;\n    const isRtl = direction === \"rtl\";\n    const leftKey = isRtl ? \"ArrowRight\" : \"ArrowLeft\";\n    const rightKey = isRtl ? \"ArrowLeft\" : \"ArrowRight\";\n    const ariaRowCount = rawAriaRowCount ?? headerRowsCount + rows.length + summaryRowsCount;\n    const defaultGridComponents = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            renderCheckbox: renderCheckbox$1,\n            renderSortStatus: renderSortStatus$1\n        }), [\n        renderCheckbox$1,\n        renderSortStatus$1\n    ]);\n    const allRowsSelected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const { length } = rows;\n        return length !== 0 && selectedRows != null && rowKeyGetter != null && selectedRows.size >= length && rows.every((row)=>selectedRows.has(rowKeyGetter(row)));\n    }, [\n        rows,\n        selectedRows,\n        rowKeyGetter\n    ]);\n    const { rowOverscanStartIdx, rowOverscanEndIdx, totalRowHeight, gridTemplateRows, getRowTop, getRowHeight, findRowIdx } = useViewportRows({\n        rows,\n        rowHeight,\n        clientHeight,\n        scrollTop,\n        enableVirtualization\n    });\n    const viewportColumns = useViewportColumns({\n        columns,\n        colSpanColumns,\n        colOverscanStartIdx,\n        colOverscanEndIdx,\n        lastFrozenColumnIndex,\n        rowOverscanStartIdx,\n        rowOverscanEndIdx,\n        rows,\n        topSummaryRows,\n        bottomSummaryRows\n    });\n    const { gridTemplateColumns, handleColumnResize } = useColumnWidths(columns, viewportColumns, templateColumns, gridRef, gridWidth, resizedColumnWidths, measuredColumnWidths, setResizedColumnWidths, setMeasuredColumnWidths, onColumnResize);\n    const minColIdx = isTreeGrid ? -1 : 0;\n    const maxColIdx = columns.length - 1;\n    const selectedCellIsWithinSelectionBounds = isCellWithinSelectionBounds(selectedPosition);\n    const selectedCellIsWithinViewportBounds = isCellWithinViewportBounds(selectedPosition);\n    const scrollHeight = headerRowHeight + totalRowHeight + summaryRowsHeight + horizontalScrollbarHeight;\n    const handleColumnResizeLatest = useLatestFunc(handleColumnResize);\n    const onColumnsReorderLastest = useLatestFunc(onColumnsReorder);\n    const onSortColumnsChangeLatest = useLatestFunc(onSortColumnsChange);\n    const onCellClickLatest = useLatestFunc(onCellClick);\n    const onCellDoubleClickLatest = useLatestFunc(onCellDoubleClick);\n    const onCellContextMenuLatest = useLatestFunc(onCellContextMenu);\n    const selectRowLatest = useLatestFunc(selectRow);\n    const handleFormatterRowChangeLatest = useLatestFunc(updateRow);\n    const selectCellLatest = useLatestFunc(selectCell);\n    const selectHeaderCellLatest = useLatestFunc(({ idx, rowIdx })=>{\n        selectCell({\n            rowIdx: minRowIdx + rowIdx - 1,\n            idx\n        });\n    });\n    useLayoutEffect(()=>{\n        if (!selectedCellIsWithinSelectionBounds || isSamePosition(selectedPosition, prevSelectedPosition.current)) {\n            prevSelectedPosition.current = selectedPosition;\n            return;\n        }\n        prevSelectedPosition.current = selectedPosition;\n        if (selectedPosition.idx === -1) {\n            focusSinkRef.current.focus({\n                preventScroll: true\n            });\n            scrollIntoView(focusSinkRef.current);\n        }\n    });\n    useLayoutEffect(()=>{\n        if (!shouldFocusCellRef.current) return;\n        shouldFocusCellRef.current = false;\n        focusCellOrCellContent();\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>({\n            element: gridRef.current,\n            scrollToCell ({ idx, rowIdx }) {\n                const scrollToIdx = idx !== undefined && idx > lastFrozenColumnIndex && idx < columns.length ? idx : undefined;\n                const scrollToRowIdx = rowIdx !== undefined && isRowIdxWithinViewportBounds(rowIdx) ? rowIdx : undefined;\n                if (scrollToIdx !== undefined || scrollToRowIdx !== undefined) {\n                    setScrollToPosition({\n                        idx: scrollToIdx,\n                        rowIdx: scrollToRowIdx\n                    });\n                }\n            },\n            selectCell\n        }));\n    const setDraggedOverRowIdx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((rowIdx)=>{\n        setOverRowIdx(rowIdx);\n        latestDraggedOverRowIdx.current = rowIdx;\n    }, []);\n    function selectRow(args) {\n        if (!onSelectedRowsChange) return;\n        assertIsValidKeyGetter(rowKeyGetter);\n        if (args.type === \"HEADER\") {\n            const newSelectedRows = new Set(selectedRows);\n            for (const row of rows){\n                const rowKey = rowKeyGetter(row);\n                if (args.checked) {\n                    newSelectedRows.add(rowKey);\n                } else {\n                    newSelectedRows.delete(rowKey);\n                }\n            }\n            onSelectedRowsChange(newSelectedRows);\n            return;\n        }\n        const { row, checked, isShiftClick } = args;\n        const newSelectedRows = new Set(selectedRows);\n        const rowKey = rowKeyGetter(row);\n        const previousRowIdx = lastSelectedRowIdx.current;\n        const rowIdx = rows.indexOf(row);\n        lastSelectedRowIdx.current = rowIdx;\n        if (checked) {\n            newSelectedRows.add(rowKey);\n        } else {\n            newSelectedRows.delete(rowKey);\n        }\n        if (isShiftClick && previousRowIdx !== -1 && previousRowIdx !== rowIdx && previousRowIdx < rows.length) {\n            const step = sign(rowIdx - previousRowIdx);\n            for(let i = previousRowIdx + step; i !== rowIdx; i += step){\n                const row = rows[i];\n                if (checked) {\n                    newSelectedRows.add(rowKeyGetter(row));\n                } else {\n                    newSelectedRows.delete(rowKeyGetter(row));\n                }\n            }\n        }\n        onSelectedRowsChange(newSelectedRows);\n    }\n    function handleKeyDown(event) {\n        const { idx, rowIdx, mode } = selectedPosition;\n        if (mode === \"EDIT\") return;\n        if (onCellKeyDown && isRowIdxWithinViewportBounds(rowIdx)) {\n            const row = rows[rowIdx];\n            const cellEvent = createCellEvent(event);\n            onCellKeyDown({\n                mode: \"SELECT\",\n                row,\n                column: columns[idx],\n                rowIdx,\n                selectCell\n            }, cellEvent);\n            if (cellEvent.isGridDefaultPrevented()) return;\n        }\n        if (!(event.target instanceof Element)) return;\n        const isCellEvent = event.target.closest(\".rdg-cell\") !== null;\n        const isRowEvent = isTreeGrid && event.target === focusSinkRef.current;\n        if (!isCellEvent && !isRowEvent) return;\n        const { keyCode } = event;\n        if (selectedCellIsWithinViewportBounds && (onPaste != null || onCopy != null) && isCtrlKeyHeldDown(event)) {\n            const cKey = 67;\n            const vKey = 86;\n            if (keyCode === cKey) {\n                if (window.getSelection()?.isCollapsed === false) return;\n                handleCopy();\n                return;\n            }\n            if (keyCode === vKey) {\n                handlePaste();\n                return;\n            }\n        }\n        switch(event.key){\n            case \"Escape\":\n                setCopiedCell(null);\n                return;\n            case \"ArrowUp\":\n            case \"ArrowDown\":\n            case \"ArrowLeft\":\n            case \"ArrowRight\":\n            case \"Tab\":\n            case \"Home\":\n            case \"End\":\n            case \"PageUp\":\n            case \"PageDown\":\n                navigate(event);\n                break;\n            default:\n                handleCellInput(event);\n                break;\n        }\n    }\n    function handleScroll(event) {\n        const { scrollTop, scrollLeft } = event.currentTarget;\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>{\n            setScrollTop(scrollTop);\n            setScrollLeft(abs(scrollLeft));\n        });\n        onScroll?.(event);\n    }\n    function updateRow(column, rowIdx, row) {\n        if (typeof onRowsChange !== \"function\") return;\n        if (row === rows[rowIdx]) return;\n        const updatedRows = [\n            ...rows\n        ];\n        updatedRows[rowIdx] = row;\n        onRowsChange(updatedRows, {\n            indexes: [\n                rowIdx\n            ],\n            column\n        });\n    }\n    function commitEditorChanges() {\n        if (selectedPosition.mode !== \"EDIT\") return;\n        updateRow(columns[selectedPosition.idx], selectedPosition.rowIdx, selectedPosition.row);\n    }\n    function handleCopy() {\n        const { idx, rowIdx } = selectedPosition;\n        const sourceRow = rows[rowIdx];\n        const sourceColumnKey = columns[idx].key;\n        setCopiedCell({\n            row: sourceRow,\n            columnKey: sourceColumnKey\n        });\n        onCopy?.({\n            sourceRow,\n            sourceColumnKey\n        });\n    }\n    function handlePaste() {\n        if (!onPaste || !onRowsChange || copiedCell === null || !isCellEditable(selectedPosition)) {\n            return;\n        }\n        const { idx, rowIdx } = selectedPosition;\n        const targetColumn = columns[idx];\n        const targetRow = rows[rowIdx];\n        const updatedTargetRow = onPaste({\n            sourceRow: copiedCell.row,\n            sourceColumnKey: copiedCell.columnKey,\n            targetRow,\n            targetColumnKey: targetColumn.key\n        });\n        updateRow(targetColumn, rowIdx, updatedTargetRow);\n    }\n    function handleCellInput(event) {\n        if (!selectedCellIsWithinViewportBounds) return;\n        const row = rows[selectedPosition.rowIdx];\n        const { key, shiftKey } = event;\n        if (isSelectable && shiftKey && key === \" \") {\n            assertIsValidKeyGetter(rowKeyGetter);\n            const rowKey = rowKeyGetter(row);\n            selectRow({\n                type: \"ROW\",\n                row,\n                checked: !selectedRows.has(rowKey),\n                isShiftClick: false\n            });\n            event.preventDefault();\n            return;\n        }\n        if (isCellEditable(selectedPosition) && isDefaultCellInput(event)) {\n            setSelectedPosition(({ idx, rowIdx })=>({\n                    idx,\n                    rowIdx,\n                    mode: \"EDIT\",\n                    row,\n                    originalRow: row\n                }));\n        }\n    }\n    function isColIdxWithinSelectionBounds(idx) {\n        return idx >= minColIdx && idx <= maxColIdx;\n    }\n    function isRowIdxWithinViewportBounds(rowIdx) {\n        return rowIdx >= 0 && rowIdx < rows.length;\n    }\n    function isCellWithinSelectionBounds({ idx, rowIdx }) {\n        return rowIdx >= minRowIdx && rowIdx <= maxRowIdx && isColIdxWithinSelectionBounds(idx);\n    }\n    function isCellWithinEditBounds({ idx, rowIdx }) {\n        return isRowIdxWithinViewportBounds(rowIdx) && idx >= 0 && idx <= maxColIdx;\n    }\n    function isCellWithinViewportBounds({ idx, rowIdx }) {\n        return isRowIdxWithinViewportBounds(rowIdx) && isColIdxWithinSelectionBounds(idx);\n    }\n    function isCellEditable(position) {\n        return isCellWithinEditBounds(position) && isSelectedCellEditable({\n            columns,\n            rows,\n            selectedPosition: position\n        });\n    }\n    function selectCell(position, enableEditor) {\n        if (!isCellWithinSelectionBounds(position)) return;\n        commitEditorChanges();\n        const row = rows[position.rowIdx];\n        const samePosition = isSamePosition(selectedPosition, position);\n        if (enableEditor && isCellEditable(position)) {\n            setSelectedPosition({\n                ...position,\n                mode: \"EDIT\",\n                row,\n                originalRow: row\n            });\n        } else if (samePosition) {\n            scrollIntoView(getCellToScroll(gridRef.current));\n        } else {\n            shouldFocusCellRef.current = true;\n            setSelectedPosition({\n                ...position,\n                mode: \"SELECT\"\n            });\n        }\n        if (onSelectedCellChange && !samePosition) {\n            onSelectedCellChange({\n                rowIdx: position.rowIdx,\n                row,\n                column: columns[position.idx]\n            });\n        }\n    }\n    function getNextPosition(key, ctrlKey, shiftKey) {\n        const { idx, rowIdx } = selectedPosition;\n        const isRowSelected = selectedCellIsWithinSelectionBounds && idx === -1;\n        switch(key){\n            case \"ArrowUp\":\n                return {\n                    idx,\n                    rowIdx: rowIdx - 1\n                };\n            case \"ArrowDown\":\n                return {\n                    idx,\n                    rowIdx: rowIdx + 1\n                };\n            case leftKey:\n                return {\n                    idx: idx - 1,\n                    rowIdx\n                };\n            case rightKey:\n                return {\n                    idx: idx + 1,\n                    rowIdx\n                };\n            case \"Tab\":\n                return {\n                    idx: idx + (shiftKey ? -1 : 1),\n                    rowIdx\n                };\n            case \"Home\":\n                if (isRowSelected) return {\n                    idx,\n                    rowIdx: minRowIdx\n                };\n                return {\n                    idx: 0,\n                    rowIdx: ctrlKey ? minRowIdx : rowIdx\n                };\n            case \"End\":\n                if (isRowSelected) return {\n                    idx,\n                    rowIdx: maxRowIdx\n                };\n                return {\n                    idx: maxColIdx,\n                    rowIdx: ctrlKey ? maxRowIdx : rowIdx\n                };\n            case \"PageUp\":\n                {\n                    if (selectedPosition.rowIdx === minRowIdx) return selectedPosition;\n                    const nextRowY = getRowTop(rowIdx) + getRowHeight(rowIdx) - clientHeight;\n                    return {\n                        idx,\n                        rowIdx: nextRowY > 0 ? findRowIdx(nextRowY) : 0\n                    };\n                }\n            case \"PageDown\":\n                {\n                    if (selectedPosition.rowIdx >= rows.length) return selectedPosition;\n                    const nextRowY = getRowTop(rowIdx) + clientHeight;\n                    return {\n                        idx,\n                        rowIdx: nextRowY < totalRowHeight ? findRowIdx(nextRowY) : rows.length - 1\n                    };\n                }\n            default:\n                return selectedPosition;\n        }\n    }\n    function navigate(event) {\n        const { key, shiftKey } = event;\n        let cellNavigationMode = \"NONE\";\n        if (key === \"Tab\") {\n            if (canExitGrid({\n                shiftKey,\n                maxColIdx,\n                minRowIdx,\n                maxRowIdx,\n                selectedPosition\n            })) {\n                commitEditorChanges();\n                return;\n            }\n            cellNavigationMode = \"CHANGE_ROW\";\n        }\n        event.preventDefault();\n        const ctrlKey = isCtrlKeyHeldDown(event);\n        const nextPosition = getNextPosition(key, ctrlKey, shiftKey);\n        if (isSamePosition(selectedPosition, nextPosition)) return;\n        const nextSelectedCellPosition = getNextSelectedCellPosition({\n            moveUp: key === \"ArrowUp\",\n            moveNext: key === rightKey || key === \"Tab\" && !shiftKey,\n            columns,\n            colSpanColumns,\n            rows,\n            topSummaryRows,\n            bottomSummaryRows,\n            minRowIdx,\n            mainHeaderRowIdx,\n            maxRowIdx,\n            lastFrozenColumnIndex,\n            cellNavigationMode,\n            currentPosition: selectedPosition,\n            nextPosition,\n            isCellWithinBounds: isCellWithinSelectionBounds\n        });\n        selectCell(nextSelectedCellPosition);\n    }\n    function getDraggedOverCellIdx(currentRowIdx) {\n        if (draggedOverRowIdx === undefined) return;\n        const { rowIdx } = selectedPosition;\n        const isDraggedOver = rowIdx < draggedOverRowIdx ? rowIdx < currentRowIdx && currentRowIdx <= draggedOverRowIdx : rowIdx > currentRowIdx && currentRowIdx >= draggedOverRowIdx;\n        return isDraggedOver ? selectedPosition.idx : undefined;\n    }\n    function focusCellOrCellContent() {\n        const cell = getCellToScroll(gridRef.current);\n        if (cell === null) return;\n        scrollIntoView(cell);\n        const elementToFocus = cell.querySelector('[tabindex=\"0\"]') ?? cell;\n        elementToFocus.focus({\n            preventScroll: true\n        });\n    }\n    function renderDragHandle() {\n        if (onFill == null || selectedPosition.mode === \"EDIT\" || !isCellWithinViewportBounds(selectedPosition)) {\n            return;\n        }\n        const { idx, rowIdx } = selectedPosition;\n        const column = columns[idx];\n        if (column.renderEditCell == null || column.editable === false) {\n            return;\n        }\n        const columnWidth = getColumnWidth(column);\n        return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(DragHandle, {\n            gridRowStart: headerAndTopSummaryRowsCount + rowIdx + 1,\n            rows: rows,\n            column: column,\n            columnWidth: columnWidth,\n            maxColIdx: maxColIdx,\n            isLastRow: rowIdx === maxRowIdx,\n            selectedPosition: selectedPosition,\n            isCellEditable: isCellEditable,\n            latestDraggedOverRowIdx: latestDraggedOverRowIdx,\n            onRowsChange: onRowsChange,\n            onClick: focusCellOrCellContent,\n            onFill: onFill,\n            setDragging: setDragging,\n            setDraggedOverRowIdx: setDraggedOverRowIdx\n        });\n    }\n    function getCellEditor(rowIdx) {\n        if (selectedPosition.rowIdx !== rowIdx || selectedPosition.mode === \"SELECT\") return;\n        const { idx, row } = selectedPosition;\n        const column = columns[idx];\n        const colSpan = getColSpan(column, lastFrozenColumnIndex, {\n            type: \"ROW\",\n            row\n        });\n        const closeEditor = (shouldFocusCell)=>{\n            shouldFocusCellRef.current = shouldFocusCell;\n            setSelectedPosition(({ idx, rowIdx })=>({\n                    idx,\n                    rowIdx,\n                    mode: \"SELECT\"\n                }));\n        };\n        const onRowChange = (row, commitChanges, shouldFocusCell)=>{\n            if (commitChanges) {\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>{\n                    updateRow(column, selectedPosition.rowIdx, row);\n                    closeEditor(shouldFocusCell);\n                });\n            } else {\n                setSelectedPosition((position)=>({\n                        ...position,\n                        row\n                    }));\n            }\n        };\n        if (rows[selectedPosition.rowIdx] !== selectedPosition.originalRow) {\n            closeEditor(false);\n        }\n        return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(EditCell, {\n            column: column,\n            colSpan: colSpan,\n            row: row,\n            rowIdx: rowIdx,\n            onRowChange: onRowChange,\n            closeEditor: closeEditor,\n            onKeyDown: onCellKeyDown,\n            navigate: navigate\n        }, column.key);\n    }\n    function getRowViewportColumns(rowIdx) {\n        const selectedColumn = selectedPosition.idx === -1 ? undefined : columns[selectedPosition.idx];\n        if (selectedColumn !== undefined && selectedPosition.rowIdx === rowIdx && !viewportColumns.includes(selectedColumn)) {\n            return selectedPosition.idx > colOverscanEndIdx ? [\n                ...viewportColumns,\n                selectedColumn\n            ] : [\n                ...viewportColumns.slice(0, lastFrozenColumnIndex + 1),\n                selectedColumn,\n                ...viewportColumns.slice(lastFrozenColumnIndex + 1)\n            ];\n        }\n        return viewportColumns;\n    }\n    function getViewportRows() {\n        const rowElements = [];\n        const { idx: selectedIdx, rowIdx: selectedRowIdx } = selectedPosition;\n        const startRowIdx = selectedCellIsWithinViewportBounds && selectedRowIdx < rowOverscanStartIdx ? rowOverscanStartIdx - 1 : rowOverscanStartIdx;\n        const endRowIdx = selectedCellIsWithinViewportBounds && selectedRowIdx > rowOverscanEndIdx ? rowOverscanEndIdx + 1 : rowOverscanEndIdx;\n        for(let viewportRowIdx = startRowIdx; viewportRowIdx <= endRowIdx; viewportRowIdx++){\n            const isRowOutsideViewport = viewportRowIdx === rowOverscanStartIdx - 1 || viewportRowIdx === rowOverscanEndIdx + 1;\n            const rowIdx = isRowOutsideViewport ? selectedRowIdx : viewportRowIdx;\n            let rowColumns = viewportColumns;\n            const selectedColumn = selectedIdx === -1 ? undefined : columns[selectedIdx];\n            if (selectedColumn !== undefined) {\n                if (isRowOutsideViewport) {\n                    rowColumns = [\n                        selectedColumn\n                    ];\n                } else {\n                    rowColumns = getRowViewportColumns(rowIdx);\n                }\n            }\n            const row = rows[rowIdx];\n            const gridRowStart = headerAndTopSummaryRowsCount + rowIdx + 1;\n            let key = rowIdx;\n            let isRowSelected = false;\n            if (typeof rowKeyGetter === \"function\") {\n                key = rowKeyGetter(row);\n                isRowSelected = selectedRows?.has(key) ?? false;\n            }\n            rowElements.push(renderRow(key, {\n                \"aria-rowindex\": headerAndTopSummaryRowsCount + rowIdx + 1,\n                \"aria-selected\": isSelectable ? isRowSelected : undefined,\n                rowIdx,\n                row,\n                viewportColumns: rowColumns,\n                isRowSelected,\n                onCellClick: onCellClickLatest,\n                onCellDoubleClick: onCellDoubleClickLatest,\n                onCellContextMenu: onCellContextMenuLatest,\n                rowClass,\n                gridRowStart,\n                copiedCellIdx: copiedCell !== null && copiedCell.row === row ? columns.findIndex((c)=>c.key === copiedCell.columnKey) : undefined,\n                selectedCellIdx: selectedRowIdx === rowIdx ? selectedIdx : undefined,\n                draggedOverCellIdx: getDraggedOverCellIdx(rowIdx),\n                setDraggedOverRowIdx: isDragging ? setDraggedOverRowIdx : undefined,\n                lastFrozenColumnIndex,\n                onRowChange: handleFormatterRowChangeLatest,\n                selectCell: selectCellLatest,\n                selectedCellEditor: getCellEditor(rowIdx)\n            }));\n        }\n        return rowElements;\n    }\n    if (selectedPosition.idx > maxColIdx || selectedPosition.rowIdx > maxRowIdx) {\n        setSelectedPosition({\n            idx: -1,\n            rowIdx: minRowIdx - 1,\n            mode: \"SELECT\"\n        });\n        setDraggedOverRowIdx(undefined);\n    }\n    let templateRows = `repeat(${headerRowsCount}, ${headerRowHeight}px)`;\n    if (topSummaryRowsCount > 0) {\n        templateRows += ` repeat(${topSummaryRowsCount}, ${summaryRowHeight}px)`;\n    }\n    if (rows.length > 0) {\n        templateRows += gridTemplateRows;\n    }\n    if (bottomSummaryRowsCount > 0) {\n        templateRows += ` repeat(${bottomSummaryRowsCount}, ${summaryRowHeight}px)`;\n    }\n    const isGroupRowFocused = selectedPosition.idx === -1 && selectedPosition.rowIdx !== minRowIdx - 1;\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(\"div\", {\n        role: role,\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": ariaLabelledBy,\n        \"aria-describedby\": ariaDescribedBy,\n        \"aria-multiselectable\": isSelectable ? true : undefined,\n        \"aria-colcount\": columns.length,\n        \"aria-rowcount\": ariaRowCount,\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(rootClassname, className, isDragging && viewportDraggingClassname),\n        style: {\n            ...style,\n            scrollPaddingInlineStart: selectedPosition.idx > lastFrozenColumnIndex || scrollToPosition?.idx !== undefined ? `${totalFrozenColumnWidth}px` : undefined,\n            scrollPaddingBlock: isRowIdxWithinViewportBounds(selectedPosition.rowIdx) || scrollToPosition?.rowIdx !== undefined ? `${headerRowsHeight + topSummaryRowsCount * summaryRowHeight}px ${bottomSummaryRowsCount * summaryRowHeight}px` : undefined,\n            gridTemplateColumns,\n            gridTemplateRows: templateRows,\n            \"--rdg-header-row-height\": `${headerRowHeight}px`,\n            \"--rdg-scroll-height\": `${scrollHeight}px`,\n            ...layoutCssVars\n        },\n        dir: direction,\n        ref: gridRef,\n        onScroll: handleScroll,\n        onKeyDown: handleKeyDown,\n        \"data-testid\": testId,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(DataGridDefaultRenderersProvider, {\n                value: defaultGridComponents,\n                children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(RowSelectionChangeProvider, {\n                    value: selectRowLatest,\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(RowSelectionProvider, {\n                            value: allRowsSelected,\n                            children: [\n                                Array.from({\n                                    length: groupedColumnHeaderRowsCount\n                                }, (_, index)=>/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(GroupedColumnHeaderRow$1, {\n                                        rowIdx: index + 1,\n                                        level: -groupedColumnHeaderRowsCount + index,\n                                        columns: getRowViewportColumns(minRowIdx + index),\n                                        selectedCellIdx: selectedPosition.rowIdx === minRowIdx + index ? selectedPosition.idx : undefined,\n                                        selectCell: selectHeaderCellLatest\n                                    }, index)),\n                                /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(HeaderRow$1, {\n                                    rowIdx: headerRowsCount,\n                                    columns: getRowViewportColumns(mainHeaderRowIdx),\n                                    onColumnResize: handleColumnResizeLatest,\n                                    onColumnsReorder: onColumnsReorderLastest,\n                                    sortColumns: sortColumns,\n                                    onSortColumnsChange: onSortColumnsChangeLatest,\n                                    lastFrozenColumnIndex: lastFrozenColumnIndex,\n                                    selectedCellIdx: selectedPosition.rowIdx === mainHeaderRowIdx ? selectedPosition.idx : undefined,\n                                    selectCell: selectHeaderCellLatest,\n                                    shouldFocusGrid: !selectedCellIsWithinSelectionBounds,\n                                    direction: direction\n                                })\n                            ]\n                        }),\n                        rows.length === 0 && noRowsFallback ? noRowsFallback : /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, {\n                            children: [\n                                topSummaryRows?.map((row, rowIdx)=>{\n                                    const gridRowStart = headerRowsCount + 1 + rowIdx;\n                                    const summaryRowIdx = mainHeaderRowIdx + 1 + rowIdx;\n                                    const isSummaryRowSelected = selectedPosition.rowIdx === summaryRowIdx;\n                                    const top = headerRowsHeight + summaryRowHeight * rowIdx;\n                                    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(SummaryRow$1, {\n                                        \"aria-rowindex\": gridRowStart,\n                                        rowIdx: summaryRowIdx,\n                                        gridRowStart: gridRowStart,\n                                        row: row,\n                                        top: top,\n                                        bottom: undefined,\n                                        viewportColumns: getRowViewportColumns(summaryRowIdx),\n                                        lastFrozenColumnIndex: lastFrozenColumnIndex,\n                                        selectedCellIdx: isSummaryRowSelected ? selectedPosition.idx : undefined,\n                                        isTop: true,\n                                        selectCell: selectCellLatest\n                                    }, rowIdx);\n                                }),\n                                getViewportRows(),\n                                bottomSummaryRows?.map((row, rowIdx)=>{\n                                    const gridRowStart = headerAndTopSummaryRowsCount + rows.length + rowIdx + 1;\n                                    const summaryRowIdx = rows.length + rowIdx;\n                                    const isSummaryRowSelected = selectedPosition.rowIdx === summaryRowIdx;\n                                    const top = clientHeight > totalRowHeight ? gridHeight - summaryRowHeight * (bottomSummaryRows.length - rowIdx) : undefined;\n                                    const bottom = top === undefined ? summaryRowHeight * (bottomSummaryRows.length - 1 - rowIdx) : undefined;\n                                    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(SummaryRow$1, {\n                                        \"aria-rowindex\": ariaRowCount - bottomSummaryRowsCount + rowIdx + 1,\n                                        rowIdx: summaryRowIdx,\n                                        gridRowStart: gridRowStart,\n                                        row: row,\n                                        top: top,\n                                        bottom: bottom,\n                                        viewportColumns: getRowViewportColumns(summaryRowIdx),\n                                        lastFrozenColumnIndex: lastFrozenColumnIndex,\n                                        selectedCellIdx: isSummaryRowSelected ? selectedPosition.idx : undefined,\n                                        isTop: false,\n                                        selectCell: selectCellLatest\n                                    }, rowIdx);\n                                })\n                            ]\n                        })\n                    ]\n                })\n            }),\n            renderDragHandle(),\n            renderMeasuringCells(viewportColumns),\n            isTreeGrid && /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n                ref: focusSinkRef,\n                tabIndex: isGroupRowFocused ? 0 : -1,\n                className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(focusSinkClassname, isGroupRowFocused && [\n                    rowSelected,\n                    lastFrozenColumnIndex !== -1 && rowSelectedWithFrozenCell\n                ], !isRowIdxWithinViewportBounds(selectedPosition.rowIdx) && focusSinkHeaderAndSummaryClassname),\n                style: {\n                    gridRowStart: selectedPosition.rowIdx + headerAndTopSummaryRowsCount + 1\n                }\n            }),\n            scrollToPosition !== null && /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(ScrollToCell, {\n                scrollToPosition: scrollToPosition,\n                setScrollToCellPosition: setScrollToPosition,\n                gridElement: gridRef.current\n            })\n        ]\n    });\n}\nfunction getCellToScroll(gridEl) {\n    return gridEl.querySelector(':scope > [role=\"row\"] > [tabindex=\"0\"]');\n}\nfunction isSamePosition(p1, p2) {\n    return p1.idx === p2.idx && p1.rowIdx === p2.rowIdx;\n}\nconst DataGrid$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(DataGrid);\nfunction GroupCell({ id, groupKey, childRows, isExpanded, isCellSelected, column, row, groupColumnIndex, isGroupByColumn, toggleGroup: toggleGroupWrapper }) {\n    const { tabIndex, childTabIndex, onFocus } = useRovingTabIndex(isCellSelected);\n    function toggleGroup() {\n        toggleGroupWrapper(id);\n    }\n    const isLevelMatching = isGroupByColumn && groupColumnIndex === column.idx;\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        role: \"gridcell\",\n        \"aria-colindex\": column.idx + 1,\n        \"aria-selected\": isCellSelected,\n        tabIndex: tabIndex,\n        className: getCellClassname(column),\n        style: {\n            ...getCellStyle(column),\n            cursor: isLevelMatching ? \"pointer\" : \"default\"\n        },\n        onClick: isLevelMatching ? toggleGroup : undefined,\n        onFocus: onFocus,\n        children: (!isGroupByColumn || isLevelMatching) && column.renderGroupCell?.({\n            groupKey,\n            childRows,\n            column,\n            row,\n            isExpanded,\n            tabIndex: childTabIndex,\n            toggleGroup\n        })\n    }, column.key);\n}\nconst GroupCell$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(GroupCell);\nconst groupRow = \"g1yxluv37-0-0-beta-46\";\nconst groupRowClassname = `rdg-group-row ${groupRow}`;\nfunction GroupedRow({ className, row, rowIdx, viewportColumns, selectedCellIdx, isRowSelected, selectCell, gridRowStart, groupBy, toggleGroup, ...props }) {\n    const idx = viewportColumns[0].key === SELECT_COLUMN_KEY ? row.level + 1 : row.level;\n    function handleSelectGroup() {\n        selectCell({\n            rowIdx,\n            idx: -1\n        });\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(RowSelectionProvider, {\n        value: isRowSelected,\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n            role: \"row\",\n            \"aria-level\": row.level + 1,\n            \"aria-setsize\": row.setSize,\n            \"aria-posinset\": row.posInSet + 1,\n            \"aria-expanded\": row.isExpanded,\n            className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(rowClassname, groupRowClassname, `rdg-row-${rowIdx % 2 === 0 ? \"even\" : \"odd\"}`, className, selectedCellIdx === -1 && rowSelectedClassname),\n            onClick: handleSelectGroup,\n            style: getRowStyle(gridRowStart),\n            ...props,\n            children: viewportColumns.map((column)=>/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(GroupCell$1, {\n                    id: row.id,\n                    groupKey: row.groupKey,\n                    childRows: row.childRows,\n                    isExpanded: row.isExpanded,\n                    isCellSelected: selectedCellIdx === column.idx,\n                    column: column,\n                    row: row,\n                    groupColumnIndex: idx,\n                    toggleGroup: toggleGroup,\n                    isGroupByColumn: groupBy.includes(column.key)\n                }, column.key))\n        })\n    });\n}\nconst GroupedRow$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(GroupedRow);\nfunction TreeDataGrid({ columns: rawColumns, rows: rawRows, rowHeight: rawRowHeight, rowKeyGetter: rawRowKeyGetter, onCellKeyDown: rawOnCellKeyDown, onRowsChange, selectedRows: rawSelectedRows, onSelectedRowsChange: rawOnSelectedRowsChange, renderers, groupBy: rawGroupBy, rowGrouper, expandedGroupIds, onExpandedGroupIdsChange, ...props }, ref) {\n    const defaultRenderers = useDefaultRenderers();\n    const rawRenderRow = renderers?.renderRow ?? defaultRenderers?.renderRow ?? defaultRenderRow;\n    const headerAndTopSummaryRowsCount = 1 + (props.topSummaryRows?.length ?? 0);\n    const isRtl = props.direction === \"rtl\";\n    const leftKey = isRtl ? \"ArrowRight\" : \"ArrowLeft\";\n    const rightKey = isRtl ? \"ArrowLeft\" : \"ArrowRight\";\n    const toggleGroupLatest = useLatestFunc(toggleGroup);\n    const { columns, groupBy } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const columns = [\n            ...rawColumns\n        ].sort(({ key: aKey }, { key: bKey })=>{\n            if (aKey === SELECT_COLUMN_KEY) return -1;\n            if (bKey === SELECT_COLUMN_KEY) return 1;\n            if (rawGroupBy.includes(aKey)) {\n                if (rawGroupBy.includes(bKey)) {\n                    return rawGroupBy.indexOf(aKey) - rawGroupBy.indexOf(bKey);\n                }\n                return -1;\n            }\n            if (rawGroupBy.includes(bKey)) return 1;\n            return 0;\n        });\n        const groupBy = [];\n        for (const [index, column] of columns.entries()){\n            if (rawGroupBy.includes(column.key)) {\n                groupBy.push(column.key);\n                columns[index] = {\n                    ...column,\n                    frozen: true,\n                    renderCell: ()=>null,\n                    renderGroupCell: column.renderGroupCell ?? renderToggleGroup,\n                    editable: false\n                };\n            }\n        }\n        return {\n            columns,\n            groupBy\n        };\n    }, [\n        rawColumns,\n        rawGroupBy\n    ]);\n    const [groupedRows, rowsCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (groupBy.length === 0) return [\n            undefined,\n            rawRows.length\n        ];\n        const groupRows = (rows, [groupByKey, ...remainingGroupByKeys], startRowIndex)=>{\n            let groupRowsCount = 0;\n            const groups = {};\n            for (const [key, childRows] of Object.entries(rowGrouper(rows, groupByKey))){\n                const [childGroups, childRowsCount] = remainingGroupByKeys.length === 0 ? [\n                    childRows,\n                    childRows.length\n                ] : groupRows(childRows, remainingGroupByKeys, startRowIndex + groupRowsCount + 1);\n                groups[key] = {\n                    childRows,\n                    childGroups,\n                    startRowIndex: startRowIndex + groupRowsCount\n                };\n                groupRowsCount += childRowsCount + 1;\n            }\n            return [\n                groups,\n                groupRowsCount\n            ];\n        };\n        return groupRows(rawRows, groupBy, 0);\n    }, [\n        groupBy,\n        rowGrouper,\n        rawRows\n    ]);\n    const [rows, isGroupRow] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const allGroupRows = new Set();\n        if (!groupedRows) return [\n            rawRows,\n            isGroupRow\n        ];\n        const flattenedRows = [];\n        const expandGroup = (rows, parentId, level)=>{\n            if (isReadonlyArray(rows)) {\n                flattenedRows.push(...rows);\n                return;\n            }\n            Object.keys(rows).forEach((groupKey, posInSet, keys)=>{\n                const id = parentId !== undefined ? `${parentId}__${groupKey}` : groupKey;\n                const isExpanded = expandedGroupIds.has(id);\n                const { childRows, childGroups, startRowIndex } = rows[groupKey];\n                const groupRow = {\n                    id,\n                    parentId,\n                    groupKey,\n                    isExpanded,\n                    childRows,\n                    level,\n                    posInSet,\n                    startRowIndex,\n                    setSize: keys.length\n                };\n                flattenedRows.push(groupRow);\n                allGroupRows.add(groupRow);\n                if (isExpanded) {\n                    expandGroup(childGroups, id, level + 1);\n                }\n            });\n        };\n        expandGroup(groupedRows, undefined, 0);\n        return [\n            flattenedRows,\n            isGroupRow\n        ];\n        function isGroupRow(row) {\n            return allGroupRows.has(row);\n        }\n    }, [\n        expandedGroupIds,\n        groupedRows,\n        rawRows\n    ]);\n    const rowHeight = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (typeof rawRowHeight === \"function\") {\n            return (row)=>{\n                if (isGroupRow(row)) {\n                    return rawRowHeight({\n                        type: \"GROUP\",\n                        row\n                    });\n                }\n                return rawRowHeight({\n                    type: \"ROW\",\n                    row\n                });\n            };\n        }\n        return rawRowHeight;\n    }, [\n        isGroupRow,\n        rawRowHeight\n    ]);\n    const getParentRowAndIndex = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((row)=>{\n        const rowIdx = rows.indexOf(row);\n        for(let i = rowIdx - 1; i >= 0; i--){\n            const parentRow = rows[i];\n            if (isGroupRow(parentRow) && (!isGroupRow(row) || row.parentId === parentRow.id)) {\n                return [\n                    parentRow,\n                    i\n                ];\n            }\n        }\n        return undefined;\n    }, [\n        isGroupRow,\n        rows\n    ]);\n    const rowKeyGetter = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((row)=>{\n        if (isGroupRow(row)) {\n            return row.id;\n        }\n        if (typeof rawRowKeyGetter === \"function\") {\n            return rawRowKeyGetter(row);\n        }\n        const parentRowAndIndex = getParentRowAndIndex(row);\n        if (parentRowAndIndex !== undefined) {\n            const { startRowIndex, childRows } = parentRowAndIndex[0];\n            const groupIndex = childRows.indexOf(row);\n            return startRowIndex + groupIndex + 1;\n        }\n        return rows.indexOf(row);\n    }, [\n        getParentRowAndIndex,\n        isGroupRow,\n        rawRowKeyGetter,\n        rows\n    ]);\n    const selectedRows = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (rawSelectedRows == null) return null;\n        assertIsValidKeyGetter(rawRowKeyGetter);\n        const selectedRows = new Set(rawSelectedRows);\n        for (const row of rows){\n            if (isGroupRow(row)) {\n                const isGroupRowSelected = row.childRows.every((cr)=>rawSelectedRows.has(rawRowKeyGetter(cr)));\n                if (isGroupRowSelected) {\n                    selectedRows.add(row.id);\n                }\n            }\n        }\n        return selectedRows;\n    }, [\n        isGroupRow,\n        rawRowKeyGetter,\n        rawSelectedRows,\n        rows\n    ]);\n    function onSelectedRowsChange(newSelectedRows) {\n        if (!rawOnSelectedRowsChange) return;\n        assertIsValidKeyGetter(rawRowKeyGetter);\n        const newRawSelectedRows = new Set(rawSelectedRows);\n        for (const row of rows){\n            const key = rowKeyGetter(row);\n            if (selectedRows?.has(key) && !newSelectedRows.has(key)) {\n                if (isGroupRow(row)) {\n                    for (const cr of row.childRows){\n                        newRawSelectedRows.delete(rawRowKeyGetter(cr));\n                    }\n                } else {\n                    newRawSelectedRows.delete(key);\n                }\n            } else if (!selectedRows?.has(key) && newSelectedRows.has(key)) {\n                if (isGroupRow(row)) {\n                    for (const cr of row.childRows){\n                        newRawSelectedRows.add(rawRowKeyGetter(cr));\n                    }\n                } else {\n                    newRawSelectedRows.add(key);\n                }\n            }\n        }\n        rawOnSelectedRowsChange(newRawSelectedRows);\n    }\n    function handleKeyDown(args, event) {\n        rawOnCellKeyDown?.(args, event);\n        if (event.isGridDefaultPrevented()) return;\n        if (args.mode === \"EDIT\") return;\n        const { column, rowIdx, selectCell } = args;\n        const idx = column?.idx ?? -1;\n        const row = rows[rowIdx];\n        if (!isGroupRow(row)) return;\n        if (idx === -1 && (event.key === leftKey && row.isExpanded || event.key === rightKey && !row.isExpanded)) {\n            event.preventDefault();\n            event.preventGridDefault();\n            toggleGroup(row.id);\n        }\n        if (idx === -1 && event.key === leftKey && !row.isExpanded && row.level !== 0) {\n            const parentRowAndIndex = getParentRowAndIndex(row);\n            if (parentRowAndIndex !== undefined) {\n                event.preventGridDefault();\n                selectCell({\n                    idx,\n                    rowIdx: parentRowAndIndex[1]\n                });\n            }\n        }\n        if (isCtrlKeyHeldDown(event) && (event.keyCode === 67 || event.keyCode === 86)) {\n            event.preventGridDefault();\n        }\n    }\n    function handleRowsChange(updatedRows, { indexes, column }) {\n        if (!onRowsChange) return;\n        const updatedRawRows = [\n            ...rawRows\n        ];\n        const rawIndexes = [];\n        for (const index of indexes){\n            const rawIndex = rawRows.indexOf(rows[index]);\n            updatedRawRows[rawIndex] = updatedRows[index];\n            rawIndexes.push(rawIndex);\n        }\n        onRowsChange(updatedRawRows, {\n            indexes: rawIndexes,\n            column\n        });\n    }\n    function toggleGroup(groupId) {\n        const newExpandedGroupIds = new Set(expandedGroupIds);\n        if (newExpandedGroupIds.has(groupId)) {\n            newExpandedGroupIds.delete(groupId);\n        } else {\n            newExpandedGroupIds.add(groupId);\n        }\n        onExpandedGroupIdsChange(newExpandedGroupIds);\n    }\n    function renderRow(key, { row, rowClass, onCellClick, onCellDoubleClick, onCellContextMenu, onRowChange, lastFrozenColumnIndex, copiedCellIdx, draggedOverCellIdx, setDraggedOverRowIdx, selectedCellEditor, ...rowProps }) {\n        if (isGroupRow(row)) {\n            const { startRowIndex } = row;\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(GroupedRow$1, {\n                ...rowProps,\n                \"aria-rowindex\": headerAndTopSummaryRowsCount + startRowIndex + 1,\n                row: row,\n                groupBy: groupBy,\n                toggleGroup: toggleGroupLatest\n            }, key);\n        }\n        let ariaRowIndex = rowProps[\"aria-rowindex\"];\n        const parentRowAndIndex = getParentRowAndIndex(row);\n        if (parentRowAndIndex !== undefined) {\n            const { startRowIndex, childRows } = parentRowAndIndex[0];\n            const groupIndex = childRows.indexOf(row);\n            ariaRowIndex = startRowIndex + headerAndTopSummaryRowsCount + groupIndex + 2;\n        }\n        return rawRenderRow(key, {\n            ...rowProps,\n            \"aria-rowindex\": ariaRowIndex,\n            row,\n            rowClass,\n            onCellClick,\n            onCellDoubleClick,\n            onCellContextMenu,\n            onRowChange,\n            lastFrozenColumnIndex,\n            copiedCellIdx,\n            draggedOverCellIdx,\n            setDraggedOverRowIdx,\n            selectedCellEditor\n        });\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(DataGrid$1, {\n        ...props,\n        role: \"treegrid\",\n        \"aria-rowcount\": rowsCount + 1 + (props.topSummaryRows?.length ?? 0) + (props.bottomSummaryRows?.length ?? 0),\n        ref: ref,\n        columns: columns,\n        rows: rows,\n        rowHeight: rowHeight,\n        rowKeyGetter: rowKeyGetter,\n        onRowsChange: handleRowsChange,\n        selectedRows: selectedRows,\n        onSelectedRowsChange: onSelectedRowsChange,\n        onCellKeyDown: handleKeyDown,\n        renderers: {\n            ...renderers,\n            renderRow\n        }\n    });\n}\nfunction isReadonlyArray(arr) {\n    return Array.isArray(arr);\n}\nconst TreeDataGrid$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(TreeDataGrid);\nconst textEditorInternalClassname = \"t7vyx3i7-0-0-beta-46\";\nconst textEditorClassname = `rdg-text-editor ${textEditorInternalClassname}`;\nfunction autoFocusAndSelect(input) {\n    input?.focus();\n    input?.select();\n}\nfunction textEditor({ row, column, onRowChange, onClose }) {\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"input\", {\n        className: textEditorClassname,\n        ref: autoFocusAndSelect,\n        value: row[column.key],\n        onChange: (event)=>onRowChange({\n                ...row,\n                [column.key]: event.target.value\n            }),\n        onBlur: ()=>onClose(true, false)\n    });\n}\n //# sourceMappingURL=bundle.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZGF0YS1ncmlkL2xpYi9idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBeUw7QUFDbko7QUFDZDtBQUNnQztBQUV4RCxTQUFTa0IsV0FBV0MsTUFBTSxFQUFFQyxxQkFBcUIsRUFBRUMsSUFBSTtJQUNyRCxNQUFNQyxVQUFVLE9BQU9ILE9BQU9HLE9BQU8sS0FBSyxhQUFhSCxPQUFPRyxPQUFPLENBQUNELFFBQVE7SUFDOUUsSUFBSUUsT0FBT0MsU0FBUyxDQUFDRixZQUFZQSxVQUFVLEtBQU0sRUFBQ0gsT0FBT00sTUFBTSxJQUFJTixPQUFPTyxHQUFHLEdBQUdKLFVBQVUsS0FBS0YscUJBQW9CLEdBQUk7UUFDckgsT0FBT0U7SUFDVDtJQUNBLE9BQU9LO0FBQ1Q7QUFFQSxTQUFTQyxnQkFBZ0JDLEtBQUs7SUFDNUJBLE1BQU1ELGVBQWU7QUFDdkI7QUFDQSxTQUFTRSxlQUFlQyxPQUFPO0lBQzdCQSxTQUFTRCxlQUFlO1FBQ3RCRSxRQUFRO1FBQ1JDLE9BQU87SUFDVDtBQUNGO0FBRUEsU0FBU0MsZ0JBQWdCTCxLQUFLO0lBQzVCLElBQUlNLG1CQUFtQjtJQUN2QixNQUFNQyxZQUFZO1FBQ2hCLEdBQUdQLEtBQUs7UUFDUlE7WUFDRUYsbUJBQW1CO1FBQ3JCO1FBQ0FHO1lBQ0UsT0FBT0g7UUFDVDtJQUNGO0lBQ0FJLE9BQU9DLGNBQWMsQ0FBQ0osV0FBV0csT0FBT0UsY0FBYyxDQUFDWjtJQUN2RCxPQUFPTztBQUNUO0FBRUEsTUFBTU0sZUFBZSxJQUFJQyxJQUFJO0lBQUM7SUFBZ0I7SUFBTztJQUFZO0lBQVk7SUFBVztJQUFNO0lBQVU7SUFBUTtJQUFXO0lBQWM7SUFBUztJQUFPO0lBQWE7SUFBYTtJQUFjO0lBQVc7SUFBTztJQUFRO0lBQVk7SUFBVTtJQUFVO0lBQWU7SUFBVTtJQUFTO0lBQVE7SUFBZTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lB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QjtRQUNYamMsS0FBS2tjO1FBQ0xua0IsT0FBTzNHLEdBQUcsQ0FBQ3ZELE9BQU82QixHQUFHLENBQUM7UUFDdEIwRyxVQUFVN0gsQ0FBQUEsUUFBU3VXLFlBQVk7Z0JBQzdCLEdBQUcxVCxHQUFHO2dCQUNOLENBQUN2RCxPQUFPNkIsR0FBRyxDQUFDLEVBQUVuQixNQUFNeUIsTUFBTSxDQUFDK0gsS0FBSztZQUNsQztRQUNBdWtCLFFBQVEsSUFBTWpYLFFBQVEsTUFBTTtJQUM5QjtBQUNGO0FBRWdVLENBQ2hVLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2luc25pcC8uL25vZGVfbW9kdWxlcy9yZWFjdC1kYXRhLWdyaWQvbGliL2J1bmRsZS5qcz8wMzZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZU1lbW8sIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdCQxLCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgbWVtbywgdXNlSWQsIGZvcndhcmRSZWYsIHVzZUltcGVyYXRpdmVIYW5kbGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmbHVzaFN5bmMgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgeyBqc3gsIGpzeHMsIEZyYWdtZW50IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuXG5mdW5jdGlvbiBnZXRDb2xTcGFuKGNvbHVtbiwgbGFzdEZyb3plbkNvbHVtbkluZGV4LCBhcmdzKSB7XG4gIGNvbnN0IGNvbFNwYW4gPSB0eXBlb2YgY29sdW1uLmNvbFNwYW4gPT09ICdmdW5jdGlvbicgPyBjb2x1bW4uY29sU3BhbihhcmdzKSA6IDE7XG4gIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGNvbFNwYW4pICYmIGNvbFNwYW4gPiAxICYmICghY29sdW1uLmZyb3plbiB8fCBjb2x1bW4uaWR4ICsgY29sU3BhbiAtIDEgPD0gbGFzdEZyb3plbkNvbHVtbkluZGV4KSkge1xuICAgIHJldHVybiBjb2xTcGFuO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihldmVudCkge1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cbmZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KGVsZW1lbnQpIHtcbiAgZWxlbWVudD8uc2Nyb2xsSW50b1ZpZXcoe1xuICAgIGlubGluZTogJ25lYXJlc3QnLFxuICAgIGJsb2NrOiAnbmVhcmVzdCdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNlbGxFdmVudChldmVudCkge1xuICBsZXQgZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuICBjb25zdCBjZWxsRXZlbnQgPSB7XG4gICAgLi4uZXZlbnQsXG4gICAgcHJldmVudEdyaWREZWZhdWx0KCkge1xuICAgICAgZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgfSxcbiAgICBpc0dyaWREZWZhdWx0UHJldmVudGVkKCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgfVxuICB9O1xuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY2VsbEV2ZW50LCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZXZlbnQpKTtcbiAgcmV0dXJuIGNlbGxFdmVudDtcbn1cblxuY29uc3Qgbm9uSW5wdXRLZXlzID0gbmV3IFNldChbJ1VuaWRlbnRpZmllZCcsICdBbHQnLCAnQWx0R3JhcGgnLCAnQ2Fwc0xvY2snLCAnQ29udHJvbCcsICdGbicsICdGbkxvY2snLCAnTWV0YScsICdOdW1Mb2NrJywgJ1Njcm9sbExvY2snLCAnU2hpZnQnLCAnVGFiJywgJ0Fycm93RG93bicsICdBcnJvd0xlZnQnLCAnQXJyb3dSaWdodCcsICdBcnJvd1VwJywgJ0VuZCcsICdIb21lJywgJ1BhZ2VEb3duJywgJ1BhZ2VVcCcsICdJbnNlcnQnLCAnQ29udGV4dE1lbnUnLCAnRXNjYXBlJywgJ1BhdXNlJywgJ1BsYXknLCAnUHJpbnRTY3JlZW4nLCAnRjEnLCAnRjMnLCAnRjQnLCAnRjUnLCAnRjYnLCAnRjcnLCAnRjgnLCAnRjknLCAnRjEwJywgJ0YxMScsICdGMTInXSk7XG5mdW5jdGlvbiBpc0N0cmxLZXlIZWxkRG93bihlKSB7XG4gIHJldHVybiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgJiYgZS5rZXkgIT09ICdDb250cm9sJztcbn1cbmZ1bmN0aW9uIGlzRGVmYXVsdENlbGxJbnB1dChldmVudCkge1xuICBjb25zdCB2S2V5ID0gODY7XG4gIGlmIChpc0N0cmxLZXlIZWxkRG93bihldmVudCkgJiYgZXZlbnQua2V5Q29kZSAhPT0gdktleSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gIW5vbklucHV0S2V5cy5oYXMoZXZlbnQua2V5KTtcbn1cbmZ1bmN0aW9uIG9uRWRpdG9yTmF2aWdhdGlvbih7XG4gIGtleSxcbiAgdGFyZ2V0XG59KSB7XG4gIGlmIChrZXkgPT09ICdUYWInICYmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50IHx8IHRhcmdldCBpbnN0YW5jZW9mIEhUTUxUZXh0QXJlYUVsZW1lbnQgfHwgdGFyZ2V0IGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHRhcmdldC5jbG9zZXN0KCcucmRnLWVkaXRvci1jb250YWluZXInKT8ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQsIHRleHRhcmVhLCBzZWxlY3QnKS5sZW5ndGggPT09IDE7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jb25zdCBtZWFzdXJpbmdDZWxsQ2xhc3NuYW1lID0gXCJtbGxuNnpnNy0wLTAtYmV0YS00NlwiO1xuZnVuY3Rpb24gcmVuZGVyTWVhc3VyaW5nQ2VsbHModmlld3BvcnRDb2x1bW5zKSB7XG4gIHJldHVybiB2aWV3cG9ydENvbHVtbnMubWFwKCh7XG4gICAga2V5LFxuICAgIGlkeCxcbiAgICBtaW5XaWR0aCxcbiAgICBtYXhXaWR0aFxuICB9KSA9PiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IG1lYXN1cmluZ0NlbGxDbGFzc25hbWUsXG4gICAgc3R5bGU6IHtcbiAgICAgIGdyaWRDb2x1bW5TdGFydDogaWR4ICsgMSxcbiAgICAgIG1pbldpZHRoLFxuICAgICAgbWF4V2lkdGhcbiAgICB9LFxuICAgIFwiZGF0YS1tZWFzdXJpbmctY2VsbC1rZXlcIjoga2V5XG4gIH0sIGtleSkpO1xufVxuXG5mdW5jdGlvbiBpc1NlbGVjdGVkQ2VsbEVkaXRhYmxlKHtcbiAgc2VsZWN0ZWRQb3NpdGlvbixcbiAgY29sdW1ucyxcbiAgcm93c1xufSkge1xuICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zW3NlbGVjdGVkUG9zaXRpb24uaWR4XTtcbiAgY29uc3Qgcm93ID0gcm93c1tzZWxlY3RlZFBvc2l0aW9uLnJvd0lkeF07XG4gIHJldHVybiBpc0NlbGxFZGl0YWJsZVV0aWwoY29sdW1uLCByb3cpO1xufVxuZnVuY3Rpb24gaXNDZWxsRWRpdGFibGVVdGlsKGNvbHVtbiwgcm93KSB7XG4gIHJldHVybiBjb2x1bW4ucmVuZGVyRWRpdENlbGwgIT0gbnVsbCAmJiAodHlwZW9mIGNvbHVtbi5lZGl0YWJsZSA9PT0gJ2Z1bmN0aW9uJyA/IGNvbHVtbi5lZGl0YWJsZShyb3cpIDogY29sdW1uLmVkaXRhYmxlKSAhPT0gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRTZWxlY3RlZENlbGxDb2xTcGFuKHtcbiAgcm93cyxcbiAgdG9wU3VtbWFyeVJvd3MsXG4gIGJvdHRvbVN1bW1hcnlSb3dzLFxuICByb3dJZHgsXG4gIG1haW5IZWFkZXJSb3dJZHgsXG4gIGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgY29sdW1uXG59KSB7XG4gIGNvbnN0IHRvcFN1bW1hcnlSb3dzQ291bnQgPSB0b3BTdW1tYXJ5Um93cz8ubGVuZ3RoID8/IDA7XG4gIGlmIChyb3dJZHggPT09IG1haW5IZWFkZXJSb3dJZHgpIHtcbiAgICByZXR1cm4gZ2V0Q29sU3Bhbihjb2x1bW4sIGxhc3RGcm96ZW5Db2x1bW5JbmRleCwge1xuICAgICAgdHlwZTogJ0hFQURFUidcbiAgICB9KTtcbiAgfVxuICBpZiAodG9wU3VtbWFyeVJvd3MgJiYgcm93SWR4ID4gbWFpbkhlYWRlclJvd0lkeCAmJiByb3dJZHggPD0gdG9wU3VtbWFyeVJvd3NDb3VudCArIG1haW5IZWFkZXJSb3dJZHgpIHtcbiAgICByZXR1cm4gZ2V0Q29sU3Bhbihjb2x1bW4sIGxhc3RGcm96ZW5Db2x1bW5JbmRleCwge1xuICAgICAgdHlwZTogJ1NVTU1BUlknLFxuICAgICAgcm93OiB0b3BTdW1tYXJ5Um93c1tyb3dJZHggKyB0b3BTdW1tYXJ5Um93c0NvdW50XVxuICAgIH0pO1xuICB9XG4gIGlmIChyb3dJZHggPj0gMCAmJiByb3dJZHggPCByb3dzLmxlbmd0aCkge1xuICAgIGNvbnN0IHJvdyA9IHJvd3Nbcm93SWR4XTtcbiAgICByZXR1cm4gZ2V0Q29sU3Bhbihjb2x1bW4sIGxhc3RGcm96ZW5Db2x1bW5JbmRleCwge1xuICAgICAgdHlwZTogJ1JPVycsXG4gICAgICByb3dcbiAgICB9KTtcbiAgfVxuICBpZiAoYm90dG9tU3VtbWFyeVJvd3MpIHtcbiAgICByZXR1cm4gZ2V0Q29sU3Bhbihjb2x1bW4sIGxhc3RGcm96ZW5Db2x1bW5JbmRleCwge1xuICAgICAgdHlwZTogJ1NVTU1BUlknLFxuICAgICAgcm93OiBib3R0b21TdW1tYXJ5Um93c1tyb3dJZHggLSByb3dzLmxlbmd0aF1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0TmV4dFNlbGVjdGVkQ2VsbFBvc2l0aW9uKHtcbiAgbW92ZVVwLFxuICBtb3ZlTmV4dCxcbiAgY2VsbE5hdmlnYXRpb25Nb2RlLFxuICBjb2x1bW5zLFxuICBjb2xTcGFuQ29sdW1ucyxcbiAgcm93cyxcbiAgdG9wU3VtbWFyeVJvd3MsXG4gIGJvdHRvbVN1bW1hcnlSb3dzLFxuICBtaW5Sb3dJZHgsXG4gIG1haW5IZWFkZXJSb3dJZHgsXG4gIG1heFJvd0lkeCxcbiAgY3VycmVudFBvc2l0aW9uOiB7XG4gICAgaWR4OiBjdXJyZW50SWR4LFxuICAgIHJvd0lkeDogY3VycmVudFJvd0lkeFxuICB9LFxuICBuZXh0UG9zaXRpb24sXG4gIGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgaXNDZWxsV2l0aGluQm91bmRzXG59KSB7XG4gIGxldCB7XG4gICAgaWR4OiBuZXh0SWR4LFxuICAgIHJvd0lkeDogbmV4dFJvd0lkeFxuICB9ID0gbmV4dFBvc2l0aW9uO1xuICBjb25zdCBjb2x1bW5zQ291bnQgPSBjb2x1bW5zLmxlbmd0aDtcbiAgY29uc3Qgc2V0Q29sU3BhbiA9IG1vdmVOZXh0ID0+IHtcbiAgICBmb3IgKGNvbnN0IGNvbHVtbiBvZiBjb2xTcGFuQ29sdW1ucykge1xuICAgICAgY29uc3QgY29sSWR4ID0gY29sdW1uLmlkeDtcbiAgICAgIGlmIChjb2xJZHggPiBuZXh0SWR4KSBicmVhaztcbiAgICAgIGNvbnN0IGNvbFNwYW4gPSBnZXRTZWxlY3RlZENlbGxDb2xTcGFuKHtcbiAgICAgICAgcm93cyxcbiAgICAgICAgdG9wU3VtbWFyeVJvd3MsXG4gICAgICAgIGJvdHRvbVN1bW1hcnlSb3dzLFxuICAgICAgICByb3dJZHg6IG5leHRSb3dJZHgsXG4gICAgICAgIG1haW5IZWFkZXJSb3dJZHgsXG4gICAgICAgIGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgICAgICAgY29sdW1uXG4gICAgICB9KTtcbiAgICAgIGlmIChjb2xTcGFuICYmIG5leHRJZHggPiBjb2xJZHggJiYgbmV4dElkeCA8IGNvbFNwYW4gKyBjb2xJZHgpIHtcbiAgICAgICAgbmV4dElkeCA9IGNvbElkeCArIChtb3ZlTmV4dCA/IGNvbFNwYW4gOiAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBnZXRQYXJlbnRSb3dJZHggPSBwYXJlbnQgPT4ge1xuICAgIHJldHVybiBwYXJlbnQubGV2ZWwgKyBtYWluSGVhZGVyUm93SWR4O1xuICB9O1xuICBjb25zdCBzZXRIZWFkZXJHcm91cENvbEFuZFJvd1NwYW4gPSAoKSA9PiB7XG4gICAgaWYgKG1vdmVOZXh0KSB7XG4gICAgICBjb25zdCBuZXh0Q29sdW1uID0gY29sdW1uc1tuZXh0SWR4XTtcbiAgICAgIGxldCBwYXJlbnQgPSBuZXh0Q29sdW1uLnBhcmVudDtcbiAgICAgIHdoaWxlIChwYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBwYXJlbnRSb3dJZHggPSBnZXRQYXJlbnRSb3dJZHgocGFyZW50KTtcbiAgICAgICAgaWYgKG5leHRSb3dJZHggPT09IHBhcmVudFJvd0lkeCkge1xuICAgICAgICAgIG5leHRJZHggPSBwYXJlbnQuaWR4ICsgcGFyZW50LmNvbFNwYW47XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1vdmVVcCkge1xuICAgICAgY29uc3QgbmV4dENvbHVtbiA9IGNvbHVtbnNbbmV4dElkeF07XG4gICAgICBsZXQgcGFyZW50ID0gbmV4dENvbHVtbi5wYXJlbnQ7XG4gICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChwYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBwYXJlbnRSb3dJZHggPSBnZXRQYXJlbnRSb3dJZHgocGFyZW50KTtcbiAgICAgICAgaWYgKG5leHRSb3dJZHggPj0gcGFyZW50Um93SWR4KSB7XG4gICAgICAgICAgbmV4dElkeCA9IHBhcmVudC5pZHg7XG4gICAgICAgICAgbmV4dFJvd0lkeCA9IHBhcmVudFJvd0lkeDtcbiAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgbmV4dElkeCA9IGN1cnJlbnRJZHg7XG4gICAgICAgIG5leHRSb3dJZHggPSBjdXJyZW50Um93SWR4O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgaWYgKGlzQ2VsbFdpdGhpbkJvdW5kcyhuZXh0UG9zaXRpb24pKSB7XG4gICAgc2V0Q29sU3Bhbihtb3ZlTmV4dCk7XG4gICAgaWYgKG5leHRSb3dJZHggPCBtYWluSGVhZGVyUm93SWR4KSB7XG4gICAgICBzZXRIZWFkZXJHcm91cENvbEFuZFJvd1NwYW4oKTtcbiAgICB9XG4gIH1cbiAgaWYgKGNlbGxOYXZpZ2F0aW9uTW9kZSA9PT0gJ0NIQU5HRV9ST1cnKSB7XG4gICAgY29uc3QgaXNBZnRlckxhc3RDb2x1bW4gPSBuZXh0SWR4ID09PSBjb2x1bW5zQ291bnQ7XG4gICAgY29uc3QgaXNCZWZvcmVGaXJzdENvbHVtbiA9IG5leHRJZHggPT09IC0xO1xuICAgIGlmIChpc0FmdGVyTGFzdENvbHVtbikge1xuICAgICAgY29uc3QgaXNMYXN0Um93ID0gbmV4dFJvd0lkeCA9PT0gbWF4Um93SWR4O1xuICAgICAgaWYgKCFpc0xhc3RSb3cpIHtcbiAgICAgICAgbmV4dElkeCA9IDA7XG4gICAgICAgIG5leHRSb3dJZHggKz0gMTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQmVmb3JlRmlyc3RDb2x1bW4pIHtcbiAgICAgIGNvbnN0IGlzRmlyc3RSb3cgPSBuZXh0Um93SWR4ID09PSBtaW5Sb3dJZHg7XG4gICAgICBpZiAoIWlzRmlyc3RSb3cpIHtcbiAgICAgICAgbmV4dFJvd0lkeCAtPSAxO1xuICAgICAgICBuZXh0SWR4ID0gY29sdW1uc0NvdW50IC0gMTtcbiAgICAgIH1cbiAgICAgIHNldENvbFNwYW4oZmFsc2UpO1xuICAgIH1cbiAgfVxuICBpZiAobmV4dFJvd0lkeCA8IG1haW5IZWFkZXJSb3dJZHgpIHtcbiAgICBjb25zdCBuZXh0Q29sdW1uID0gY29sdW1uc1tuZXh0SWR4XTtcbiAgICBsZXQgcGFyZW50ID0gbmV4dENvbHVtbi5wYXJlbnQ7XG4gICAgY29uc3QgbmV4dFBhcmVudFJvd0lkeCA9IG5leHRSb3dJZHg7XG4gICAgbmV4dFJvd0lkeCA9IG1haW5IZWFkZXJSb3dJZHg7XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBwYXJlbnRSb3dJZHggPSBnZXRQYXJlbnRSb3dJZHgocGFyZW50KTtcbiAgICAgIGlmIChwYXJlbnRSb3dJZHggPj0gbmV4dFBhcmVudFJvd0lkeCkge1xuICAgICAgICBuZXh0Um93SWR4ID0gcGFyZW50Um93SWR4O1xuICAgICAgICBuZXh0SWR4ID0gcGFyZW50LmlkeDtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgaWR4OiBuZXh0SWR4LFxuICAgIHJvd0lkeDogbmV4dFJvd0lkeFxuICB9O1xufVxuZnVuY3Rpb24gY2FuRXhpdEdyaWQoe1xuICBtYXhDb2xJZHgsXG4gIG1pblJvd0lkeCxcbiAgbWF4Um93SWR4LFxuICBzZWxlY3RlZFBvc2l0aW9uOiB7XG4gICAgcm93SWR4LFxuICAgIGlkeFxuICB9LFxuICBzaGlmdEtleVxufSkge1xuICBjb25zdCBhdExhc3RDZWxsSW5Sb3cgPSBpZHggPT09IG1heENvbElkeDtcbiAgY29uc3QgYXRGaXJzdENlbGxJblJvdyA9IGlkeCA9PT0gMDtcbiAgY29uc3QgYXRMYXN0Um93ID0gcm93SWR4ID09PSBtYXhSb3dJZHg7XG4gIGNvbnN0IGF0Rmlyc3RSb3cgPSByb3dJZHggPT09IG1pblJvd0lkeDtcbiAgcmV0dXJuIHNoaWZ0S2V5ID8gYXRGaXJzdENlbGxJblJvdyAmJiBhdEZpcnN0Um93IDogYXRMYXN0Q2VsbEluUm93ICYmIGF0TGFzdFJvdztcbn1cblxuY29uc3QgY2VsbCA9IFwiY2ozNDN4MDctMC0wLWJldGEtNDZcIjtcbmNvbnN0IGNlbGxDbGFzc25hbWUgPSBgcmRnLWNlbGwgJHtjZWxsfWA7XG5jb25zdCBjZWxsRnJvemVuID0gXCJjc29majdyNy0wLTAtYmV0YS00NlwiO1xuY29uc3QgY2VsbEZyb3plbkNsYXNzbmFtZSA9IGByZGctY2VsbC1mcm96ZW4gJHtjZWxsRnJvemVufWA7XG5cbmZ1bmN0aW9uIGdldFJvd1N0eWxlKHJvd0lkeCkge1xuICByZXR1cm4ge1xuICAgICctLXJkZy1ncmlkLXJvdy1zdGFydCc6IHJvd0lkeFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0SGVhZGVyQ2VsbFN0eWxlKGNvbHVtbiwgcm93SWR4LCByb3dTcGFuKSB7XG4gIGNvbnN0IGdyaWRSb3dFbmQgPSByb3dJZHggKyAxO1xuICBjb25zdCBwYWRkaW5nQmxvY2tTdGFydCA9IGBjYWxjKCR7cm93U3BhbiAtIDF9ICogdmFyKC0tcmRnLWhlYWRlci1yb3ctaGVpZ2h0KSlgO1xuICBpZiAoY29sdW1uLnBhcmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluc2V0QmxvY2tTdGFydDogMCxcbiAgICAgIGdyaWRSb3dTdGFydDogMSxcbiAgICAgIGdyaWRSb3dFbmQsXG4gICAgICBwYWRkaW5nQmxvY2tTdGFydFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpbnNldEJsb2NrU3RhcnQ6IGBjYWxjKCR7cm93SWR4IC0gcm93U3Bhbn0gKiB2YXIoLS1yZGctaGVhZGVyLXJvdy1oZWlnaHQpKWAsXG4gICAgZ3JpZFJvd1N0YXJ0OiBncmlkUm93RW5kIC0gcm93U3BhbixcbiAgICBncmlkUm93RW5kLFxuICAgIHBhZGRpbmdCbG9ja1N0YXJ0XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDZWxsU3R5bGUoY29sdW1uLCBjb2xTcGFuID0gMSkge1xuICBjb25zdCBpbmRleCA9IGNvbHVtbi5pZHggKyAxO1xuICByZXR1cm4ge1xuICAgIGdyaWRDb2x1bW5TdGFydDogaW5kZXgsXG4gICAgZ3JpZENvbHVtbkVuZDogaW5kZXggKyBjb2xTcGFuLFxuICAgIGluc2V0SW5saW5lU3RhcnQ6IGNvbHVtbi5mcm96ZW4gPyBgdmFyKC0tcmRnLWZyb3plbi1sZWZ0LSR7Y29sdW1uLmlkeH0pYCA6IHVuZGVmaW5lZFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2VsbENsYXNzbmFtZShjb2x1bW4sIC4uLmV4dHJhQ2xhc3Nlcykge1xuICByZXR1cm4gY2xzeChjZWxsQ2xhc3NuYW1lLCAuLi5leHRyYUNsYXNzZXMsIGNvbHVtbi5mcm96ZW4gJiYgY2VsbEZyb3plbkNsYXNzbmFtZSk7XG59XG5cbmNvbnN0IHtcbiAgbWluLFxuICBtYXgsXG4gIGZsb29yLFxuICBzaWduLFxuICBhYnNcbn0gPSBNYXRoO1xuZnVuY3Rpb24gYXNzZXJ0SXNWYWxpZEtleUdldHRlcihrZXlHZXR0ZXIpIHtcbiAgaWYgKHR5cGVvZiBrZXlHZXR0ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBzcGVjaWZ5IHRoZSByb3dLZXlHZXR0ZXIgcHJvcCB0byB1c2Ugc2VsZWN0aW9uJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsYW1wQ29sdW1uV2lkdGgod2lkdGgsIHtcbiAgbWluV2lkdGgsXG4gIG1heFdpZHRoXG59KSB7XG4gIHdpZHRoID0gbWF4KHdpZHRoLCBtaW5XaWR0aCk7XG4gIGlmICh0eXBlb2YgbWF4V2lkdGggPT09ICdudW1iZXInICYmIG1heFdpZHRoID49IG1pbldpZHRoKSB7XG4gICAgcmV0dXJuIG1pbih3aWR0aCwgbWF4V2lkdGgpO1xuICB9XG4gIHJldHVybiB3aWR0aDtcbn1cbmZ1bmN0aW9uIGdldEhlYWRlckNlbGxSb3dTcGFuKGNvbHVtbiwgcm93SWR4KSB7XG4gIHJldHVybiBjb2x1bW4ucGFyZW50ID09PSB1bmRlZmluZWQgPyByb3dJZHggOiBjb2x1bW4ubGV2ZWwgLSBjb2x1bW4ucGFyZW50LmxldmVsO1xufVxuXG5jb25zdCBjaGVja2JveENvbnRhaW5lciA9IFwiYzFibjg4dnY3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCBjaGVja2JveCA9IFwiYzFxdDA3M2w3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCBjaGVja2JveENsYXNzbmFtZSA9IGByZGctY2hlY2tib3gtaW5wdXQgJHtjaGVja2JveH1gO1xuZnVuY3Rpb24gcmVuZGVyQ2hlY2tib3goe1xuICBvbkNoYW5nZSxcbiAgLi4ucHJvcHNcbn0pIHtcbiAgZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKGUpIHtcbiAgICBvbkNoYW5nZShlLnRhcmdldC5jaGVja2VkLCBlLm5hdGl2ZUV2ZW50LnNoaWZ0S2V5KTtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBjaGVja2JveENvbnRhaW5lcixcbiAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChcImlucHV0XCIsIHtcbiAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgIC4uLnByb3BzLFxuICAgICAgY2xhc3NOYW1lOiBjaGVja2JveENsYXNzbmFtZSxcbiAgICAgIG9uQ2hhbmdlOiBoYW5kbGVDaGFuZ2VcbiAgICB9KVxuICB9KTtcbn1cblxuY29uc3QgZ3JvdXBDZWxsQ29udGVudCA9IFwiZzFzOXlsZ3A3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCBncm91cENlbGxDb250ZW50Q2xhc3NuYW1lID0gYHJkZy1ncm91cC1jZWxsLWNvbnRlbnQgJHtncm91cENlbGxDb250ZW50fWA7XG5jb25zdCBjYXJldCA9IFwiY3o1NGU0eTctMC0wLWJldGEtNDZcIjtcbmNvbnN0IGNhcmV0Q2xhc3NuYW1lID0gYHJkZy1jYXJldCAke2NhcmV0fWA7XG5mdW5jdGlvbiByZW5kZXJUb2dnbGVHcm91cChwcm9wcykge1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChUb2dnbGVHcm91cCwge1xuICAgIC4uLnByb3BzXG4gIH0pO1xufVxuZnVuY3Rpb24gVG9nZ2xlR3JvdXAoe1xuICBncm91cEtleSxcbiAgaXNFeHBhbmRlZCxcbiAgdGFiSW5kZXgsXG4gIHRvZ2dsZUdyb3VwXG59KSB7XG4gIGZ1bmN0aW9uIGhhbmRsZUtleURvd24oe1xuICAgIGtleVxuICB9KSB7XG4gICAgaWYgKGtleSA9PT0gJ0VudGVyJykge1xuICAgICAgdG9nZ2xlR3JvdXAoKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZCA9IGlzRXhwYW5kZWQgPyAnTTEgMSBMIDcgNyBMIDEzIDEnIDogJ00xIDcgTCA3IDEgTCAxMyA3JztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3hzKFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBncm91cENlbGxDb250ZW50Q2xhc3NuYW1lLFxuICAgIHRhYkluZGV4OiB0YWJJbmRleCxcbiAgICBvbktleURvd246IGhhbmRsZUtleURvd24sXG4gICAgY2hpbGRyZW46IFtncm91cEtleSwgLyojX19QVVJFX18qL2pzeChcInN2Z1wiLCB7XG4gICAgICB2aWV3Qm94OiBcIjAgMCAxNCA4XCIsXG4gICAgICB3aWR0aDogXCIxNFwiLFxuICAgICAgaGVpZ2h0OiBcIjhcIixcbiAgICAgIGNsYXNzTmFtZTogY2FyZXRDbGFzc25hbWUsXG4gICAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChcInBhdGhcIiwge1xuICAgICAgICBkOiBkXG4gICAgICB9KVxuICAgIH0pXVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVmFsdWUocHJvcHMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvcHMucm93W3Byb3BzLmNvbHVtbi5rZXldO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5jb25zdCBEYXRhR3JpZERlZmF1bHRSZW5kZXJlcnNDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbmNvbnN0IERhdGFHcmlkRGVmYXVsdFJlbmRlcmVyc1Byb3ZpZGVyID0gRGF0YUdyaWREZWZhdWx0UmVuZGVyZXJzQ29udGV4dC5Qcm92aWRlcjtcbmZ1bmN0aW9uIHVzZURlZmF1bHRSZW5kZXJlcnMoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KERhdGFHcmlkRGVmYXVsdFJlbmRlcmVyc0NvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBTZWxlY3RDZWxsRm9ybWF0dGVyKHtcbiAgdmFsdWUsXG4gIHRhYkluZGV4LFxuICBkaXNhYmxlZCxcbiAgb25DaGFuZ2UsXG4gICdhcmlhLWxhYmVsJzogYXJpYUxhYmVsLFxuICAnYXJpYS1sYWJlbGxlZGJ5JzogYXJpYUxhYmVsbGVkQnlcbn0pIHtcbiAgY29uc3QgcmVuZGVyQ2hlY2tib3ggPSB1c2VEZWZhdWx0UmVuZGVyZXJzKCkucmVuZGVyQ2hlY2tib3g7XG4gIHJldHVybiByZW5kZXJDaGVja2JveCh7XG4gICAgJ2FyaWEtbGFiZWwnOiBhcmlhTGFiZWwsXG4gICAgJ2FyaWEtbGFiZWxsZWRieSc6IGFyaWFMYWJlbGxlZEJ5LFxuICAgIHRhYkluZGV4LFxuICAgIGRpc2FibGVkLFxuICAgIGNoZWNrZWQ6IHZhbHVlLFxuICAgIG9uQ2hhbmdlXG4gIH0pO1xufVxuXG5jb25zdCBSb3dTZWxlY3Rpb25Db250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbmNvbnN0IFJvd1NlbGVjdGlvblByb3ZpZGVyID0gUm93U2VsZWN0aW9uQ29udGV4dC5Qcm92aWRlcjtcbmNvbnN0IFJvd1NlbGVjdGlvbkNoYW5nZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuY29uc3QgUm93U2VsZWN0aW9uQ2hhbmdlUHJvdmlkZXIgPSBSb3dTZWxlY3Rpb25DaGFuZ2VDb250ZXh0LlByb3ZpZGVyO1xuZnVuY3Rpb24gdXNlUm93U2VsZWN0aW9uKCkge1xuICBjb25zdCByb3dTZWxlY3Rpb25Db250ZXh0ID0gdXNlQ29udGV4dChSb3dTZWxlY3Rpb25Db250ZXh0KTtcbiAgY29uc3Qgcm93U2VsZWN0aW9uQ2hhbmdlQ29udGV4dCA9IHVzZUNvbnRleHQoUm93U2VsZWN0aW9uQ2hhbmdlQ29udGV4dCk7XG4gIGlmIChyb3dTZWxlY3Rpb25Db250ZXh0ID09PSB1bmRlZmluZWQgfHwgcm93U2VsZWN0aW9uQ2hhbmdlQ29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VSb3dTZWxlY3Rpb24gbXVzdCBiZSB1c2VkIHdpdGhpbiBEYXRhR3JpZCBjZWxscycpO1xuICB9XG4gIHJldHVybiBbcm93U2VsZWN0aW9uQ29udGV4dCwgcm93U2VsZWN0aW9uQ2hhbmdlQ29udGV4dF07XG59XG5cbmNvbnN0IFNFTEVDVF9DT0xVTU5fS0VZID0gJ3NlbGVjdC1yb3cnO1xuZnVuY3Rpb24gSGVhZGVyUmVuZGVyZXIocHJvcHMpIHtcbiAgY29uc3QgW2lzUm93U2VsZWN0ZWQsIG9uUm93U2VsZWN0aW9uQ2hhbmdlXSA9IHVzZVJvd1NlbGVjdGlvbigpO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChTZWxlY3RDZWxsRm9ybWF0dGVyLCB7XG4gICAgXCJhcmlhLWxhYmVsXCI6IFwiU2VsZWN0IEFsbFwiLFxuICAgIHRhYkluZGV4OiBwcm9wcy50YWJJbmRleCxcbiAgICB2YWx1ZTogaXNSb3dTZWxlY3RlZCxcbiAgICBvbkNoYW5nZTogY2hlY2tlZCA9PiB7XG4gICAgICBvblJvd1NlbGVjdGlvbkNoYW5nZSh7XG4gICAgICAgIHR5cGU6ICdIRUFERVInLFxuICAgICAgICBjaGVja2VkXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gU2VsZWN0Rm9ybWF0dGVyKHByb3BzKSB7XG4gIGNvbnN0IFtpc1Jvd1NlbGVjdGVkLCBvblJvd1NlbGVjdGlvbkNoYW5nZV0gPSB1c2VSb3dTZWxlY3Rpb24oKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goU2VsZWN0Q2VsbEZvcm1hdHRlciwge1xuICAgIFwiYXJpYS1sYWJlbFwiOiBcIlNlbGVjdFwiLFxuICAgIHRhYkluZGV4OiBwcm9wcy50YWJJbmRleCxcbiAgICB2YWx1ZTogaXNSb3dTZWxlY3RlZCxcbiAgICBvbkNoYW5nZTogKGNoZWNrZWQsIGlzU2hpZnRDbGljaykgPT4ge1xuICAgICAgb25Sb3dTZWxlY3Rpb25DaGFuZ2Uoe1xuICAgICAgICB0eXBlOiAnUk9XJyxcbiAgICAgICAgcm93OiBwcm9wcy5yb3csXG4gICAgICAgIGNoZWNrZWQsXG4gICAgICAgIGlzU2hpZnRDbGlja1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIFNlbGVjdEdyb3VwRm9ybWF0dGVyKHByb3BzKSB7XG4gIGNvbnN0IFtpc1Jvd1NlbGVjdGVkLCBvblJvd1NlbGVjdGlvbkNoYW5nZV0gPSB1c2VSb3dTZWxlY3Rpb24oKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goU2VsZWN0Q2VsbEZvcm1hdHRlciwge1xuICAgIFwiYXJpYS1sYWJlbFwiOiBcIlNlbGVjdCBHcm91cFwiLFxuICAgIHRhYkluZGV4OiBwcm9wcy50YWJJbmRleCxcbiAgICB2YWx1ZTogaXNSb3dTZWxlY3RlZCxcbiAgICBvbkNoYW5nZTogY2hlY2tlZCA9PiB7XG4gICAgICBvblJvd1NlbGVjdGlvbkNoYW5nZSh7XG4gICAgICAgIHR5cGU6ICdST1cnLFxuICAgICAgICByb3c6IHByb3BzLnJvdyxcbiAgICAgICAgY2hlY2tlZCxcbiAgICAgICAgaXNTaGlmdENsaWNrOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbmNvbnN0IFNlbGVjdENvbHVtbiA9IHtcbiAga2V5OiBTRUxFQ1RfQ09MVU1OX0tFWSxcbiAgbmFtZTogJycsXG4gIHdpZHRoOiAzNSxcbiAgbWluV2lkdGg6IDM1LFxuICBtYXhXaWR0aDogMzUsXG4gIHJlc2l6YWJsZTogZmFsc2UsXG4gIHNvcnRhYmxlOiBmYWxzZSxcbiAgZnJvemVuOiB0cnVlLFxuICByZW5kZXJIZWFkZXJDZWxsKHByb3BzKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goSGVhZGVyUmVuZGVyZXIsIHtcbiAgICAgIC4uLnByb3BzXG4gICAgfSk7XG4gIH0sXG4gIHJlbmRlckNlbGwocHJvcHMpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL2pzeChTZWxlY3RGb3JtYXR0ZXIsIHtcbiAgICAgIC4uLnByb3BzXG4gICAgfSk7XG4gIH0sXG4gIHJlbmRlckdyb3VwQ2VsbChwcm9wcykge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFNlbGVjdEdyb3VwRm9ybWF0dGVyLCB7XG4gICAgICAuLi5wcm9wc1xuICAgIH0pO1xuICB9XG59O1xuXG5jb25zdCBERUZBVUxUX0NPTFVNTl9XSURUSCA9ICdhdXRvJztcbmNvbnN0IERFRkFVTFRfQ09MVU1OX01JTl9XSURUSCA9IDUwO1xuZnVuY3Rpb24gdXNlQ2FsY3VsYXRlZENvbHVtbnMoe1xuICByYXdDb2x1bW5zLFxuICBkZWZhdWx0Q29sdW1uT3B0aW9ucyxcbiAgZ2V0Q29sdW1uV2lkdGgsXG4gIHZpZXdwb3J0V2lkdGgsXG4gIHNjcm9sbExlZnQsXG4gIGVuYWJsZVZpcnR1YWxpemF0aW9uXG59KSB7XG4gIGNvbnN0IGRlZmF1bHRXaWR0aCA9IGRlZmF1bHRDb2x1bW5PcHRpb25zPy53aWR0aCA/PyBERUZBVUxUX0NPTFVNTl9XSURUSDtcbiAgY29uc3QgZGVmYXVsdE1pbldpZHRoID0gZGVmYXVsdENvbHVtbk9wdGlvbnM/Lm1pbldpZHRoID8/IERFRkFVTFRfQ09MVU1OX01JTl9XSURUSDtcbiAgY29uc3QgZGVmYXVsdE1heFdpZHRoID0gZGVmYXVsdENvbHVtbk9wdGlvbnM/Lm1heFdpZHRoID8/IHVuZGVmaW5lZDtcbiAgY29uc3QgZGVmYXVsdENlbGxSZW5kZXJlciA9IGRlZmF1bHRDb2x1bW5PcHRpb25zPy5yZW5kZXJDZWxsID8/IHJlbmRlclZhbHVlO1xuICBjb25zdCBkZWZhdWx0U29ydGFibGUgPSBkZWZhdWx0Q29sdW1uT3B0aW9ucz8uc29ydGFibGUgPz8gZmFsc2U7XG4gIGNvbnN0IGRlZmF1bHRSZXNpemFibGUgPSBkZWZhdWx0Q29sdW1uT3B0aW9ucz8ucmVzaXphYmxlID8/IGZhbHNlO1xuICBjb25zdCBkZWZhdWx0RHJhZ2dhYmxlID0gZGVmYXVsdENvbHVtbk9wdGlvbnM/LmRyYWdnYWJsZSA/PyBmYWxzZTtcbiAgY29uc3Qge1xuICAgIGNvbHVtbnMsXG4gICAgY29sU3BhbkNvbHVtbnMsXG4gICAgbGFzdEZyb3plbkNvbHVtbkluZGV4LFxuICAgIGhlYWRlclJvd3NDb3VudFxuICB9ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IGxhc3RGcm96ZW5Db2x1bW5JbmRleCA9IC0xO1xuICAgIGxldCBoZWFkZXJSb3dzQ291bnQgPSAxO1xuICAgIGNvbnN0IGNvbHVtbnMgPSBbXTtcbiAgICBjb2xsZWN0Q29sdW1ucyhyYXdDb2x1bW5zLCAxKTtcbiAgICBmdW5jdGlvbiBjb2xsZWN0Q29sdW1ucyhyYXdDb2x1bW5zLCBsZXZlbCwgcGFyZW50KSB7XG4gICAgICBmb3IgKGNvbnN0IHJhd0NvbHVtbiBvZiByYXdDb2x1bW5zKSB7XG4gICAgICAgIGlmICgnY2hpbGRyZW4nIGluIHJhd0NvbHVtbikge1xuICAgICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRDb2x1bW5QYXJlbnQgPSB7XG4gICAgICAgICAgICBuYW1lOiByYXdDb2x1bW4ubmFtZSxcbiAgICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICAgIGlkeDogLTEsXG4gICAgICAgICAgICBjb2xTcGFuOiAwLFxuICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICBoZWFkZXJDZWxsQ2xhc3M6IHJhd0NvbHVtbi5oZWFkZXJDZWxsQ2xhc3NcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbGxlY3RDb2x1bW5zKHJhd0NvbHVtbi5jaGlsZHJlbiwgbGV2ZWwgKyAxLCBjYWxjdWxhdGVkQ29sdW1uUGFyZW50KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcm96ZW4gPSByYXdDb2x1bW4uZnJvemVuID8/IGZhbHNlO1xuICAgICAgICBjb25zdCBjb2x1bW4gPSB7XG4gICAgICAgICAgLi4ucmF3Q29sdW1uLFxuICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICBpZHg6IDAsXG4gICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgZnJvemVuLFxuICAgICAgICAgIHdpZHRoOiByYXdDb2x1bW4ud2lkdGggPz8gZGVmYXVsdFdpZHRoLFxuICAgICAgICAgIG1pbldpZHRoOiByYXdDb2x1bW4ubWluV2lkdGggPz8gZGVmYXVsdE1pbldpZHRoLFxuICAgICAgICAgIG1heFdpZHRoOiByYXdDb2x1bW4ubWF4V2lkdGggPz8gZGVmYXVsdE1heFdpZHRoLFxuICAgICAgICAgIHNvcnRhYmxlOiByYXdDb2x1bW4uc29ydGFibGUgPz8gZGVmYXVsdFNvcnRhYmxlLFxuICAgICAgICAgIHJlc2l6YWJsZTogcmF3Q29sdW1uLnJlc2l6YWJsZSA/PyBkZWZhdWx0UmVzaXphYmxlLFxuICAgICAgICAgIGRyYWdnYWJsZTogcmF3Q29sdW1uLmRyYWdnYWJsZSA/PyBkZWZhdWx0RHJhZ2dhYmxlLFxuICAgICAgICAgIHJlbmRlckNlbGw6IHJhd0NvbHVtbi5yZW5kZXJDZWxsID8/IGRlZmF1bHRDZWxsUmVuZGVyZXJcbiAgICAgICAgfTtcbiAgICAgICAgY29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgIGlmIChmcm96ZW4pIHtcbiAgICAgICAgICBsYXN0RnJvemVuQ29sdW1uSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGV2ZWwgPiBoZWFkZXJSb3dzQ291bnQpIHtcbiAgICAgICAgICBoZWFkZXJSb3dzQ291bnQgPSBsZXZlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb2x1bW5zLnNvcnQoKHtcbiAgICAgIGtleTogYUtleSxcbiAgICAgIGZyb3plbjogZnJvemVuQVxuICAgIH0sIHtcbiAgICAgIGtleTogYktleSxcbiAgICAgIGZyb3plbjogZnJvemVuQlxuICAgIH0pID0+IHtcbiAgICAgIGlmIChhS2V5ID09PSBTRUxFQ1RfQ09MVU1OX0tFWSkgcmV0dXJuIC0xO1xuICAgICAgaWYgKGJLZXkgPT09IFNFTEVDVF9DT0xVTU5fS0VZKSByZXR1cm4gMTtcbiAgICAgIGlmIChmcm96ZW5BKSB7XG4gICAgICAgIGlmIChmcm96ZW5CKSByZXR1cm4gMDtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKGZyb3plbkIpIHJldHVybiAxO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG4gICAgY29uc3QgY29sU3BhbkNvbHVtbnMgPSBbXTtcbiAgICBjb2x1bW5zLmZvckVhY2goKGNvbHVtbiwgaWR4KSA9PiB7XG4gICAgICBjb2x1bW4uaWR4ID0gaWR4O1xuICAgICAgdXBkYXRlQ29sdW1uUGFyZW50KGNvbHVtbiwgaWR4LCAwKTtcbiAgICAgIGlmIChjb2x1bW4uY29sU3BhbiAhPSBudWxsKSB7XG4gICAgICAgIGNvbFNwYW5Db2x1bW5zLnB1c2goY29sdW1uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1ucyxcbiAgICAgIGNvbFNwYW5Db2x1bW5zLFxuICAgICAgbGFzdEZyb3plbkNvbHVtbkluZGV4LFxuICAgICAgaGVhZGVyUm93c0NvdW50XG4gICAgfTtcbiAgfSwgW3Jhd0NvbHVtbnMsIGRlZmF1bHRXaWR0aCwgZGVmYXVsdE1pbldpZHRoLCBkZWZhdWx0TWF4V2lkdGgsIGRlZmF1bHRDZWxsUmVuZGVyZXIsIGRlZmF1bHRSZXNpemFibGUsIGRlZmF1bHRTb3J0YWJsZSwgZGVmYXVsdERyYWdnYWJsZV0pO1xuICBjb25zdCB7XG4gICAgdGVtcGxhdGVDb2x1bW5zLFxuICAgIGxheW91dENzc1ZhcnMsXG4gICAgdG90YWxGcm96ZW5Db2x1bW5XaWR0aCxcbiAgICBjb2x1bW5NZXRyaWNzXG4gIH0gPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBjb2x1bW5NZXRyaWNzID0gbmV3IE1hcCgpO1xuICAgIGxldCBsZWZ0ID0gMDtcbiAgICBsZXQgdG90YWxGcm96ZW5Db2x1bW5XaWR0aCA9IDA7XG4gICAgY29uc3QgdGVtcGxhdGVDb2x1bW5zID0gW107XG4gICAgZm9yIChjb25zdCBjb2x1bW4gb2YgY29sdW1ucykge1xuICAgICAgbGV0IHdpZHRoID0gZ2V0Q29sdW1uV2lkdGgoY29sdW1uKTtcbiAgICAgIGlmICh0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgIHdpZHRoID0gY2xhbXBDb2x1bW5XaWR0aCh3aWR0aCwgY29sdW1uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoID0gY29sdW1uLm1pbldpZHRoO1xuICAgICAgfVxuICAgICAgdGVtcGxhdGVDb2x1bW5zLnB1c2goYCR7d2lkdGh9cHhgKTtcbiAgICAgIGNvbHVtbk1ldHJpY3Muc2V0KGNvbHVtbiwge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgbGVmdFxuICAgICAgfSk7XG4gICAgICBsZWZ0ICs9IHdpZHRoO1xuICAgIH1cbiAgICBpZiAobGFzdEZyb3plbkNvbHVtbkluZGV4ICE9PSAtMSkge1xuICAgICAgY29uc3QgY29sdW1uTWV0cmljID0gY29sdW1uTWV0cmljcy5nZXQoY29sdW1uc1tsYXN0RnJvemVuQ29sdW1uSW5kZXhdKTtcbiAgICAgIHRvdGFsRnJvemVuQ29sdW1uV2lkdGggPSBjb2x1bW5NZXRyaWMubGVmdCArIGNvbHVtbk1ldHJpYy53aWR0aDtcbiAgICB9XG4gICAgY29uc3QgbGF5b3V0Q3NzVmFycyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGxhc3RGcm96ZW5Db2x1bW5JbmRleDsgaSsrKSB7XG4gICAgICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zW2ldO1xuICAgICAgbGF5b3V0Q3NzVmFyc1tgLS1yZGctZnJvemVuLWxlZnQtJHtjb2x1bW4uaWR4fWBdID0gYCR7Y29sdW1uTWV0cmljcy5nZXQoY29sdW1uKS5sZWZ0fXB4YDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRlbXBsYXRlQ29sdW1ucyxcbiAgICAgIGxheW91dENzc1ZhcnMsXG4gICAgICB0b3RhbEZyb3plbkNvbHVtbldpZHRoLFxuICAgICAgY29sdW1uTWV0cmljc1xuICAgIH07XG4gIH0sIFtnZXRDb2x1bW5XaWR0aCwgY29sdW1ucywgbGFzdEZyb3plbkNvbHVtbkluZGV4XSk7XG4gIGNvbnN0IFtjb2xPdmVyc2NhblN0YXJ0SWR4LCBjb2xPdmVyc2NhbkVuZElkeF0gPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZVZpcnR1YWxpemF0aW9uKSB7XG4gICAgICByZXR1cm4gWzAsIGNvbHVtbnMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGNvbnN0IHZpZXdwb3J0TGVmdCA9IHNjcm9sbExlZnQgKyB0b3RhbEZyb3plbkNvbHVtbldpZHRoO1xuICAgIGNvbnN0IHZpZXdwb3J0UmlnaHQgPSBzY3JvbGxMZWZ0ICsgdmlld3BvcnRXaWR0aDtcbiAgICBjb25zdCBsYXN0Q29sSWR4ID0gY29sdW1ucy5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGZpcnN0VW5mcm96ZW5Db2x1bW5JZHggPSBtaW4obGFzdEZyb3plbkNvbHVtbkluZGV4ICsgMSwgbGFzdENvbElkeCk7XG4gICAgaWYgKHZpZXdwb3J0TGVmdCA+PSB2aWV3cG9ydFJpZ2h0KSB7XG4gICAgICByZXR1cm4gW2ZpcnN0VW5mcm96ZW5Db2x1bW5JZHgsIGZpcnN0VW5mcm96ZW5Db2x1bW5JZHhdO1xuICAgIH1cbiAgICBsZXQgY29sVmlzaWJsZVN0YXJ0SWR4ID0gZmlyc3RVbmZyb3plbkNvbHVtbklkeDtcbiAgICB3aGlsZSAoY29sVmlzaWJsZVN0YXJ0SWR4IDwgbGFzdENvbElkeCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsZWZ0LFxuICAgICAgICB3aWR0aFxuICAgICAgfSA9IGNvbHVtbk1ldHJpY3MuZ2V0KGNvbHVtbnNbY29sVmlzaWJsZVN0YXJ0SWR4XSk7XG4gICAgICBpZiAobGVmdCArIHdpZHRoID4gdmlld3BvcnRMZWZ0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29sVmlzaWJsZVN0YXJ0SWR4Kys7XG4gICAgfVxuICAgIGxldCBjb2xWaXNpYmxlRW5kSWR4ID0gY29sVmlzaWJsZVN0YXJ0SWR4O1xuICAgIHdoaWxlIChjb2xWaXNpYmxlRW5kSWR4IDwgbGFzdENvbElkeCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsZWZ0LFxuICAgICAgICB3aWR0aFxuICAgICAgfSA9IGNvbHVtbk1ldHJpY3MuZ2V0KGNvbHVtbnNbY29sVmlzaWJsZUVuZElkeF0pO1xuICAgICAgaWYgKGxlZnQgKyB3aWR0aCA+PSB2aWV3cG9ydFJpZ2h0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29sVmlzaWJsZUVuZElkeCsrO1xuICAgIH1cbiAgICBjb25zdCBjb2xPdmVyc2NhblN0YXJ0SWR4ID0gbWF4KGZpcnN0VW5mcm96ZW5Db2x1bW5JZHgsIGNvbFZpc2libGVTdGFydElkeCAtIDEpO1xuICAgIGNvbnN0IGNvbE92ZXJzY2FuRW5kSWR4ID0gbWluKGxhc3RDb2xJZHgsIGNvbFZpc2libGVFbmRJZHggKyAxKTtcbiAgICByZXR1cm4gW2NvbE92ZXJzY2FuU3RhcnRJZHgsIGNvbE92ZXJzY2FuRW5kSWR4XTtcbiAgfSwgW2NvbHVtbk1ldHJpY3MsIGNvbHVtbnMsIGxhc3RGcm96ZW5Db2x1bW5JbmRleCwgc2Nyb2xsTGVmdCwgdG90YWxGcm96ZW5Db2x1bW5XaWR0aCwgdmlld3BvcnRXaWR0aCwgZW5hYmxlVmlydHVhbGl6YXRpb25dKTtcbiAgcmV0dXJuIHtcbiAgICBjb2x1bW5zLFxuICAgIGNvbFNwYW5Db2x1bW5zLFxuICAgIGNvbE92ZXJzY2FuU3RhcnRJZHgsXG4gICAgY29sT3ZlcnNjYW5FbmRJZHgsXG4gICAgdGVtcGxhdGVDb2x1bW5zLFxuICAgIGxheW91dENzc1ZhcnMsXG4gICAgaGVhZGVyUm93c0NvdW50LFxuICAgIGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgICB0b3RhbEZyb3plbkNvbHVtbldpZHRoXG4gIH07XG59XG5mdW5jdGlvbiB1cGRhdGVDb2x1bW5QYXJlbnQoY29sdW1uLCBpbmRleCwgbGV2ZWwpIHtcbiAgaWYgKGxldmVsIDwgY29sdW1uLmxldmVsKSB7XG4gICAgY29sdW1uLmxldmVsID0gbGV2ZWw7XG4gIH1cbiAgaWYgKGNvbHVtbi5wYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmVudFxuICAgIH0gPSBjb2x1bW47XG4gICAgaWYgKHBhcmVudC5pZHggPT09IC0xKSB7XG4gICAgICBwYXJlbnQuaWR4ID0gaW5kZXg7XG4gICAgfVxuICAgIHBhcmVudC5jb2xTcGFuICs9IDE7XG4gICAgdXBkYXRlQ29sdW1uUGFyZW50KHBhcmVudCwgaW5kZXgsIGxldmVsIC0gMSk7XG4gIH1cbn1cblxuY29uc3QgdXNlTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyB1c2VFZmZlY3QgOiB1c2VMYXlvdXRFZmZlY3QkMTtcblxuZnVuY3Rpb24gdXNlQ29sdW1uV2lkdGhzKGNvbHVtbnMsIHZpZXdwb3J0Q29sdW1ucywgdGVtcGxhdGVDb2x1bW5zLCBncmlkUmVmLCBncmlkV2lkdGgsIHJlc2l6ZWRDb2x1bW5XaWR0aHMsIG1lYXN1cmVkQ29sdW1uV2lkdGhzLCBzZXRSZXNpemVkQ29sdW1uV2lkdGhzLCBzZXRNZWFzdXJlZENvbHVtbldpZHRocywgb25Db2x1bW5SZXNpemUpIHtcbiAgY29uc3QgcHJldkdyaWRXaWR0aFJlZiA9IHVzZVJlZihncmlkV2lkdGgpO1xuICBjb25zdCBjb2x1bW5zQ2FuRmxleCA9IGNvbHVtbnMubGVuZ3RoID09PSB2aWV3cG9ydENvbHVtbnMubGVuZ3RoO1xuICBjb25zdCBpZ25vcmVQcmV2aW91c2x5TWVhc3VyZWRDb2x1bW5zID0gY29sdW1uc0NhbkZsZXggJiYgZ3JpZFdpZHRoICE9PSBwcmV2R3JpZFdpZHRoUmVmLmN1cnJlbnQ7XG4gIGNvbnN0IG5ld1RlbXBsYXRlQ29sdW1ucyA9IFsuLi50ZW1wbGF0ZUNvbHVtbnNdO1xuICBjb25zdCBjb2x1bW5zVG9NZWFzdXJlID0gW107XG4gIGZvciAoY29uc3Qge1xuICAgIGtleSxcbiAgICBpZHgsXG4gICAgd2lkdGhcbiAgfSBvZiB2aWV3cG9ydENvbHVtbnMpIHtcbiAgICBpZiAodHlwZW9mIHdpZHRoID09PSAnc3RyaW5nJyAmJiAoaWdub3JlUHJldmlvdXNseU1lYXN1cmVkQ29sdW1ucyB8fCAhbWVhc3VyZWRDb2x1bW5XaWR0aHMuaGFzKGtleSkpICYmICFyZXNpemVkQ29sdW1uV2lkdGhzLmhhcyhrZXkpKSB7XG4gICAgICBuZXdUZW1wbGF0ZUNvbHVtbnNbaWR4XSA9IHdpZHRoO1xuICAgICAgY29sdW1uc1RvTWVhc3VyZS5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGdyaWRUZW1wbGF0ZUNvbHVtbnMgPSBuZXdUZW1wbGF0ZUNvbHVtbnMuam9pbignICcpO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHByZXZHcmlkV2lkdGhSZWYuY3VycmVudCA9IGdyaWRXaWR0aDtcbiAgICB1cGRhdGVNZWFzdXJlZFdpZHRocyhjb2x1bW5zVG9NZWFzdXJlKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIHVwZGF0ZU1lYXN1cmVkV2lkdGhzKGNvbHVtbnNUb01lYXN1cmUpIHtcbiAgICBpZiAoY29sdW1uc1RvTWVhc3VyZS5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBzZXRNZWFzdXJlZENvbHVtbldpZHRocyhtZWFzdXJlZENvbHVtbldpZHRocyA9PiB7XG4gICAgICBjb25zdCBuZXdNZWFzdXJlZENvbHVtbldpZHRocyA9IG5ldyBNYXAobWVhc3VyZWRDb2x1bW5XaWR0aHMpO1xuICAgICAgbGV0IGhhc0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGNvbHVtbnNUb01lYXN1cmUpIHtcbiAgICAgICAgY29uc3QgbWVhc3VyZWRXaWR0aCA9IG1lYXN1cmVDb2x1bW5XaWR0aChncmlkUmVmLCBrZXkpO1xuICAgICAgICBoYXNDaGFuZ2VzIHx8PSBtZWFzdXJlZFdpZHRoICE9PSBtZWFzdXJlZENvbHVtbldpZHRocy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKG1lYXN1cmVkV2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5ld01lYXN1cmVkQ29sdW1uV2lkdGhzLmRlbGV0ZShrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld01lYXN1cmVkQ29sdW1uV2lkdGhzLnNldChrZXksIG1lYXN1cmVkV2lkdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzQ2hhbmdlcyA/IG5ld01lYXN1cmVkQ29sdW1uV2lkdGhzIDogbWVhc3VyZWRDb2x1bW5XaWR0aHM7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlQ29sdW1uUmVzaXplKGNvbHVtbiwgbmV4dFdpZHRoKSB7XG4gICAgY29uc3Qge1xuICAgICAga2V5OiByZXNpemluZ0tleVxuICAgIH0gPSBjb2x1bW47XG4gICAgY29uc3QgbmV3VGVtcGxhdGVDb2x1bW5zID0gWy4uLnRlbXBsYXRlQ29sdW1uc107XG4gICAgY29uc3QgY29sdW1uc1RvTWVhc3VyZSA9IFtdO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAga2V5LFxuICAgICAgaWR4LFxuICAgICAgd2lkdGhcbiAgICB9IG9mIHZpZXdwb3J0Q29sdW1ucykge1xuICAgICAgaWYgKHJlc2l6aW5nS2V5ID09PSBrZXkpIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0eXBlb2YgbmV4dFdpZHRoID09PSAnbnVtYmVyJyA/IGAke25leHRXaWR0aH1weGAgOiBuZXh0V2lkdGg7XG4gICAgICAgIG5ld1RlbXBsYXRlQ29sdW1uc1tpZHhdID0gd2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKGNvbHVtbnNDYW5GbGV4ICYmIHR5cGVvZiB3aWR0aCA9PT0gJ3N0cmluZycgJiYgIXJlc2l6ZWRDb2x1bW5XaWR0aHMuaGFzKGtleSkpIHtcbiAgICAgICAgbmV3VGVtcGxhdGVDb2x1bW5zW2lkeF0gPSB3aWR0aDtcbiAgICAgICAgY29sdW1uc1RvTWVhc3VyZS5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGdyaWRSZWYuY3VycmVudC5zdHlsZS5ncmlkVGVtcGxhdGVDb2x1bW5zID0gbmV3VGVtcGxhdGVDb2x1bW5zLmpvaW4oJyAnKTtcbiAgICBjb25zdCBtZWFzdXJlZFdpZHRoID0gdHlwZW9mIG5leHRXaWR0aCA9PT0gJ251bWJlcicgPyBuZXh0V2lkdGggOiBtZWFzdXJlQ29sdW1uV2lkdGgoZ3JpZFJlZiwgcmVzaXppbmdLZXkpO1xuICAgIGZsdXNoU3luYygoKSA9PiB7XG4gICAgICBzZXRSZXNpemVkQ29sdW1uV2lkdGhzKHJlc2l6ZWRDb2x1bW5XaWR0aHMgPT4ge1xuICAgICAgICBjb25zdCBuZXdSZXNpemVkQ29sdW1uV2lkdGhzID0gbmV3IE1hcChyZXNpemVkQ29sdW1uV2lkdGhzKTtcbiAgICAgICAgbmV3UmVzaXplZENvbHVtbldpZHRocy5zZXQocmVzaXppbmdLZXksIG1lYXN1cmVkV2lkdGgpO1xuICAgICAgICByZXR1cm4gbmV3UmVzaXplZENvbHVtbldpZHRocztcbiAgICAgIH0pO1xuICAgICAgdXBkYXRlTWVhc3VyZWRXaWR0aHMoY29sdW1uc1RvTWVhc3VyZSk7XG4gICAgfSk7XG4gICAgb25Db2x1bW5SZXNpemU/Lihjb2x1bW4uaWR4LCBtZWFzdXJlZFdpZHRoKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdyaWRUZW1wbGF0ZUNvbHVtbnMsXG4gICAgaGFuZGxlQ29sdW1uUmVzaXplXG4gIH07XG59XG5mdW5jdGlvbiBtZWFzdXJlQ29sdW1uV2lkdGgoZ3JpZFJlZiwga2V5KSB7XG4gIGNvbnN0IHNlbGVjdG9yID0gYFtkYXRhLW1lYXN1cmluZy1jZWxsLWtleT1cIiR7Q1NTLmVzY2FwZShrZXkpfVwiXWA7XG4gIGNvbnN0IG1lYXN1cmluZ0NlbGwgPSBncmlkUmVmLmN1cnJlbnQ/LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICByZXR1cm4gbWVhc3VyaW5nQ2VsbD8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG59XG5cbmZ1bmN0aW9uIHVzZUdyaWREaW1lbnNpb25zKCkge1xuICBjb25zdCBncmlkUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbaW5saW5lU2l6ZSwgc2V0SW5saW5lU2l6ZV0gPSB1c2VTdGF0ZSgxKTtcbiAgY29uc3QgW2Jsb2NrU2l6ZSwgc2V0QmxvY2tTaXplXSA9IHVzZVN0YXRlKDEpO1xuICBjb25zdCBbaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCwgc2V0SG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodF0gPSB1c2VTdGF0ZSgwKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBSZXNpemVPYnNlcnZlclxuICAgIH0gPSB3aW5kb3c7XG4gICAgaWYgKFJlc2l6ZU9ic2VydmVyID09IG51bGwpIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBjbGllbnRXaWR0aCxcbiAgICAgIGNsaWVudEhlaWdodCxcbiAgICAgIG9mZnNldFdpZHRoLFxuICAgICAgb2Zmc2V0SGVpZ2h0XG4gICAgfSA9IGdyaWRSZWYuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBncmlkUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgaW5pdGlhbEhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQgPSBvZmZzZXRIZWlnaHQgLSBjbGllbnRIZWlnaHQ7XG4gICAgY29uc3QgaW5pdGlhbFdpZHRoID0gd2lkdGggLSBvZmZzZXRXaWR0aCArIGNsaWVudFdpZHRoO1xuICAgIGNvbnN0IGluaXRpYWxIZWlnaHQgPSBoZWlnaHQgLSBpbml0aWFsSG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodDtcbiAgICBzZXRJbmxpbmVTaXplKGluaXRpYWxXaWR0aCk7XG4gICAgc2V0QmxvY2tTaXplKGluaXRpYWxIZWlnaHQpO1xuICAgIHNldEhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQoaW5pdGlhbEhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQpO1xuICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgY29uc3Qgc2l6ZSA9IGVudHJpZXNbMF0uY29udGVudEJveFNpemVbMF07XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsaWVudEhlaWdodCxcbiAgICAgICAgb2Zmc2V0SGVpZ2h0XG4gICAgICB9ID0gZ3JpZFJlZi5jdXJyZW50O1xuICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgc2V0SW5saW5lU2l6ZShzaXplLmlubGluZVNpemUpO1xuICAgICAgICBzZXRCbG9ja1NpemUoc2l6ZS5ibG9ja1NpemUpO1xuICAgICAgICBzZXRIb3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0KG9mZnNldEhlaWdodCAtIGNsaWVudEhlaWdodCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGdyaWRSZWYuY3VycmVudCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBbZ3JpZFJlZiwgaW5saW5lU2l6ZSwgYmxvY2tTaXplLCBob3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0XTtcbn1cblxuZnVuY3Rpb24gdXNlTGF0ZXN0RnVuYyhmbikge1xuICBjb25zdCByZWYgPSB1c2VSZWYoZm4pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gZm47XG4gIH0pO1xuICBjb25zdCBjYWxsYmFja0ZuID0gdXNlQ2FsbGJhY2soKC4uLmFyZ3MpID0+IHtcbiAgICByZWYuY3VycmVudCguLi5hcmdzKTtcbiAgfSwgW10pO1xuICByZXR1cm4gZm4gPyBjYWxsYmFja0ZuIDogZm47XG59XG5cbmZ1bmN0aW9uIHVzZVJvdmluZ1RhYkluZGV4KGlzU2VsZWN0ZWQpIHtcbiAgY29uc3QgW2lzQ2hpbGRGb2N1c2VkLCBzZXRJc0NoaWxkRm9jdXNlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGlmIChpc0NoaWxkRm9jdXNlZCAmJiAhaXNTZWxlY3RlZCkge1xuICAgIHNldElzQ2hpbGRGb2N1c2VkKGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBvbkZvY3VzKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gZXZlbnQuY3VycmVudFRhcmdldCkge1xuICAgICAgc2V0SXNDaGlsZEZvY3VzZWQodHJ1ZSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGlzRm9jdXNhYmxlID0gaXNTZWxlY3RlZCAmJiAhaXNDaGlsZEZvY3VzZWQ7XG4gIHJldHVybiB7XG4gICAgdGFiSW5kZXg6IGlzRm9jdXNhYmxlID8gMCA6IC0xLFxuICAgIGNoaWxkVGFiSW5kZXg6IGlzU2VsZWN0ZWQgPyAwIDogLTEsXG4gICAgb25Gb2N1czogaXNTZWxlY3RlZCA/IG9uRm9jdXMgOiB1bmRlZmluZWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlVmlld3BvcnRDb2x1bW5zKHtcbiAgY29sdW1ucyxcbiAgY29sU3BhbkNvbHVtbnMsXG4gIHJvd3MsXG4gIHRvcFN1bW1hcnlSb3dzLFxuICBib3R0b21TdW1tYXJ5Um93cyxcbiAgY29sT3ZlcnNjYW5TdGFydElkeCxcbiAgY29sT3ZlcnNjYW5FbmRJZHgsXG4gIGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgcm93T3ZlcnNjYW5TdGFydElkeCxcbiAgcm93T3ZlcnNjYW5FbmRJZHhcbn0pIHtcbiAgY29uc3Qgc3RhcnRJZHggPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoY29sT3ZlcnNjYW5TdGFydElkeCA9PT0gMCkgcmV0dXJuIDA7XG4gICAgbGV0IHN0YXJ0SWR4ID0gY29sT3ZlcnNjYW5TdGFydElkeDtcbiAgICBjb25zdCB1cGRhdGVTdGFydElkeCA9IChjb2xJZHgsIGNvbFNwYW4pID0+IHtcbiAgICAgIGlmIChjb2xTcGFuICE9PSB1bmRlZmluZWQgJiYgY29sSWR4ICsgY29sU3BhbiA+IGNvbE92ZXJzY2FuU3RhcnRJZHgpIHtcbiAgICAgICAgc3RhcnRJZHggPSBjb2xJZHg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgZm9yIChjb25zdCBjb2x1bW4gb2YgY29sU3BhbkNvbHVtbnMpIHtcbiAgICAgIGNvbnN0IGNvbElkeCA9IGNvbHVtbi5pZHg7XG4gICAgICBpZiAoY29sSWR4ID49IHN0YXJ0SWR4KSBicmVhaztcbiAgICAgIGlmICh1cGRhdGVTdGFydElkeChjb2xJZHgsIGdldENvbFNwYW4oY29sdW1uLCBsYXN0RnJvemVuQ29sdW1uSW5kZXgsIHtcbiAgICAgICAgdHlwZTogJ0hFQURFUidcbiAgICAgIH0pKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHJvd0lkeCA9IHJvd092ZXJzY2FuU3RhcnRJZHg7IHJvd0lkeCA8PSByb3dPdmVyc2NhbkVuZElkeDsgcm93SWR4KyspIHtcbiAgICAgICAgY29uc3Qgcm93ID0gcm93c1tyb3dJZHhdO1xuICAgICAgICBpZiAodXBkYXRlU3RhcnRJZHgoY29sSWR4LCBnZXRDb2xTcGFuKGNvbHVtbiwgbGFzdEZyb3plbkNvbHVtbkluZGV4LCB7XG4gICAgICAgICAgdHlwZTogJ1JPVycsXG4gICAgICAgICAgcm93XG4gICAgICAgIH0pKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodG9wU3VtbWFyeVJvd3MgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0b3BTdW1tYXJ5Um93cykge1xuICAgICAgICAgIGlmICh1cGRhdGVTdGFydElkeChjb2xJZHgsIGdldENvbFNwYW4oY29sdW1uLCBsYXN0RnJvemVuQ29sdW1uSW5kZXgsIHtcbiAgICAgICAgICAgIHR5cGU6ICdTVU1NQVJZJyxcbiAgICAgICAgICAgIHJvd1xuICAgICAgICAgIH0pKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYm90dG9tU3VtbWFyeVJvd3MgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiBib3R0b21TdW1tYXJ5Um93cykge1xuICAgICAgICAgIGlmICh1cGRhdGVTdGFydElkeChjb2xJZHgsIGdldENvbFNwYW4oY29sdW1uLCBsYXN0RnJvemVuQ29sdW1uSW5kZXgsIHtcbiAgICAgICAgICAgIHR5cGU6ICdTVU1NQVJZJyxcbiAgICAgICAgICAgIHJvd1xuICAgICAgICAgIH0pKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGFydElkeDtcbiAgfSwgW3Jvd092ZXJzY2FuU3RhcnRJZHgsIHJvd092ZXJzY2FuRW5kSWR4LCByb3dzLCB0b3BTdW1tYXJ5Um93cywgYm90dG9tU3VtbWFyeVJvd3MsIGNvbE92ZXJzY2FuU3RhcnRJZHgsIGxhc3RGcm96ZW5Db2x1bW5JbmRleCwgY29sU3BhbkNvbHVtbnNdKTtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHZpZXdwb3J0Q29sdW1ucyA9IFtdO1xuICAgIGZvciAobGV0IGNvbElkeCA9IDA7IGNvbElkeCA8PSBjb2xPdmVyc2NhbkVuZElkeDsgY29sSWR4KyspIHtcbiAgICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnNbY29sSWR4XTtcbiAgICAgIGlmIChjb2xJZHggPCBzdGFydElkeCAmJiAhY29sdW1uLmZyb3plbikgY29udGludWU7XG4gICAgICB2aWV3cG9ydENvbHVtbnMucHVzaChjb2x1bW4pO1xuICAgIH1cbiAgICByZXR1cm4gdmlld3BvcnRDb2x1bW5zO1xuICB9LCBbc3RhcnRJZHgsIGNvbE92ZXJzY2FuRW5kSWR4LCBjb2x1bW5zXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVZpZXdwb3J0Um93cyh7XG4gIHJvd3MsXG4gIHJvd0hlaWdodCxcbiAgY2xpZW50SGVpZ2h0LFxuICBzY3JvbGxUb3AsXG4gIGVuYWJsZVZpcnR1YWxpemF0aW9uXG59KSB7XG4gIGNvbnN0IHtcbiAgICB0b3RhbFJvd0hlaWdodCxcbiAgICBncmlkVGVtcGxhdGVSb3dzLFxuICAgIGdldFJvd1RvcCxcbiAgICBnZXRSb3dIZWlnaHQsXG4gICAgZmluZFJvd0lkeFxuICB9ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiByb3dIZWlnaHQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3RhbFJvd0hlaWdodDogcm93SGVpZ2h0ICogcm93cy5sZW5ndGgsXG4gICAgICAgIGdyaWRUZW1wbGF0ZVJvd3M6IGAgcmVwZWF0KCR7cm93cy5sZW5ndGh9LCAke3Jvd0hlaWdodH1weClgLFxuICAgICAgICBnZXRSb3dUb3A6IHJvd0lkeCA9PiByb3dJZHggKiByb3dIZWlnaHQsXG4gICAgICAgIGdldFJvd0hlaWdodDogKCkgPT4gcm93SGVpZ2h0LFxuICAgICAgICBmaW5kUm93SWR4OiBvZmZzZXQgPT4gZmxvb3Iob2Zmc2V0IC8gcm93SGVpZ2h0KVxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHRvdGFsUm93SGVpZ2h0ID0gMDtcbiAgICBsZXQgZ3JpZFRlbXBsYXRlUm93cyA9ICcgJztcbiAgICBjb25zdCByb3dQb3NpdGlvbnMgPSByb3dzLm1hcChyb3cgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFJvd0hlaWdodCA9IHJvd0hlaWdodChyb3cpO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSB7XG4gICAgICAgIHRvcDogdG90YWxSb3dIZWlnaHQsXG4gICAgICAgIGhlaWdodDogY3VycmVudFJvd0hlaWdodFxuICAgICAgfTtcbiAgICAgIGdyaWRUZW1wbGF0ZVJvd3MgKz0gYCR7Y3VycmVudFJvd0hlaWdodH1weCBgO1xuICAgICAgdG90YWxSb3dIZWlnaHQgKz0gY3VycmVudFJvd0hlaWdodDtcbiAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9KTtcbiAgICBjb25zdCB2YWxpZGF0ZVJvd0lkeCA9IHJvd0lkeCA9PiB7XG4gICAgICByZXR1cm4gbWF4KDAsIG1pbihyb3dzLmxlbmd0aCAtIDEsIHJvd0lkeCkpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsUm93SGVpZ2h0LFxuICAgICAgZ3JpZFRlbXBsYXRlUm93cyxcbiAgICAgIGdldFJvd1RvcDogcm93SWR4ID0+IHJvd1Bvc2l0aW9uc1t2YWxpZGF0ZVJvd0lkeChyb3dJZHgpXS50b3AsXG4gICAgICBnZXRSb3dIZWlnaHQ6IHJvd0lkeCA9PiByb3dQb3NpdGlvbnNbdmFsaWRhdGVSb3dJZHgocm93SWR4KV0uaGVpZ2h0LFxuICAgICAgZmluZFJvd0lkeChvZmZzZXQpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IGVuZCA9IHJvd1Bvc2l0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgICAgICAgY29uc3QgbWlkZGxlID0gc3RhcnQgKyBmbG9vcigoZW5kIC0gc3RhcnQpIC8gMik7XG4gICAgICAgICAgY29uc3QgY3VycmVudE9mZnNldCA9IHJvd1Bvc2l0aW9uc1ttaWRkbGVdLnRvcDtcbiAgICAgICAgICBpZiAoY3VycmVudE9mZnNldCA9PT0gb2Zmc2V0KSByZXR1cm4gbWlkZGxlO1xuICAgICAgICAgIGlmIChjdXJyZW50T2Zmc2V0IDwgb2Zmc2V0KSB7XG4gICAgICAgICAgICBzdGFydCA9IG1pZGRsZSArIDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50T2Zmc2V0ID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICBlbmQgPSBtaWRkbGUgLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3Jvd0hlaWdodCwgcm93c10pO1xuICBsZXQgcm93T3ZlcnNjYW5TdGFydElkeCA9IDA7XG4gIGxldCByb3dPdmVyc2NhbkVuZElkeCA9IHJvd3MubGVuZ3RoIC0gMTtcbiAgaWYgKGVuYWJsZVZpcnR1YWxpemF0aW9uKSB7XG4gICAgY29uc3Qgb3ZlcnNjYW5UaHJlc2hvbGQgPSA0O1xuICAgIGNvbnN0IHJvd1Zpc2libGVTdGFydElkeCA9IGZpbmRSb3dJZHgoc2Nyb2xsVG9wKTtcbiAgICBjb25zdCByb3dWaXNpYmxlRW5kSWR4ID0gZmluZFJvd0lkeChzY3JvbGxUb3AgKyBjbGllbnRIZWlnaHQpO1xuICAgIHJvd092ZXJzY2FuU3RhcnRJZHggPSBtYXgoMCwgcm93VmlzaWJsZVN0YXJ0SWR4IC0gb3ZlcnNjYW5UaHJlc2hvbGQpO1xuICAgIHJvd092ZXJzY2FuRW5kSWR4ID0gbWluKHJvd3MubGVuZ3RoIC0gMSwgcm93VmlzaWJsZUVuZElkeCArIG92ZXJzY2FuVGhyZXNob2xkKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJvd092ZXJzY2FuU3RhcnRJZHgsXG4gICAgcm93T3ZlcnNjYW5FbmRJZHgsXG4gICAgdG90YWxSb3dIZWlnaHQsXG4gICAgZ3JpZFRlbXBsYXRlUm93cyxcbiAgICBnZXRSb3dUb3AsXG4gICAgZ2V0Um93SGVpZ2h0LFxuICAgIGZpbmRSb3dJZHhcbiAgfTtcbn1cblxuY29uc3QgY2VsbERyYWdIYW5kbGUgPSBcImMxdzliYmhyNy0wLTAtYmV0YS00NlwiO1xuY29uc3QgY2VsbERyYWdIYW5kbGVGcm96ZW5DbGFzc25hbWUgPSBcImMxY3Jlb3JjNy0wLTAtYmV0YS00NlwiO1xuY29uc3QgY2VsbERyYWdIYW5kbGVDbGFzc25hbWUgPSBgcmRnLWNlbGwtZHJhZy1oYW5kbGUgJHtjZWxsRHJhZ0hhbmRsZX1gO1xuZnVuY3Rpb24gRHJhZ0hhbmRsZSh7XG4gIGdyaWRSb3dTdGFydCxcbiAgcm93cyxcbiAgY29sdW1uLFxuICBjb2x1bW5XaWR0aCxcbiAgbWF4Q29sSWR4LFxuICBpc0xhc3RSb3csXG4gIHNlbGVjdGVkUG9zaXRpb24sXG4gIGxhdGVzdERyYWdnZWRPdmVyUm93SWR4LFxuICBpc0NlbGxFZGl0YWJsZSxcbiAgb25Sb3dzQ2hhbmdlLFxuICBvbkZpbGwsXG4gIG9uQ2xpY2ssXG4gIHNldERyYWdnaW5nLFxuICBzZXREcmFnZ2VkT3ZlclJvd0lkeFxufSkge1xuICBjb25zdCB7XG4gICAgaWR4LFxuICAgIHJvd0lkeFxuICB9ID0gc2VsZWN0ZWRQb3NpdGlvbjtcbiAgZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoZXZlbnQuYnV0dG9ucyAhPT0gMSkgcmV0dXJuO1xuICAgIHNldERyYWdnaW5nKHRydWUpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBvbk1vdXNlT3Zlcik7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgIGZ1bmN0aW9uIG9uTW91c2VPdmVyKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuYnV0dG9ucyAhPT0gMSkgb25Nb3VzZVVwKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VVcCgpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBvbk1vdXNlT3Zlcik7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICBzZXREcmFnZ2luZyhmYWxzZSk7XG4gICAgICBoYW5kbGVEcmFnRW5kKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZURyYWdFbmQoKSB7XG4gICAgY29uc3Qgb3ZlclJvd0lkeCA9IGxhdGVzdERyYWdnZWRPdmVyUm93SWR4LmN1cnJlbnQ7XG4gICAgaWYgKG92ZXJSb3dJZHggPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIGNvbnN0IHN0YXJ0Um93SW5kZXggPSByb3dJZHggPCBvdmVyUm93SWR4ID8gcm93SWR4ICsgMSA6IG92ZXJSb3dJZHg7XG4gICAgY29uc3QgZW5kUm93SW5kZXggPSByb3dJZHggPCBvdmVyUm93SWR4ID8gb3ZlclJvd0lkeCArIDEgOiByb3dJZHg7XG4gICAgdXBkYXRlUm93cyhzdGFydFJvd0luZGV4LCBlbmRSb3dJbmRleCk7XG4gICAgc2V0RHJhZ2dlZE92ZXJSb3dJZHgodW5kZWZpbmVkKTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVEb3VibGVDbGljayhldmVudCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHVwZGF0ZVJvd3Mocm93SWR4ICsgMSwgcm93cy5sZW5ndGgpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVJvd3Moc3RhcnRSb3dJZHgsIGVuZFJvd0lkeCkge1xuICAgIGNvbnN0IHNvdXJjZVJvdyA9IHJvd3Nbcm93SWR4XTtcbiAgICBjb25zdCB1cGRhdGVkUm93cyA9IFsuLi5yb3dzXTtcbiAgICBjb25zdCBpbmRleGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0Um93SWR4OyBpIDwgZW5kUm93SWR4OyBpKyspIHtcbiAgICAgIGlmIChpc0NlbGxFZGl0YWJsZSh7XG4gICAgICAgIHJvd0lkeDogaSxcbiAgICAgICAgaWR4XG4gICAgICB9KSkge1xuICAgICAgICBjb25zdCB1cGRhdGVkUm93ID0gb25GaWxsKHtcbiAgICAgICAgICBjb2x1bW5LZXk6IGNvbHVtbi5rZXksXG4gICAgICAgICAgc291cmNlUm93LFxuICAgICAgICAgIHRhcmdldFJvdzogcm93c1tpXVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHVwZGF0ZWRSb3cgIT09IHJvd3NbaV0pIHtcbiAgICAgICAgICB1cGRhdGVkUm93c1tpXSA9IHVwZGF0ZWRSb3c7XG4gICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbmRleGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIG9uUm93c0NoYW5nZT8uKHVwZGF0ZWRSb3dzLCB7XG4gICAgICAgIGluZGV4ZXMsXG4gICAgICAgIGNvbHVtblxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFN0eWxlKCkge1xuICAgIGNvbnN0IGNvbFNwYW4gPSBjb2x1bW4uY29sU3Bhbj8uKHtcbiAgICAgIHR5cGU6ICdST1cnLFxuICAgICAgcm93OiByb3dzW3Jvd0lkeF1cbiAgICB9KSA/PyAxO1xuICAgIGNvbnN0IHtcbiAgICAgIGluc2V0SW5saW5lU3RhcnQsXG4gICAgICAuLi5zdHlsZVxuICAgIH0gPSBnZXRDZWxsU3R5bGUoY29sdW1uLCBjb2xTcGFuKTtcbiAgICBjb25zdCBtYXJnaW5FbmQgPSAnY2FsYyh2YXIoLS1yZGctZHJhZy1oYW5kbGUtc2l6ZSkgKiAtMC41ICsgMXB4KSc7XG4gICAgY29uc3QgaXNMYXN0Q29sdW1uID0gY29sdW1uLmlkeCArIGNvbFNwYW4gLSAxID09PSBtYXhDb2xJZHg7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0eWxlLFxuICAgICAgZ3JpZFJvd1N0YXJ0LFxuICAgICAgbWFyZ2luSW5saW5lRW5kOiBpc0xhc3RDb2x1bW4gPyB1bmRlZmluZWQgOiBtYXJnaW5FbmQsXG4gICAgICBtYXJnaW5CbG9ja0VuZDogaXNMYXN0Um93ID8gdW5kZWZpbmVkIDogbWFyZ2luRW5kLFxuICAgICAgaW5zZXRJbmxpbmVTdGFydDogaW5zZXRJbmxpbmVTdGFydCA/IGBjYWxjKCR7aW5zZXRJbmxpbmVTdGFydH0gKyAke2NvbHVtbldpZHRofXB4ICsgdmFyKC0tcmRnLWRyYWctaGFuZGxlLXNpemUpICogLTAuNSAtIDFweClgIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChcImRpdlwiLCB7XG4gICAgc3R5bGU6IGdldFN0eWxlKCksXG4gICAgY2xhc3NOYW1lOiBjbHN4KGNlbGxEcmFnSGFuZGxlQ2xhc3NuYW1lLCBjb2x1bW4uZnJvemVuICYmIGNlbGxEcmFnSGFuZGxlRnJvemVuQ2xhc3NuYW1lKSxcbiAgICBvbkNsaWNrOiBvbkNsaWNrLFxuICAgIG9uTW91c2VEb3duOiBoYW5kbGVNb3VzZURvd24sXG4gICAgb25Eb3VibGVDbGljazogaGFuZGxlRG91YmxlQ2xpY2tcbiAgfSk7XG59XG5cbmNvbnN0IGNlbGxFZGl0aW5nID0gXCJjaXM1cnJtNy0wLTAtYmV0YS00NlwiO1xuZnVuY3Rpb24gRWRpdENlbGwoe1xuICBjb2x1bW4sXG4gIGNvbFNwYW4sXG4gIHJvdyxcbiAgcm93SWR4LFxuICBvblJvd0NoYW5nZSxcbiAgY2xvc2VFZGl0b3IsXG4gIG9uS2V5RG93bixcbiAgbmF2aWdhdGVcbn0pIHtcbiAgY29uc3QgZnJhbWVSZXF1ZXN0UmVmID0gdXNlUmVmKHVuZGVmaW5lZCk7XG4gIGNvbnN0IGNvbW1pdE9uT3V0c2lkZUNsaWNrID0gY29sdW1uLmVkaXRvck9wdGlvbnM/LmNvbW1pdE9uT3V0c2lkZUNsaWNrICE9PSBmYWxzZTtcbiAgY29uc3QgY29tbWl0T25PdXRzaWRlTW91c2VEb3duID0gdXNlTGF0ZXN0RnVuYygoKSA9PiB7XG4gICAgb25DbG9zZSh0cnVlLCBmYWxzZSk7XG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY29tbWl0T25PdXRzaWRlQ2xpY2spIHJldHVybjtcbiAgICBmdW5jdGlvbiBvbldpbmRvd0NhcHR1cmVNb3VzZURvd24oKSB7XG4gICAgICBmcmFtZVJlcXVlc3RSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShjb21taXRPbk91dHNpZGVNb3VzZURvd24pO1xuICAgIH1cbiAgICBhZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbldpbmRvd0NhcHR1cmVNb3VzZURvd24sIHtcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25XaW5kb3dDYXB0dXJlTW91c2VEb3duLCB7XG4gICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY2FuY2VsRnJhbWVSZXF1ZXN0KCk7XG4gICAgfTtcbiAgfSwgW2NvbW1pdE9uT3V0c2lkZUNsaWNrLCBjb21taXRPbk91dHNpZGVNb3VzZURvd25dKTtcbiAgZnVuY3Rpb24gY2FuY2VsRnJhbWVSZXF1ZXN0KCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lUmVxdWVzdFJlZi5jdXJyZW50KTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgaWYgKG9uS2V5RG93bikge1xuICAgICAgY29uc3QgY2VsbEV2ZW50ID0gY3JlYXRlQ2VsbEV2ZW50KGV2ZW50KTtcbiAgICAgIG9uS2V5RG93bih7XG4gICAgICAgIG1vZGU6ICdFRElUJyxcbiAgICAgICAgcm93LFxuICAgICAgICBjb2x1bW4sXG4gICAgICAgIHJvd0lkeCxcbiAgICAgICAgbmF2aWdhdGUoKSB7XG4gICAgICAgICAgbmF2aWdhdGUoZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBvbkNsb3NlXG4gICAgICB9LCBjZWxsRXZlbnQpO1xuICAgICAgaWYgKGNlbGxFdmVudC5pc0dyaWREZWZhdWx0UHJldmVudGVkKCkpIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgIG9uQ2xvc2UoKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgb25DbG9zZSh0cnVlKTtcbiAgICB9IGVsc2UgaWYgKG9uRWRpdG9yTmF2aWdhdGlvbihldmVudCkpIHtcbiAgICAgIG5hdmlnYXRlKGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25DbG9zZShjb21taXRDaGFuZ2VzID0gZmFsc2UsIHNob3VsZEZvY3VzQ2VsbCA9IHRydWUpIHtcbiAgICBpZiAoY29tbWl0Q2hhbmdlcykge1xuICAgICAgb25Sb3dDaGFuZ2Uocm93LCB0cnVlLCBzaG91bGRGb2N1c0NlbGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZUVkaXRvcihzaG91bGRGb2N1c0NlbGwpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvbkVkaXRvclJvd0NoYW5nZShyb3csIGNvbW1pdENoYW5nZXNBbmRGb2N1cyA9IGZhbHNlKSB7XG4gICAgb25Sb3dDaGFuZ2Uocm93LCBjb21taXRDaGFuZ2VzQW5kRm9jdXMsIGNvbW1pdENoYW5nZXNBbmRGb2N1cyk7XG4gIH1cbiAgY29uc3Qge1xuICAgIGNlbGxDbGFzc1xuICB9ID0gY29sdW1uO1xuICBjb25zdCBjbGFzc05hbWUgPSBnZXRDZWxsQ2xhc3NuYW1lKGNvbHVtbiwgJ3JkZy1lZGl0b3ItY29udGFpbmVyJywgdHlwZW9mIGNlbGxDbGFzcyA9PT0gJ2Z1bmN0aW9uJyA/IGNlbGxDbGFzcyhyb3cpIDogY2VsbENsYXNzLCAhY29sdW1uLmVkaXRvck9wdGlvbnM/LmRpc3BsYXlDZWxsQ29udGVudCAmJiBjZWxsRWRpdGluZyk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICByb2xlOiBcImdyaWRjZWxsXCIsXG4gICAgXCJhcmlhLWNvbGluZGV4XCI6IGNvbHVtbi5pZHggKyAxLFxuICAgIFwiYXJpYS1jb2xzcGFuXCI6IGNvbFNwYW4sXG4gICAgXCJhcmlhLXNlbGVjdGVkXCI6IHRydWUsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgc3R5bGU6IGdldENlbGxTdHlsZShjb2x1bW4sIGNvbFNwYW4pLFxuICAgIG9uS2V5RG93bjogaGFuZGxlS2V5RG93bixcbiAgICBvbk1vdXNlRG93bkNhcHR1cmU6IGNhbmNlbEZyYW1lUmVxdWVzdCxcbiAgICBjaGlsZHJlbjogY29sdW1uLnJlbmRlckVkaXRDZWxsICE9IG51bGwgJiYgLyojX19QVVJFX18qL2pzeHMoRnJhZ21lbnQsIHtcbiAgICAgIGNoaWxkcmVuOiBbY29sdW1uLnJlbmRlckVkaXRDZWxsKHtcbiAgICAgICAgY29sdW1uLFxuICAgICAgICByb3csXG4gICAgICAgIHJvd0lkeCxcbiAgICAgICAgb25Sb3dDaGFuZ2U6IG9uRWRpdG9yUm93Q2hhbmdlLFxuICAgICAgICBvbkNsb3NlXG4gICAgICB9KSwgY29sdW1uLmVkaXRvck9wdGlvbnM/LmRpc3BsYXlDZWxsQ29udGVudCAmJiBjb2x1bW4ucmVuZGVyQ2VsbCh7XG4gICAgICAgIGNvbHVtbixcbiAgICAgICAgcm93LFxuICAgICAgICByb3dJZHgsXG4gICAgICAgIGlzQ2VsbEVkaXRhYmxlOiB0cnVlLFxuICAgICAgICB0YWJJbmRleDogLTEsXG4gICAgICAgIG9uUm93Q2hhbmdlOiBvbkVkaXRvclJvd0NoYW5nZVxuICAgICAgfSldXG4gICAgfSlcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIEdyb3VwZWRDb2x1bW5IZWFkZXJDZWxsKHtcbiAgY29sdW1uLFxuICByb3dJZHgsXG4gIGlzQ2VsbFNlbGVjdGVkLFxuICBzZWxlY3RDZWxsXG59KSB7XG4gIGNvbnN0IHtcbiAgICB0YWJJbmRleCxcbiAgICBvbkZvY3VzXG4gIH0gPSB1c2VSb3ZpbmdUYWJJbmRleChpc0NlbGxTZWxlY3RlZCk7XG4gIGNvbnN0IHtcbiAgICBjb2xTcGFuXG4gIH0gPSBjb2x1bW47XG4gIGNvbnN0IHJvd1NwYW4gPSBnZXRIZWFkZXJDZWxsUm93U3Bhbihjb2x1bW4sIHJvd0lkeCk7XG4gIGNvbnN0IGluZGV4ID0gY29sdW1uLmlkeCArIDE7XG4gIGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgc2VsZWN0Q2VsbCh7XG4gICAgICBpZHg6IGNvbHVtbi5pZHgsXG4gICAgICByb3dJZHhcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChcImRpdlwiLCB7XG4gICAgcm9sZTogXCJjb2x1bW5oZWFkZXJcIixcbiAgICBcImFyaWEtY29saW5kZXhcIjogaW5kZXgsXG4gICAgXCJhcmlhLWNvbHNwYW5cIjogY29sU3BhbixcbiAgICBcImFyaWEtcm93c3BhblwiOiByb3dTcGFuLFxuICAgIFwiYXJpYS1zZWxlY3RlZFwiOiBpc0NlbGxTZWxlY3RlZCxcbiAgICB0YWJJbmRleDogdGFiSW5kZXgsXG4gICAgY2xhc3NOYW1lOiBjbHN4KGNlbGxDbGFzc25hbWUsIGNvbHVtbi5oZWFkZXJDZWxsQ2xhc3MpLFxuICAgIHN0eWxlOiB7XG4gICAgICAuLi5nZXRIZWFkZXJDZWxsU3R5bGUoY29sdW1uLCByb3dJZHgsIHJvd1NwYW4pLFxuICAgICAgZ3JpZENvbHVtblN0YXJ0OiBpbmRleCxcbiAgICAgIGdyaWRDb2x1bW5FbmQ6IGluZGV4ICsgY29sU3BhblxuICAgIH0sXG4gICAgb25Gb2N1czogb25Gb2N1cyxcbiAgICBvbkNsaWNrOiBvbkNsaWNrLFxuICAgIGNoaWxkcmVuOiBjb2x1bW4ubmFtZVxuICB9KTtcbn1cblxuY29uc3QgaGVhZGVyU29ydENlbGxDbGFzc25hbWUgPSBcImg0NGp0azY3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCBoZWFkZXJTb3J0TmFtZSA9IFwiaGNna2h4ejctMC0wLWJldGEtNDZcIjtcbmNvbnN0IGhlYWRlclNvcnROYW1lQ2xhc3NuYW1lID0gYHJkZy1oZWFkZXItc29ydC1uYW1lICR7aGVhZGVyU29ydE5hbWV9YDtcbmZ1bmN0aW9uIHJlbmRlckhlYWRlckNlbGwoe1xuICBjb2x1bW4sXG4gIHNvcnREaXJlY3Rpb24sXG4gIHByaW9yaXR5XG59KSB7XG4gIGlmICghY29sdW1uLnNvcnRhYmxlKSByZXR1cm4gY29sdW1uLm5hbWU7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFNvcnRhYmxlSGVhZGVyQ2VsbCwge1xuICAgIHNvcnREaXJlY3Rpb246IHNvcnREaXJlY3Rpb24sXG4gICAgcHJpb3JpdHk6IHByaW9yaXR5LFxuICAgIGNoaWxkcmVuOiBjb2x1bW4ubmFtZVxuICB9KTtcbn1cbmZ1bmN0aW9uIFNvcnRhYmxlSGVhZGVyQ2VsbCh7XG4gIHNvcnREaXJlY3Rpb24sXG4gIHByaW9yaXR5LFxuICBjaGlsZHJlblxufSkge1xuICBjb25zdCByZW5kZXJTb3J0U3RhdHVzID0gdXNlRGVmYXVsdFJlbmRlcmVycygpLnJlbmRlclNvcnRTdGF0dXM7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4cyhcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogaGVhZGVyU29ydENlbGxDbGFzc25hbWUsXG4gICAgY2hpbGRyZW46IFsvKiNfX1BVUkVfXyovanN4KFwic3BhblwiLCB7XG4gICAgICBjbGFzc05hbWU6IGhlYWRlclNvcnROYW1lQ2xhc3NuYW1lLFxuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgfSksIC8qI19fUFVSRV9fKi9qc3goXCJzcGFuXCIsIHtcbiAgICAgIGNoaWxkcmVuOiByZW5kZXJTb3J0U3RhdHVzKHtcbiAgICAgICAgc29ydERpcmVjdGlvbixcbiAgICAgICAgcHJpb3JpdHlcbiAgICAgIH0pXG4gICAgfSldXG4gIH0pO1xufVxuXG5jb25zdCBjZWxsU29ydGFibGVDbGFzc25hbWUgPSBcImM2bDJ3djE3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCBjZWxsUmVzaXphYmxlID0gXCJjMWtxZHc3eTctMC0wLWJldGEtNDZcIjtcbmNvbnN0IGNlbGxSZXNpemFibGVDbGFzc25hbWUgPSBgcmRnLWNlbGwtcmVzaXphYmxlICR7Y2VsbFJlc2l6YWJsZX1gO1xuY29uc3QgcmVzaXplSGFuZGxlQ2xhc3NuYW1lID0gXCJyMXk2eXdseDctMC0wLWJldGEtNDZcIjtcbmNvbnN0IGNlbGxEcmFnZ2FibGVDbGFzc25hbWUgPSAncmRnLWNlbGwtZHJhZ2dhYmxlJztcbmNvbnN0IGNlbGxEcmFnZ2luZyA9IFwiYzFiZXpnNW83LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCBjZWxsRHJhZ2dpbmdDbGFzc25hbWUgPSBgcmRnLWNlbGwtZHJhZ2dpbmcgJHtjZWxsRHJhZ2dpbmd9YDtcbmNvbnN0IGNlbGxPdmVyID0gXCJjMXZjOTYwMzctMC0wLWJldGEtNDZcIjtcbmNvbnN0IGNlbGxPdmVyQ2xhc3NuYW1lID0gYHJkZy1jZWxsLWRyYWctb3ZlciAke2NlbGxPdmVyfWA7XG5mdW5jdGlvbiBIZWFkZXJDZWxsKHtcbiAgY29sdW1uLFxuICBjb2xTcGFuLFxuICByb3dJZHgsXG4gIGlzQ2VsbFNlbGVjdGVkLFxuICBvbkNvbHVtblJlc2l6ZSxcbiAgb25Db2x1bW5zUmVvcmRlcixcbiAgc29ydENvbHVtbnMsXG4gIG9uU29ydENvbHVtbnNDaGFuZ2UsXG4gIHNlbGVjdENlbGwsXG4gIHNob3VsZEZvY3VzR3JpZCxcbiAgZGlyZWN0aW9uLFxuICBkcmFnRHJvcEtleVxufSkge1xuICBjb25zdCBbaXNEcmFnZ2luZywgc2V0SXNEcmFnZ2luZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc092ZXIsIHNldElzT3Zlcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IGlzUnRsID0gZGlyZWN0aW9uID09PSAncnRsJztcbiAgY29uc3Qgcm93U3BhbiA9IGdldEhlYWRlckNlbGxSb3dTcGFuKGNvbHVtbiwgcm93SWR4KTtcbiAgY29uc3Qge1xuICAgIHRhYkluZGV4LFxuICAgIGNoaWxkVGFiSW5kZXgsXG4gICAgb25Gb2N1c1xuICB9ID0gdXNlUm92aW5nVGFiSW5kZXgoaXNDZWxsU2VsZWN0ZWQpO1xuICBjb25zdCBzb3J0SW5kZXggPSBzb3J0Q29sdW1ucz8uZmluZEluZGV4KHNvcnQgPT4gc29ydC5jb2x1bW5LZXkgPT09IGNvbHVtbi5rZXkpO1xuICBjb25zdCBzb3J0Q29sdW1uID0gc29ydEluZGV4ICE9PSB1bmRlZmluZWQgJiYgc29ydEluZGV4ID4gLTEgPyBzb3J0Q29sdW1uc1tzb3J0SW5kZXhdIDogdW5kZWZpbmVkO1xuICBjb25zdCBzb3J0RGlyZWN0aW9uID0gc29ydENvbHVtbj8uZGlyZWN0aW9uO1xuICBjb25zdCBwcmlvcml0eSA9IHNvcnRDb2x1bW4gIT09IHVuZGVmaW5lZCAmJiBzb3J0Q29sdW1ucy5sZW5ndGggPiAxID8gc29ydEluZGV4ICsgMSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgYXJpYVNvcnQgPSBzb3J0RGlyZWN0aW9uICYmICFwcmlvcml0eSA/IHNvcnREaXJlY3Rpb24gPT09ICdBU0MnID8gJ2FzY2VuZGluZycgOiAnZGVzY2VuZGluZycgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHtcbiAgICBzb3J0YWJsZSxcbiAgICByZXNpemFibGUsXG4gICAgZHJhZ2dhYmxlXG4gIH0gPSBjb2x1bW47XG4gIGNvbnN0IGNsYXNzTmFtZSA9IGdldENlbGxDbGFzc25hbWUoY29sdW1uLCBjb2x1bW4uaGVhZGVyQ2VsbENsYXNzLCBzb3J0YWJsZSAmJiBjZWxsU29ydGFibGVDbGFzc25hbWUsIHJlc2l6YWJsZSAmJiBjZWxsUmVzaXphYmxlQ2xhc3NuYW1lLCBkcmFnZ2FibGUgJiYgY2VsbERyYWdnYWJsZUNsYXNzbmFtZSwgaXNEcmFnZ2luZyAmJiBjZWxsRHJhZ2dpbmdDbGFzc25hbWUsIGlzT3ZlciAmJiBjZWxsT3ZlckNsYXNzbmFtZSk7XG4gIGNvbnN0IHJlbmRlckhlYWRlckNlbGwkMSA9IGNvbHVtbi5yZW5kZXJIZWFkZXJDZWxsID8/IHJlbmRlckhlYWRlckNlbGw7XG4gIGZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScgJiYgZXZlbnQuYnV0dG9ucyAhPT0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRUYXJnZXQsXG4gICAgICBwb2ludGVySWRcbiAgICB9ID0gZXZlbnQ7XG4gICAgY29uc3QgaGVhZGVyQ2VsbCA9IGN1cnJlbnRUYXJnZXQucGFyZW50RWxlbWVudDtcbiAgICBjb25zdCB7XG4gICAgICByaWdodCxcbiAgICAgIGxlZnRcbiAgICB9ID0gaGVhZGVyQ2VsbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBvZmZzZXQgPSBpc1J0bCA/IGV2ZW50LmNsaWVudFggLSBsZWZ0IDogcmlnaHQgLSBldmVudC5jbGllbnRYO1xuICAgIGZ1bmN0aW9uIG9uUG9pbnRlck1vdmUoZXZlbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmlnaHQsXG4gICAgICAgIGxlZnRcbiAgICAgIH0gPSBoZWFkZXJDZWxsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3Qgd2lkdGggPSBpc1J0bCA/IHJpZ2h0ICsgb2Zmc2V0IC0gZXZlbnQuY2xpZW50WCA6IGV2ZW50LmNsaWVudFggKyBvZmZzZXQgLSBsZWZ0O1xuICAgICAgaWYgKHdpZHRoID4gMCkge1xuICAgICAgICBvbkNvbHVtblJlc2l6ZShjb2x1bW4sIGNsYW1wQ29sdW1uV2lkdGgod2lkdGgsIGNvbHVtbikpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbkxvc3RQb2ludGVyQ2FwdHVyZSgpIHtcbiAgICAgIGN1cnJlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBvblBvaW50ZXJNb3ZlKTtcbiAgICAgIGN1cnJlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9zdHBvaW50ZXJjYXB0dXJlJywgb25Mb3N0UG9pbnRlckNhcHR1cmUpO1xuICAgIH1cbiAgICBjdXJyZW50VGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKHBvaW50ZXJJZCk7XG4gICAgY3VycmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgIGN1cnJlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbG9zdHBvaW50ZXJjYXB0dXJlJywgb25Mb3N0UG9pbnRlckNhcHR1cmUpO1xuICB9XG4gIGZ1bmN0aW9uIG9uU29ydChjdHJsQ2xpY2spIHtcbiAgICBpZiAob25Tb3J0Q29sdW1uc0NoYW5nZSA9PSBudWxsKSByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgc29ydERlc2NlbmRpbmdGaXJzdFxuICAgIH0gPSBjb2x1bW47XG4gICAgaWYgKHNvcnRDb2x1bW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbmV4dFNvcnQgPSB7XG4gICAgICAgIGNvbHVtbktleTogY29sdW1uLmtleSxcbiAgICAgICAgZGlyZWN0aW9uOiBzb3J0RGVzY2VuZGluZ0ZpcnN0ID8gJ0RFU0MnIDogJ0FTQydcbiAgICAgIH07XG4gICAgICBvblNvcnRDb2x1bW5zQ2hhbmdlKHNvcnRDb2x1bW5zICYmIGN0cmxDbGljayA/IFsuLi5zb3J0Q29sdW1ucywgbmV4dFNvcnRdIDogW25leHRTb3J0XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuZXh0U29ydENvbHVtbjtcbiAgICAgIGlmIChzb3J0RGVzY2VuZGluZ0ZpcnN0ID09PSB0cnVlICYmIHNvcnREaXJlY3Rpb24gPT09ICdERVNDJyB8fCBzb3J0RGVzY2VuZGluZ0ZpcnN0ICE9PSB0cnVlICYmIHNvcnREaXJlY3Rpb24gPT09ICdBU0MnKSB7XG4gICAgICAgIG5leHRTb3J0Q29sdW1uID0ge1xuICAgICAgICAgIGNvbHVtbktleTogY29sdW1uLmtleSxcbiAgICAgICAgICBkaXJlY3Rpb246IHNvcnREaXJlY3Rpb24gPT09ICdBU0MnID8gJ0RFU0MnIDogJ0FTQydcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChjdHJsQ2xpY2spIHtcbiAgICAgICAgY29uc3QgbmV4dFNvcnRDb2x1bW5zID0gWy4uLnNvcnRDb2x1bW5zXTtcbiAgICAgICAgaWYgKG5leHRTb3J0Q29sdW1uKSB7XG4gICAgICAgICAgbmV4dFNvcnRDb2x1bW5zW3NvcnRJbmRleF0gPSBuZXh0U29ydENvbHVtbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0U29ydENvbHVtbnMuc3BsaWNlKHNvcnRJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgb25Tb3J0Q29sdW1uc0NoYW5nZShuZXh0U29ydENvbHVtbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25Tb3J0Q29sdW1uc0NoYW5nZShuZXh0U29ydENvbHVtbiA/IFtuZXh0U29ydENvbHVtbl0gOiBbXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQpIHtcbiAgICBzZWxlY3RDZWxsKHtcbiAgICAgIGlkeDogY29sdW1uLmlkeCxcbiAgICAgIHJvd0lkeFxuICAgIH0pO1xuICAgIGlmIChzb3J0YWJsZSkge1xuICAgICAgb25Tb3J0KGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uRG91YmxlQ2xpY2soKSB7XG4gICAgb25Db2x1bW5SZXNpemUoY29sdW1uLCAnbWF4LWNvbnRlbnQnKTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVGb2N1cyhldmVudCkge1xuICAgIG9uRm9jdXM/LihldmVudCk7XG4gICAgaWYgKHNob3VsZEZvY3VzR3JpZCkge1xuICAgICAgc2VsZWN0Q2VsbCh7XG4gICAgICAgIGlkeDogMCxcbiAgICAgICAgcm93SWR4XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gJyAnIHx8IGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG9uU29ydChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvbkRyYWdTdGFydChldmVudCkge1xuICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKGRyYWdEcm9wS2V5LCBjb2x1bW4ua2V5KTtcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdtb3ZlJztcbiAgICBzZXRJc0RyYWdnaW5nKHRydWUpO1xuICB9XG4gIGZ1bmN0aW9uIG9uRHJhZ0VuZCgpIHtcbiAgICBzZXRJc0RyYWdnaW5nKGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBvbkRyYWdPdmVyKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdtb3ZlJztcbiAgfVxuICBmdW5jdGlvbiBvbkRyb3AoZXZlbnQpIHtcbiAgICBzZXRJc092ZXIoZmFsc2UpO1xuICAgIGlmIChldmVudC5kYXRhVHJhbnNmZXIudHlwZXMuaW5jbHVkZXMoZHJhZ0Ryb3BLZXkpKSB7XG4gICAgICBjb25zdCBzb3VyY2VLZXkgPSBldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShkcmFnRHJvcEtleSk7XG4gICAgICBpZiAoc291cmNlS2V5ICE9PSBjb2x1bW4ua2V5KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG9uQ29sdW1uc1Jlb3JkZXI/Lihzb3VyY2VLZXksIGNvbHVtbi5rZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvbkRyYWdFbnRlcihldmVudCkge1xuICAgIGlmIChpc0V2ZW50UGVydGluZW50KGV2ZW50KSkge1xuICAgICAgc2V0SXNPdmVyKHRydWUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvbkRyYWdMZWF2ZShldmVudCkge1xuICAgIGlmIChpc0V2ZW50UGVydGluZW50KGV2ZW50KSkge1xuICAgICAgc2V0SXNPdmVyKGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgbGV0IGRyYWdnYWJsZVByb3BzO1xuICBpZiAoZHJhZ2dhYmxlKSB7XG4gICAgZHJhZ2dhYmxlUHJvcHMgPSB7XG4gICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICBvbkRyYWdTdGFydCxcbiAgICAgIG9uRHJhZ0VuZCxcbiAgICAgIG9uRHJhZ092ZXIsXG4gICAgICBvbkRyYWdFbnRlcixcbiAgICAgIG9uRHJhZ0xlYXZlLFxuICAgICAgb25Ecm9wXG4gICAgfTtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL2pzeHMoXCJkaXZcIiwge1xuICAgIHJvbGU6IFwiY29sdW1uaGVhZGVyXCIsXG4gICAgXCJhcmlhLWNvbGluZGV4XCI6IGNvbHVtbi5pZHggKyAxLFxuICAgIFwiYXJpYS1jb2xzcGFuXCI6IGNvbFNwYW4sXG4gICAgXCJhcmlhLXJvd3NwYW5cIjogcm93U3BhbixcbiAgICBcImFyaWEtc2VsZWN0ZWRcIjogaXNDZWxsU2VsZWN0ZWQsXG4gICAgXCJhcmlhLXNvcnRcIjogYXJpYVNvcnQsXG4gICAgdGFiSW5kZXg6IHNob3VsZEZvY3VzR3JpZCA/IDAgOiB0YWJJbmRleCxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICBzdHlsZToge1xuICAgICAgLi4uZ2V0SGVhZGVyQ2VsbFN0eWxlKGNvbHVtbiwgcm93SWR4LCByb3dTcGFuKSxcbiAgICAgIC4uLmdldENlbGxTdHlsZShjb2x1bW4sIGNvbFNwYW4pXG4gICAgfSxcbiAgICBvbkZvY3VzOiBoYW5kbGVGb2N1cyxcbiAgICBvbkNsaWNrOiBvbkNsaWNrLFxuICAgIG9uS2V5RG93bjogc29ydGFibGUgPyBvbktleURvd24gOiB1bmRlZmluZWQsXG4gICAgLi4uZHJhZ2dhYmxlUHJvcHMsXG4gICAgY2hpbGRyZW46IFtyZW5kZXJIZWFkZXJDZWxsJDEoe1xuICAgICAgY29sdW1uLFxuICAgICAgc29ydERpcmVjdGlvbixcbiAgICAgIHByaW9yaXR5LFxuICAgICAgdGFiSW5kZXg6IGNoaWxkVGFiSW5kZXhcbiAgICB9KSwgcmVzaXphYmxlICYmIC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiByZXNpemVIYW5kbGVDbGFzc25hbWUsXG4gICAgICBvbkNsaWNrOiBzdG9wUHJvcGFnYXRpb24sXG4gICAgICBvbkRvdWJsZUNsaWNrOiBvbkRvdWJsZUNsaWNrLFxuICAgICAgb25Qb2ludGVyRG93bjogb25Qb2ludGVyRG93blxuICAgIH0pXVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzRXZlbnRQZXJ0aW5lbnQoZXZlbnQpIHtcbiAgY29uc3QgcmVsYXRlZFRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gIHJldHVybiAhZXZlbnQuY3VycmVudFRhcmdldC5jb250YWlucyhyZWxhdGVkVGFyZ2V0KTtcbn1cblxuY29uc3Qgcm93ID0gXCJyMXVwZnI4MDctMC0wLWJldGEtNDZcIjtcbmNvbnN0IHJvd0NsYXNzbmFtZSA9IGByZGctcm93ICR7cm93fWA7XG5jb25zdCByb3dTZWxlY3RlZCA9IFwicjE5MG1oZDM3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCByb3dTZWxlY3RlZENsYXNzbmFtZSA9ICdyZGctcm93LXNlbGVjdGVkJztcbmNvbnN0IHJvd1NlbGVjdGVkV2l0aEZyb3plbkNlbGwgPSBcInIxMzlxdTltNy0wLTAtYmV0YS00NlwiO1xuY29uc3QgdG9wU3VtbWFyeVJvd0NsYXNzbmFtZSA9ICdyZGctdG9wLXN1bW1hcnktcm93JztcbmNvbnN0IGJvdHRvbVN1bW1hcnlSb3dDbGFzc25hbWUgPSAncmRnLWJvdHRvbS1zdW1tYXJ5LXJvdyc7XG5cbmNvbnN0IGhlYWRlclJvdyA9IFwiaDEwdHNrY3g3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCBoZWFkZXJSb3dDbGFzc25hbWUgPSBgcmRnLWhlYWRlci1yb3cgJHtoZWFkZXJSb3d9YDtcbmZ1bmN0aW9uIEhlYWRlclJvdyh7XG4gIHJvd0lkeCxcbiAgY29sdW1ucyxcbiAgb25Db2x1bW5SZXNpemUsXG4gIG9uQ29sdW1uc1Jlb3JkZXIsXG4gIHNvcnRDb2x1bW5zLFxuICBvblNvcnRDb2x1bW5zQ2hhbmdlLFxuICBsYXN0RnJvemVuQ29sdW1uSW5kZXgsXG4gIHNlbGVjdGVkQ2VsbElkeCxcbiAgc2VsZWN0Q2VsbCxcbiAgc2hvdWxkRm9jdXNHcmlkLFxuICBkaXJlY3Rpb25cbn0pIHtcbiAgY29uc3QgZHJhZ0Ryb3BLZXkgPSB1c2VJZCgpO1xuICBjb25zdCBjZWxscyA9IFtdO1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgY29sdW1ucy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zW2luZGV4XTtcbiAgICBjb25zdCBjb2xTcGFuID0gZ2V0Q29sU3Bhbihjb2x1bW4sIGxhc3RGcm96ZW5Db2x1bW5JbmRleCwge1xuICAgICAgdHlwZTogJ0hFQURFUidcbiAgICB9KTtcbiAgICBpZiAoY29sU3BhbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbmRleCArPSBjb2xTcGFuIC0gMTtcbiAgICB9XG4gICAgY2VsbHMucHVzaCggLyojX19QVVJFX18qL2pzeChIZWFkZXJDZWxsLCB7XG4gICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgIGNvbFNwYW46IGNvbFNwYW4sXG4gICAgICByb3dJZHg6IHJvd0lkeCxcbiAgICAgIGlzQ2VsbFNlbGVjdGVkOiBzZWxlY3RlZENlbGxJZHggPT09IGNvbHVtbi5pZHgsXG4gICAgICBvbkNvbHVtblJlc2l6ZTogb25Db2x1bW5SZXNpemUsXG4gICAgICBvbkNvbHVtbnNSZW9yZGVyOiBvbkNvbHVtbnNSZW9yZGVyLFxuICAgICAgb25Tb3J0Q29sdW1uc0NoYW5nZTogb25Tb3J0Q29sdW1uc0NoYW5nZSxcbiAgICAgIHNvcnRDb2x1bW5zOiBzb3J0Q29sdW1ucyxcbiAgICAgIHNlbGVjdENlbGw6IHNlbGVjdENlbGwsXG4gICAgICBzaG91bGRGb2N1c0dyaWQ6IHNob3VsZEZvY3VzR3JpZCAmJiBpbmRleCA9PT0gMCxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgZHJhZ0Ryb3BLZXk6IGRyYWdEcm9wS2V5XG4gICAgfSwgY29sdW1uLmtleSkpO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICByb2xlOiBcInJvd1wiLFxuICAgIFwiYXJpYS1yb3dpbmRleFwiOiByb3dJZHgsXG4gICAgY2xhc3NOYW1lOiBjbHN4KGhlYWRlclJvd0NsYXNzbmFtZSwgc2VsZWN0ZWRDZWxsSWR4ID09PSAtMSAmJiByb3dTZWxlY3RlZENsYXNzbmFtZSksXG4gICAgY2hpbGRyZW46IGNlbGxzXG4gIH0pO1xufVxuY29uc3QgSGVhZGVyUm93JDEgPSAvKiNfX1BVUkVfXyovbWVtbyhIZWFkZXJSb3cpO1xuXG5mdW5jdGlvbiBHcm91cGVkQ29sdW1uSGVhZGVyUm93KHtcbiAgcm93SWR4LFxuICBsZXZlbCxcbiAgY29sdW1ucyxcbiAgc2VsZWN0ZWRDZWxsSWR4LFxuICBzZWxlY3RDZWxsXG59KSB7XG4gIGNvbnN0IGNlbGxzID0gW107XG4gIGNvbnN0IHJlbmRlcmVkUGFyZW50cyA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBjb2x1bW4gb2YgY29sdW1ucykge1xuICAgIGxldCB7XG4gICAgICBwYXJlbnRcbiAgICB9ID0gY29sdW1uO1xuICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gICAgd2hpbGUgKHBhcmVudC5sZXZlbCA+IGxldmVsKSB7XG4gICAgICBpZiAocGFyZW50LnBhcmVudCA9PT0gdW5kZWZpbmVkKSBicmVhaztcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIGlmIChwYXJlbnQubGV2ZWwgPT09IGxldmVsICYmICFyZW5kZXJlZFBhcmVudHMuaGFzKHBhcmVudCkpIHtcbiAgICAgIHJlbmRlcmVkUGFyZW50cy5hZGQocGFyZW50KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaWR4XG4gICAgICB9ID0gcGFyZW50O1xuICAgICAgY2VsbHMucHVzaCggLyojX19QVVJFX18qL2pzeChHcm91cGVkQ29sdW1uSGVhZGVyQ2VsbCwge1xuICAgICAgICBjb2x1bW46IHBhcmVudCxcbiAgICAgICAgcm93SWR4OiByb3dJZHgsXG4gICAgICAgIGlzQ2VsbFNlbGVjdGVkOiBzZWxlY3RlZENlbGxJZHggPT09IGlkeCxcbiAgICAgICAgc2VsZWN0Q2VsbDogc2VsZWN0Q2VsbFxuICAgICAgfSwgaWR4KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICByb2xlOiBcInJvd1wiLFxuICAgIFwiYXJpYS1yb3dpbmRleFwiOiByb3dJZHgsXG4gICAgY2xhc3NOYW1lOiBoZWFkZXJSb3dDbGFzc25hbWUsXG4gICAgY2hpbGRyZW46IGNlbGxzXG4gIH0pO1xufVxuY29uc3QgR3JvdXBlZENvbHVtbkhlYWRlclJvdyQxID0gLyojX19QVVJFX18qL21lbW8oR3JvdXBlZENvbHVtbkhlYWRlclJvdyk7XG5cbmNvbnN0IGNlbGxDb3BpZWQgPSBcImM2cmE4YTM3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCBjZWxsQ29waWVkQ2xhc3NuYW1lID0gYHJkZy1jZWxsLWNvcGllZCAke2NlbGxDb3BpZWR9YDtcbmNvbnN0IGNlbGxEcmFnZ2VkT3ZlciA9IFwiY3E5MTBtMDctMC0wLWJldGEtNDZcIjtcbmNvbnN0IGNlbGxEcmFnZ2VkT3ZlckNsYXNzbmFtZSA9IGByZGctY2VsbC1kcmFnZ2VkLW92ZXIgJHtjZWxsRHJhZ2dlZE92ZXJ9YDtcbmZ1bmN0aW9uIENlbGwoe1xuICBjb2x1bW4sXG4gIGNvbFNwYW4sXG4gIGlzQ2VsbFNlbGVjdGVkLFxuICBpc0NvcGllZCxcbiAgaXNEcmFnZ2VkT3ZlcixcbiAgcm93LFxuICByb3dJZHgsXG4gIG9uQ2xpY2ssXG4gIG9uRG91YmxlQ2xpY2ssXG4gIG9uQ29udGV4dE1lbnUsXG4gIG9uUm93Q2hhbmdlLFxuICBzZWxlY3RDZWxsLFxuICAuLi5wcm9wc1xufSkge1xuICBjb25zdCB7XG4gICAgdGFiSW5kZXgsXG4gICAgY2hpbGRUYWJJbmRleCxcbiAgICBvbkZvY3VzXG4gIH0gPSB1c2VSb3ZpbmdUYWJJbmRleChpc0NlbGxTZWxlY3RlZCk7XG4gIGNvbnN0IHtcbiAgICBjZWxsQ2xhc3NcbiAgfSA9IGNvbHVtbjtcbiAgY29uc3QgY2xhc3NOYW1lID0gZ2V0Q2VsbENsYXNzbmFtZShjb2x1bW4sIHR5cGVvZiBjZWxsQ2xhc3MgPT09ICdmdW5jdGlvbicgPyBjZWxsQ2xhc3Mocm93KSA6IGNlbGxDbGFzcywgaXNDb3BpZWQgJiYgY2VsbENvcGllZENsYXNzbmFtZSwgaXNEcmFnZ2VkT3ZlciAmJiBjZWxsRHJhZ2dlZE92ZXJDbGFzc25hbWUpO1xuICBjb25zdCBpc0VkaXRhYmxlID0gaXNDZWxsRWRpdGFibGVVdGlsKGNvbHVtbiwgcm93KTtcbiAgZnVuY3Rpb24gc2VsZWN0Q2VsbFdyYXBwZXIob3BlbkVkaXRvcikge1xuICAgIHNlbGVjdENlbGwoe1xuICAgICAgcm93SWR4LFxuICAgICAgaWR4OiBjb2x1bW4uaWR4XG4gICAgfSwgb3BlbkVkaXRvcik7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAob25DbGljaykge1xuICAgICAgY29uc3QgY2VsbEV2ZW50ID0gY3JlYXRlQ2VsbEV2ZW50KGV2ZW50KTtcbiAgICAgIG9uQ2xpY2soe1xuICAgICAgICByb3csXG4gICAgICAgIGNvbHVtbixcbiAgICAgICAgc2VsZWN0Q2VsbDogc2VsZWN0Q2VsbFdyYXBwZXJcbiAgICAgIH0sIGNlbGxFdmVudCk7XG4gICAgICBpZiAoY2VsbEV2ZW50LmlzR3JpZERlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxlY3RDZWxsV3JhcHBlcigpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZUNvbnRleHRNZW51KGV2ZW50KSB7XG4gICAgaWYgKG9uQ29udGV4dE1lbnUpIHtcbiAgICAgIGNvbnN0IGNlbGxFdmVudCA9IGNyZWF0ZUNlbGxFdmVudChldmVudCk7XG4gICAgICBvbkNvbnRleHRNZW51KHtcbiAgICAgICAgcm93LFxuICAgICAgICBjb2x1bW4sXG4gICAgICAgIHNlbGVjdENlbGw6IHNlbGVjdENlbGxXcmFwcGVyXG4gICAgICB9LCBjZWxsRXZlbnQpO1xuICAgICAgaWYgKGNlbGxFdmVudC5pc0dyaWREZWZhdWx0UHJldmVudGVkKCkpIHJldHVybjtcbiAgICB9XG4gICAgc2VsZWN0Q2VsbFdyYXBwZXIoKTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVEb3VibGVDbGljayhldmVudCkge1xuICAgIGlmIChvbkRvdWJsZUNsaWNrKSB7XG4gICAgICBjb25zdCBjZWxsRXZlbnQgPSBjcmVhdGVDZWxsRXZlbnQoZXZlbnQpO1xuICAgICAgb25Eb3VibGVDbGljayh7XG4gICAgICAgIHJvdyxcbiAgICAgICAgY29sdW1uLFxuICAgICAgICBzZWxlY3RDZWxsOiBzZWxlY3RDZWxsV3JhcHBlclxuICAgICAgfSwgY2VsbEV2ZW50KTtcbiAgICAgIGlmIChjZWxsRXZlbnQuaXNHcmlkRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm47XG4gICAgfVxuICAgIHNlbGVjdENlbGxXcmFwcGVyKHRydWUpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVJvd0NoYW5nZShuZXdSb3cpIHtcbiAgICBvblJvd0NoYW5nZShjb2x1bW4sIG5ld1Jvdyk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgIHJvbGU6IFwiZ3JpZGNlbGxcIixcbiAgICBcImFyaWEtY29saW5kZXhcIjogY29sdW1uLmlkeCArIDEsXG4gICAgXCJhcmlhLWNvbHNwYW5cIjogY29sU3BhbixcbiAgICBcImFyaWEtc2VsZWN0ZWRcIjogaXNDZWxsU2VsZWN0ZWQsXG4gICAgXCJhcmlhLXJlYWRvbmx5XCI6ICFpc0VkaXRhYmxlIHx8IHVuZGVmaW5lZCxcbiAgICB0YWJJbmRleDogdGFiSW5kZXgsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgc3R5bGU6IGdldENlbGxTdHlsZShjb2x1bW4sIGNvbFNwYW4pLFxuICAgIG9uQ2xpY2s6IGhhbmRsZUNsaWNrLFxuICAgIG9uRG91YmxlQ2xpY2s6IGhhbmRsZURvdWJsZUNsaWNrLFxuICAgIG9uQ29udGV4dE1lbnU6IGhhbmRsZUNvbnRleHRNZW51LFxuICAgIG9uRm9jdXM6IG9uRm9jdXMsXG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IGNvbHVtbi5yZW5kZXJDZWxsKHtcbiAgICAgIGNvbHVtbixcbiAgICAgIHJvdyxcbiAgICAgIHJvd0lkeCxcbiAgICAgIGlzQ2VsbEVkaXRhYmxlOiBpc0VkaXRhYmxlLFxuICAgICAgdGFiSW5kZXg6IGNoaWxkVGFiSW5kZXgsXG4gICAgICBvblJvd0NoYW5nZTogaGFuZGxlUm93Q2hhbmdlXG4gICAgfSlcbiAgfSk7XG59XG5jb25zdCBDZWxsJDEgPSAvKiNfX1BVUkVfXyovbWVtbyhDZWxsKTtcblxuZnVuY3Rpb24gUm93KHtcbiAgY2xhc3NOYW1lLFxuICByb3dJZHgsXG4gIGdyaWRSb3dTdGFydCxcbiAgc2VsZWN0ZWRDZWxsSWR4LFxuICBpc1Jvd1NlbGVjdGVkLFxuICBjb3BpZWRDZWxsSWR4LFxuICBkcmFnZ2VkT3ZlckNlbGxJZHgsXG4gIGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgcm93LFxuICB2aWV3cG9ydENvbHVtbnMsXG4gIHNlbGVjdGVkQ2VsbEVkaXRvcixcbiAgb25DZWxsQ2xpY2ssXG4gIG9uQ2VsbERvdWJsZUNsaWNrLFxuICBvbkNlbGxDb250ZXh0TWVudSxcbiAgcm93Q2xhc3MsXG4gIHNldERyYWdnZWRPdmVyUm93SWR4LFxuICBvbk1vdXNlRW50ZXIsXG4gIG9uUm93Q2hhbmdlLFxuICBzZWxlY3RDZWxsLFxuICAuLi5wcm9wc1xufSwgcmVmKSB7XG4gIGNvbnN0IGhhbmRsZVJvd0NoYW5nZSA9IHVzZUxhdGVzdEZ1bmMoKGNvbHVtbiwgbmV3Um93KSA9PiB7XG4gICAgb25Sb3dDaGFuZ2UoY29sdW1uLCByb3dJZHgsIG5ld1Jvdyk7XG4gIH0pO1xuICBmdW5jdGlvbiBoYW5kbGVEcmFnRW50ZXIoZXZlbnQpIHtcbiAgICBzZXREcmFnZ2VkT3ZlclJvd0lkeD8uKHJvd0lkeCk7XG4gICAgb25Nb3VzZUVudGVyPy4oZXZlbnQpO1xuICB9XG4gIGNsYXNzTmFtZSA9IGNsc3gocm93Q2xhc3NuYW1lLCBgcmRnLXJvdy0ke3Jvd0lkeCAlIDIgPT09IDAgPyAnZXZlbicgOiAnb2RkJ31gLCByb3dDbGFzcz8uKHJvdywgcm93SWR4KSwgY2xhc3NOYW1lLCBzZWxlY3RlZENlbGxJZHggPT09IC0xICYmIHJvd1NlbGVjdGVkQ2xhc3NuYW1lKTtcbiAgY29uc3QgY2VsbHMgPSBbXTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHZpZXdwb3J0Q29sdW1ucy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBjb2x1bW4gPSB2aWV3cG9ydENvbHVtbnNbaW5kZXhdO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkeFxuICAgIH0gPSBjb2x1bW47XG4gICAgY29uc3QgY29sU3BhbiA9IGdldENvbFNwYW4oY29sdW1uLCBsYXN0RnJvemVuQ29sdW1uSW5kZXgsIHtcbiAgICAgIHR5cGU6ICdST1cnLFxuICAgICAgcm93XG4gICAgfSk7XG4gICAgaWYgKGNvbFNwYW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5kZXggKz0gY29sU3BhbiAtIDE7XG4gICAgfVxuICAgIGNvbnN0IGlzQ2VsbFNlbGVjdGVkID0gc2VsZWN0ZWRDZWxsSWR4ID09PSBpZHg7XG4gICAgaWYgKGlzQ2VsbFNlbGVjdGVkICYmIHNlbGVjdGVkQ2VsbEVkaXRvcikge1xuICAgICAgY2VsbHMucHVzaChzZWxlY3RlZENlbGxFZGl0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZWxscy5wdXNoKCAvKiNfX1BVUkVfXyovanN4KENlbGwkMSwge1xuICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgY29sU3BhbjogY29sU3BhbixcbiAgICAgICAgcm93OiByb3csXG4gICAgICAgIHJvd0lkeDogcm93SWR4LFxuICAgICAgICBpc0NvcGllZDogY29waWVkQ2VsbElkeCA9PT0gaWR4LFxuICAgICAgICBpc0RyYWdnZWRPdmVyOiBkcmFnZ2VkT3ZlckNlbGxJZHggPT09IGlkeCxcbiAgICAgICAgaXNDZWxsU2VsZWN0ZWQ6IGlzQ2VsbFNlbGVjdGVkLFxuICAgICAgICBvbkNsaWNrOiBvbkNlbGxDbGljayxcbiAgICAgICAgb25Eb3VibGVDbGljazogb25DZWxsRG91YmxlQ2xpY2ssXG4gICAgICAgIG9uQ29udGV4dE1lbnU6IG9uQ2VsbENvbnRleHRNZW51LFxuICAgICAgICBvblJvd0NoYW5nZTogaGFuZGxlUm93Q2hhbmdlLFxuICAgICAgICBzZWxlY3RDZWxsOiBzZWxlY3RDZWxsXG4gICAgICB9LCBjb2x1bW4ua2V5KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFJvd1NlbGVjdGlvblByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGlzUm93U2VsZWN0ZWQsXG4gICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgICAgcm9sZTogXCJyb3dcIixcbiAgICAgIHJlZjogcmVmLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICBvbk1vdXNlRW50ZXI6IGhhbmRsZURyYWdFbnRlcixcbiAgICAgIHN0eWxlOiBnZXRSb3dTdHlsZShncmlkUm93U3RhcnQpLFxuICAgICAgLi4ucHJvcHMsXG4gICAgICBjaGlsZHJlbjogY2VsbHNcbiAgICB9KVxuICB9KTtcbn1cbmNvbnN0IFJvd0NvbXBvbmVudCA9IC8qI19fUFVSRV9fKi9tZW1vKCAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZihSb3cpKTtcbmNvbnN0IFJvd0NvbXBvbmVudCQxID0gUm93Q29tcG9uZW50O1xuZnVuY3Rpb24gZGVmYXVsdFJlbmRlclJvdyhrZXksIHByb3BzKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFJvd0NvbXBvbmVudCwge1xuICAgIC4uLnByb3BzXG4gIH0sIGtleSk7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbFRvQ2VsbCh7XG4gIHNjcm9sbFRvUG9zaXRpb246IHtcbiAgICBpZHgsXG4gICAgcm93SWR4XG4gIH0sXG4gIGdyaWRFbGVtZW50LFxuICBzZXRTY3JvbGxUb0NlbGxQb3NpdGlvblxufSkge1xuICBjb25zdCByZWYgPSB1c2VSZWYobnVsbCk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgc2Nyb2xsSW50b1ZpZXcocmVmLmN1cnJlbnQpO1xuICB9KTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBmdW5jdGlvbiByZW1vdmVTY3JvbGxUb0NlbGwoKSB7XG4gICAgICBzZXRTY3JvbGxUb0NlbGxQb3NpdGlvbihudWxsKTtcbiAgICB9XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIocmVtb3ZlU2Nyb2xsVG9DZWxsLCB7XG4gICAgICByb290OiBncmlkRWxlbWVudCxcbiAgICAgIHRocmVzaG9sZDogMS4wXG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShyZWYuY3VycmVudCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICB9LCBbZ3JpZEVsZW1lbnQsIHNldFNjcm9sbFRvQ2VsbFBvc2l0aW9uXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICByZWY6IHJlZixcbiAgICBzdHlsZToge1xuICAgICAgZ3JpZENvbHVtbjogaWR4ID09PSB1bmRlZmluZWQgPyAnMS8tMScgOiBpZHggKyAxLFxuICAgICAgZ3JpZFJvdzogcm93SWR4ID09PSB1bmRlZmluZWQgPyAnMS8tMScgOiByb3dJZHggKyAyXG4gICAgfVxuICB9KTtcbn1cblxuY29uc3QgYXJyb3cgPSBcImEzZWp0YXI3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCBhcnJvd0NsYXNzbmFtZSA9IGByZGctc29ydC1hcnJvdyAke2Fycm93fWA7XG5mdW5jdGlvbiByZW5kZXJTb3J0U3RhdHVzKHtcbiAgc29ydERpcmVjdGlvbixcbiAgcHJpb3JpdHlcbn0pIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3hzKEZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFtyZW5kZXJTb3J0SWNvbih7XG4gICAgICBzb3J0RGlyZWN0aW9uXG4gICAgfSksIHJlbmRlclNvcnRQcmlvcml0eSh7XG4gICAgICBwcmlvcml0eVxuICAgIH0pXVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbmRlclNvcnRJY29uKHtcbiAgc29ydERpcmVjdGlvblxufSkge1xuICBpZiAoc29ydERpcmVjdGlvbiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goXCJzdmdcIiwge1xuICAgIHZpZXdCb3g6IFwiMCAwIDEyIDhcIixcbiAgICB3aWR0aDogXCIxMlwiLFxuICAgIGhlaWdodDogXCI4XCIsXG4gICAgY2xhc3NOYW1lOiBhcnJvd0NsYXNzbmFtZSxcbiAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IHNvcnREaXJlY3Rpb24gPT09ICdBU0MnID8gJ00wIDggNiAwIDEyIDgnIDogJ00wIDAgNiA4IDEyIDAnXG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiByZW5kZXJTb3J0UHJpb3JpdHkoe1xuICBwcmlvcml0eVxufSkge1xuICByZXR1cm4gcHJpb3JpdHk7XG59XG5cbmNvbnN0IHJvb3QgPSBcInJudm9kejU3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCByb290Q2xhc3NuYW1lID0gYHJkZyAke3Jvb3R9YDtcbmNvbnN0IHZpZXdwb3J0RHJhZ2dpbmcgPSBcInZscXY5MWs3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCB2aWV3cG9ydERyYWdnaW5nQ2xhc3NuYW1lID0gYHJkZy12aWV3cG9ydC1kcmFnZ2luZyAke3ZpZXdwb3J0RHJhZ2dpbmd9YDtcbmNvbnN0IGZvY3VzU2lua0NsYXNzbmFtZSA9IFwiZjFsc2Zyenc3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCBmb2N1c1NpbmtIZWFkZXJBbmRTdW1tYXJ5Q2xhc3NuYW1lID0gXCJmMWN0ZTBsZzctMC0wLWJldGEtNDZcIjtcblxuY29uc3Qgc3VtbWFyeUNlbGxDbGFzc25hbWUgPSBcInM4d2M2Zmw3LTAtMC1iZXRhLTQ2XCI7XG5mdW5jdGlvbiBTdW1tYXJ5Q2VsbCh7XG4gIGNvbHVtbixcbiAgY29sU3BhbixcbiAgcm93LFxuICByb3dJZHgsXG4gIGlzQ2VsbFNlbGVjdGVkLFxuICBzZWxlY3RDZWxsXG59KSB7XG4gIGNvbnN0IHtcbiAgICB0YWJJbmRleCxcbiAgICBjaGlsZFRhYkluZGV4LFxuICAgIG9uRm9jdXNcbiAgfSA9IHVzZVJvdmluZ1RhYkluZGV4KGlzQ2VsbFNlbGVjdGVkKTtcbiAgY29uc3Qge1xuICAgIHN1bW1hcnlDZWxsQ2xhc3NcbiAgfSA9IGNvbHVtbjtcbiAgY29uc3QgY2xhc3NOYW1lID0gZ2V0Q2VsbENsYXNzbmFtZShjb2x1bW4sIHN1bW1hcnlDZWxsQ2xhc3NuYW1lLCB0eXBlb2Ygc3VtbWFyeUNlbGxDbGFzcyA9PT0gJ2Z1bmN0aW9uJyA/IHN1bW1hcnlDZWxsQ2xhc3Mocm93KSA6IHN1bW1hcnlDZWxsQ2xhc3MpO1xuICBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgIHNlbGVjdENlbGwoe1xuICAgICAgcm93SWR4LFxuICAgICAgaWR4OiBjb2x1bW4uaWR4XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgIHJvbGU6IFwiZ3JpZGNlbGxcIixcbiAgICBcImFyaWEtY29saW5kZXhcIjogY29sdW1uLmlkeCArIDEsXG4gICAgXCJhcmlhLWNvbHNwYW5cIjogY29sU3BhbixcbiAgICBcImFyaWEtc2VsZWN0ZWRcIjogaXNDZWxsU2VsZWN0ZWQsXG4gICAgdGFiSW5kZXg6IHRhYkluZGV4LFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIHN0eWxlOiBnZXRDZWxsU3R5bGUoY29sdW1uLCBjb2xTcGFuKSxcbiAgICBvbkNsaWNrOiBvbkNsaWNrLFxuICAgIG9uRm9jdXM6IG9uRm9jdXMsXG4gICAgY2hpbGRyZW46IGNvbHVtbi5yZW5kZXJTdW1tYXJ5Q2VsbD8uKHtcbiAgICAgIGNvbHVtbixcbiAgICAgIHJvdyxcbiAgICAgIHRhYkluZGV4OiBjaGlsZFRhYkluZGV4XG4gICAgfSlcbiAgfSk7XG59XG5jb25zdCBTdW1tYXJ5Q2VsbCQxID0gLyojX19QVVJFX18qL21lbW8oU3VtbWFyeUNlbGwpO1xuXG5jb25zdCBzdW1tYXJ5Um93ID0gXCJza3VocDU1Ny0wLTAtYmV0YS00NlwiO1xuY29uc3QgdG9wU3VtbWFyeVJvdyA9IFwidGY4bDV1YjctMC0wLWJldGEtNDZcIjtcbmNvbnN0IHN1bW1hcnlSb3dDbGFzc25hbWUgPSBgcmRnLXN1bW1hcnktcm93ICR7c3VtbWFyeVJvd31gO1xuZnVuY3Rpb24gU3VtbWFyeVJvdyh7XG4gIHJvd0lkeCxcbiAgZ3JpZFJvd1N0YXJ0LFxuICByb3csXG4gIHZpZXdwb3J0Q29sdW1ucyxcbiAgdG9wLFxuICBib3R0b20sXG4gIGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgc2VsZWN0ZWRDZWxsSWR4LFxuICBpc1RvcCxcbiAgc2VsZWN0Q2VsbCxcbiAgJ2FyaWEtcm93aW5kZXgnOiBhcmlhUm93SW5kZXhcbn0pIHtcbiAgY29uc3QgY2VsbHMgPSBbXTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHZpZXdwb3J0Q29sdW1ucy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBjb2x1bW4gPSB2aWV3cG9ydENvbHVtbnNbaW5kZXhdO1xuICAgIGNvbnN0IGNvbFNwYW4gPSBnZXRDb2xTcGFuKGNvbHVtbiwgbGFzdEZyb3plbkNvbHVtbkluZGV4LCB7XG4gICAgICB0eXBlOiAnU1VNTUFSWScsXG4gICAgICByb3dcbiAgICB9KTtcbiAgICBpZiAoY29sU3BhbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbmRleCArPSBjb2xTcGFuIC0gMTtcbiAgICB9XG4gICAgY29uc3QgaXNDZWxsU2VsZWN0ZWQgPSBzZWxlY3RlZENlbGxJZHggPT09IGNvbHVtbi5pZHg7XG4gICAgY2VsbHMucHVzaCggLyojX19QVVJFX18qL2pzeChTdW1tYXJ5Q2VsbCQxLCB7XG4gICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgIGNvbFNwYW46IGNvbFNwYW4sXG4gICAgICByb3c6IHJvdyxcbiAgICAgIHJvd0lkeDogcm93SWR4LFxuICAgICAgaXNDZWxsU2VsZWN0ZWQ6IGlzQ2VsbFNlbGVjdGVkLFxuICAgICAgc2VsZWN0Q2VsbDogc2VsZWN0Q2VsbFxuICAgIH0sIGNvbHVtbi5rZXkpKTtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChcImRpdlwiLCB7XG4gICAgcm9sZTogXCJyb3dcIixcbiAgICBcImFyaWEtcm93aW5kZXhcIjogYXJpYVJvd0luZGV4LFxuICAgIGNsYXNzTmFtZTogY2xzeChyb3dDbGFzc25hbWUsIGByZGctcm93LSR7cm93SWR4ICUgMiA9PT0gMCA/ICdldmVuJyA6ICdvZGQnfWAsIHN1bW1hcnlSb3dDbGFzc25hbWUsIGlzVG9wID8gYCR7dG9wU3VtbWFyeVJvd0NsYXNzbmFtZX0gJHt0b3BTdW1tYXJ5Um93fWAgOiBib3R0b21TdW1tYXJ5Um93Q2xhc3NuYW1lLCBzZWxlY3RlZENlbGxJZHggPT09IC0xICYmIHJvd1NlbGVjdGVkQ2xhc3NuYW1lKSxcbiAgICBzdHlsZToge1xuICAgICAgLi4uZ2V0Um93U3R5bGUoZ3JpZFJvd1N0YXJ0KSxcbiAgICAgICctLXJkZy1zdW1tYXJ5LXJvdy10b3AnOiB0b3AgIT09IHVuZGVmaW5lZCA/IGAke3RvcH1weGAgOiB1bmRlZmluZWQsXG4gICAgICAnLS1yZGctc3VtbWFyeS1yb3ctYm90dG9tJzogYm90dG9tICE9PSB1bmRlZmluZWQgPyBgJHtib3R0b219cHhgIDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICBjaGlsZHJlbjogY2VsbHNcbiAgfSk7XG59XG5jb25zdCBTdW1tYXJ5Um93JDEgPSAvKiNfX1BVUkVfXyovbWVtbyhTdW1tYXJ5Um93KTtcblxuZnVuY3Rpb24gRGF0YUdyaWQocHJvcHMsIHJlZikge1xuICBjb25zdCB7XG4gICAgY29sdW1uczogcmF3Q29sdW1ucyxcbiAgICByb3dzLFxuICAgIHRvcFN1bW1hcnlSb3dzLFxuICAgIGJvdHRvbVN1bW1hcnlSb3dzLFxuICAgIHJvd0tleUdldHRlcixcbiAgICBvblJvd3NDaGFuZ2UsXG4gICAgcm93SGVpZ2h0OiByYXdSb3dIZWlnaHQsXG4gICAgaGVhZGVyUm93SGVpZ2h0OiByYXdIZWFkZXJSb3dIZWlnaHQsXG4gICAgc3VtbWFyeVJvd0hlaWdodDogcmF3U3VtbWFyeVJvd0hlaWdodCxcbiAgICBzZWxlY3RlZFJvd3MsXG4gICAgb25TZWxlY3RlZFJvd3NDaGFuZ2UsXG4gICAgc29ydENvbHVtbnMsXG4gICAgb25Tb3J0Q29sdW1uc0NoYW5nZSxcbiAgICBkZWZhdWx0Q29sdW1uT3B0aW9ucyxcbiAgICBvbkNlbGxDbGljayxcbiAgICBvbkNlbGxEb3VibGVDbGljayxcbiAgICBvbkNlbGxDb250ZXh0TWVudSxcbiAgICBvbkNlbGxLZXlEb3duLFxuICAgIG9uU2VsZWN0ZWRDZWxsQ2hhbmdlLFxuICAgIG9uU2Nyb2xsLFxuICAgIG9uQ29sdW1uUmVzaXplLFxuICAgIG9uQ29sdW1uc1Jlb3JkZXIsXG4gICAgb25GaWxsLFxuICAgIG9uQ29weSxcbiAgICBvblBhc3RlLFxuICAgIGVuYWJsZVZpcnR1YWxpemF0aW9uOiByYXdFbmFibGVWaXJ0dWFsaXphdGlvbixcbiAgICByZW5kZXJlcnMsXG4gICAgY2xhc3NOYW1lLFxuICAgIHN0eWxlLFxuICAgIHJvd0NsYXNzLFxuICAgIGRpcmVjdGlvbjogcmF3RGlyZWN0aW9uLFxuICAgIHJvbGU6IHJhd1JvbGUsXG4gICAgJ2FyaWEtbGFiZWwnOiBhcmlhTGFiZWwsXG4gICAgJ2FyaWEtbGFiZWxsZWRieSc6IGFyaWFMYWJlbGxlZEJ5LFxuICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogYXJpYURlc2NyaWJlZEJ5LFxuICAgICdhcmlhLXJvd2NvdW50JzogcmF3QXJpYVJvd0NvdW50LFxuICAgICdkYXRhLXRlc3RpZCc6IHRlc3RJZFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGRlZmF1bHRSZW5kZXJlcnMgPSB1c2VEZWZhdWx0UmVuZGVyZXJzKCk7XG4gIGNvbnN0IHJvbGUgPSByYXdSb2xlID8/ICdncmlkJztcbiAgY29uc3Qgcm93SGVpZ2h0ID0gcmF3Um93SGVpZ2h0ID8/IDM1O1xuICBjb25zdCBoZWFkZXJSb3dIZWlnaHQgPSByYXdIZWFkZXJSb3dIZWlnaHQgPz8gKHR5cGVvZiByb3dIZWlnaHQgPT09ICdudW1iZXInID8gcm93SGVpZ2h0IDogMzUpO1xuICBjb25zdCBzdW1tYXJ5Um93SGVpZ2h0ID0gcmF3U3VtbWFyeVJvd0hlaWdodCA/PyAodHlwZW9mIHJvd0hlaWdodCA9PT0gJ251bWJlcicgPyByb3dIZWlnaHQgOiAzNSk7XG4gIGNvbnN0IHJlbmRlclJvdyA9IHJlbmRlcmVycz8ucmVuZGVyUm93ID8/IGRlZmF1bHRSZW5kZXJlcnM/LnJlbmRlclJvdyA/PyBkZWZhdWx0UmVuZGVyUm93O1xuICBjb25zdCByZW5kZXJTb3J0U3RhdHVzJDEgPSByZW5kZXJlcnM/LnJlbmRlclNvcnRTdGF0dXMgPz8gZGVmYXVsdFJlbmRlcmVycz8ucmVuZGVyU29ydFN0YXR1cyA/PyByZW5kZXJTb3J0U3RhdHVzO1xuICBjb25zdCByZW5kZXJDaGVja2JveCQxID0gcmVuZGVyZXJzPy5yZW5kZXJDaGVja2JveCA/PyBkZWZhdWx0UmVuZGVyZXJzPy5yZW5kZXJDaGVja2JveCA/PyByZW5kZXJDaGVja2JveDtcbiAgY29uc3Qgbm9Sb3dzRmFsbGJhY2sgPSByZW5kZXJlcnM/Lm5vUm93c0ZhbGxiYWNrID8/IGRlZmF1bHRSZW5kZXJlcnM/Lm5vUm93c0ZhbGxiYWNrO1xuICBjb25zdCBlbmFibGVWaXJ0dWFsaXphdGlvbiA9IHJhd0VuYWJsZVZpcnR1YWxpemF0aW9uID8/IHRydWU7XG4gIGNvbnN0IGRpcmVjdGlvbiA9IHJhd0RpcmVjdGlvbiA/PyAnbHRyJztcbiAgY29uc3QgW3Njcm9sbFRvcCwgc2V0U2Nyb2xsVG9wXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbc2Nyb2xsTGVmdCwgc2V0U2Nyb2xsTGVmdF0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW3Jlc2l6ZWRDb2x1bW5XaWR0aHMsIHNldFJlc2l6ZWRDb2x1bW5XaWR0aHNdID0gdXNlU3RhdGUoKCkgPT4gbmV3IE1hcCgpKTtcbiAgY29uc3QgW21lYXN1cmVkQ29sdW1uV2lkdGhzLCBzZXRNZWFzdXJlZENvbHVtbldpZHRoc10gPSB1c2VTdGF0ZSgoKSA9PiBuZXcgTWFwKCkpO1xuICBjb25zdCBbY29waWVkQ2VsbCwgc2V0Q29waWVkQ2VsbF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2lzRHJhZ2dpbmcsIHNldERyYWdnaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2RyYWdnZWRPdmVyUm93SWR4LCBzZXRPdmVyUm93SWR4XSA9IHVzZVN0YXRlKHVuZGVmaW5lZCk7XG4gIGNvbnN0IFtzY3JvbGxUb1Bvc2l0aW9uLCBzZXRTY3JvbGxUb1Bvc2l0aW9uXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBnZXRDb2x1bW5XaWR0aCA9IHVzZUNhbGxiYWNrKGNvbHVtbiA9PiB7XG4gICAgcmV0dXJuIHJlc2l6ZWRDb2x1bW5XaWR0aHMuZ2V0KGNvbHVtbi5rZXkpID8/IG1lYXN1cmVkQ29sdW1uV2lkdGhzLmdldChjb2x1bW4ua2V5KSA/PyBjb2x1bW4ud2lkdGg7XG4gIH0sIFttZWFzdXJlZENvbHVtbldpZHRocywgcmVzaXplZENvbHVtbldpZHRoc10pO1xuICBjb25zdCBbZ3JpZFJlZiwgZ3JpZFdpZHRoLCBncmlkSGVpZ2h0LCBob3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0XSA9IHVzZUdyaWREaW1lbnNpb25zKCk7XG4gIGNvbnN0IHtcbiAgICBjb2x1bW5zLFxuICAgIGNvbFNwYW5Db2x1bW5zLFxuICAgIGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgICBoZWFkZXJSb3dzQ291bnQsXG4gICAgY29sT3ZlcnNjYW5TdGFydElkeCxcbiAgICBjb2xPdmVyc2NhbkVuZElkeCxcbiAgICB0ZW1wbGF0ZUNvbHVtbnMsXG4gICAgbGF5b3V0Q3NzVmFycyxcbiAgICB0b3RhbEZyb3plbkNvbHVtbldpZHRoXG4gIH0gPSB1c2VDYWxjdWxhdGVkQ29sdW1ucyh7XG4gICAgcmF3Q29sdW1ucyxcbiAgICBkZWZhdWx0Q29sdW1uT3B0aW9ucyxcbiAgICBnZXRDb2x1bW5XaWR0aCxcbiAgICBzY3JvbGxMZWZ0LFxuICAgIHZpZXdwb3J0V2lkdGg6IGdyaWRXaWR0aCxcbiAgICBlbmFibGVWaXJ0dWFsaXphdGlvblxuICB9KTtcbiAgY29uc3QgdG9wU3VtbWFyeVJvd3NDb3VudCA9IHRvcFN1bW1hcnlSb3dzPy5sZW5ndGggPz8gMDtcbiAgY29uc3QgYm90dG9tU3VtbWFyeVJvd3NDb3VudCA9IGJvdHRvbVN1bW1hcnlSb3dzPy5sZW5ndGggPz8gMDtcbiAgY29uc3Qgc3VtbWFyeVJvd3NDb3VudCA9IHRvcFN1bW1hcnlSb3dzQ291bnQgKyBib3R0b21TdW1tYXJ5Um93c0NvdW50O1xuICBjb25zdCBoZWFkZXJBbmRUb3BTdW1tYXJ5Um93c0NvdW50ID0gaGVhZGVyUm93c0NvdW50ICsgdG9wU3VtbWFyeVJvd3NDb3VudDtcbiAgY29uc3QgZ3JvdXBlZENvbHVtbkhlYWRlclJvd3NDb3VudCA9IGhlYWRlclJvd3NDb3VudCAtIDE7XG4gIGNvbnN0IG1pblJvd0lkeCA9IC1oZWFkZXJBbmRUb3BTdW1tYXJ5Um93c0NvdW50O1xuICBjb25zdCBtYWluSGVhZGVyUm93SWR4ID0gbWluUm93SWR4ICsgZ3JvdXBlZENvbHVtbkhlYWRlclJvd3NDb3VudDtcbiAgY29uc3QgbWF4Um93SWR4ID0gcm93cy5sZW5ndGggKyBib3R0b21TdW1tYXJ5Um93c0NvdW50IC0gMTtcbiAgY29uc3QgW3NlbGVjdGVkUG9zaXRpb24sIHNldFNlbGVjdGVkUG9zaXRpb25dID0gdXNlU3RhdGUoKCkgPT4gKHtcbiAgICBpZHg6IC0xLFxuICAgIHJvd0lkeDogbWluUm93SWR4IC0gMSxcbiAgICBtb2RlOiAnU0VMRUNUJ1xuICB9KSk7XG4gIGNvbnN0IHByZXZTZWxlY3RlZFBvc2l0aW9uID0gdXNlUmVmKHNlbGVjdGVkUG9zaXRpb24pO1xuICBjb25zdCBsYXRlc3REcmFnZ2VkT3ZlclJvd0lkeCA9IHVzZVJlZihkcmFnZ2VkT3ZlclJvd0lkeCk7XG4gIGNvbnN0IGxhc3RTZWxlY3RlZFJvd0lkeCA9IHVzZVJlZigtMSk7XG4gIGNvbnN0IGZvY3VzU2lua1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qgc2hvdWxkRm9jdXNDZWxsUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgaXNUcmVlR3JpZCA9IHJvbGUgPT09ICd0cmVlZ3JpZCc7XG4gIGNvbnN0IGhlYWRlclJvd3NIZWlnaHQgPSBoZWFkZXJSb3dzQ291bnQgKiBoZWFkZXJSb3dIZWlnaHQ7XG4gIGNvbnN0IHN1bW1hcnlSb3dzSGVpZ2h0ID0gc3VtbWFyeVJvd3NDb3VudCAqIHN1bW1hcnlSb3dIZWlnaHQ7XG4gIGNvbnN0IGNsaWVudEhlaWdodCA9IGdyaWRIZWlnaHQgLSBoZWFkZXJSb3dzSGVpZ2h0IC0gc3VtbWFyeVJvd3NIZWlnaHQ7XG4gIGNvbnN0IGlzU2VsZWN0YWJsZSA9IHNlbGVjdGVkUm93cyAhPSBudWxsICYmIG9uU2VsZWN0ZWRSb3dzQ2hhbmdlICE9IG51bGw7XG4gIGNvbnN0IGlzUnRsID0gZGlyZWN0aW9uID09PSAncnRsJztcbiAgY29uc3QgbGVmdEtleSA9IGlzUnRsID8gJ0Fycm93UmlnaHQnIDogJ0Fycm93TGVmdCc7XG4gIGNvbnN0IHJpZ2h0S2V5ID0gaXNSdGwgPyAnQXJyb3dMZWZ0JyA6ICdBcnJvd1JpZ2h0JztcbiAgY29uc3QgYXJpYVJvd0NvdW50ID0gcmF3QXJpYVJvd0NvdW50ID8/IGhlYWRlclJvd3NDb3VudCArIHJvd3MubGVuZ3RoICsgc3VtbWFyeVJvd3NDb3VudDtcbiAgY29uc3QgZGVmYXVsdEdyaWRDb21wb25lbnRzID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIHJlbmRlckNoZWNrYm94OiByZW5kZXJDaGVja2JveCQxLFxuICAgIHJlbmRlclNvcnRTdGF0dXM6IHJlbmRlclNvcnRTdGF0dXMkMVxuICB9KSwgW3JlbmRlckNoZWNrYm94JDEsIHJlbmRlclNvcnRTdGF0dXMkMV0pO1xuICBjb25zdCBhbGxSb3dzU2VsZWN0ZWQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBsZW5ndGhcbiAgICB9ID0gcm93cztcbiAgICByZXR1cm4gbGVuZ3RoICE9PSAwICYmIHNlbGVjdGVkUm93cyAhPSBudWxsICYmIHJvd0tleUdldHRlciAhPSBudWxsICYmIHNlbGVjdGVkUm93cy5zaXplID49IGxlbmd0aCAmJiByb3dzLmV2ZXJ5KHJvdyA9PiBzZWxlY3RlZFJvd3MuaGFzKHJvd0tleUdldHRlcihyb3cpKSk7XG4gIH0sIFtyb3dzLCBzZWxlY3RlZFJvd3MsIHJvd0tleUdldHRlcl0pO1xuICBjb25zdCB7XG4gICAgcm93T3ZlcnNjYW5TdGFydElkeCxcbiAgICByb3dPdmVyc2NhbkVuZElkeCxcbiAgICB0b3RhbFJvd0hlaWdodCxcbiAgICBncmlkVGVtcGxhdGVSb3dzLFxuICAgIGdldFJvd1RvcCxcbiAgICBnZXRSb3dIZWlnaHQsXG4gICAgZmluZFJvd0lkeFxuICB9ID0gdXNlVmlld3BvcnRSb3dzKHtcbiAgICByb3dzLFxuICAgIHJvd0hlaWdodCxcbiAgICBjbGllbnRIZWlnaHQsXG4gICAgc2Nyb2xsVG9wLFxuICAgIGVuYWJsZVZpcnR1YWxpemF0aW9uXG4gIH0pO1xuICBjb25zdCB2aWV3cG9ydENvbHVtbnMgPSB1c2VWaWV3cG9ydENvbHVtbnMoe1xuICAgIGNvbHVtbnMsXG4gICAgY29sU3BhbkNvbHVtbnMsXG4gICAgY29sT3ZlcnNjYW5TdGFydElkeCxcbiAgICBjb2xPdmVyc2NhbkVuZElkeCxcbiAgICBsYXN0RnJvemVuQ29sdW1uSW5kZXgsXG4gICAgcm93T3ZlcnNjYW5TdGFydElkeCxcbiAgICByb3dPdmVyc2NhbkVuZElkeCxcbiAgICByb3dzLFxuICAgIHRvcFN1bW1hcnlSb3dzLFxuICAgIGJvdHRvbVN1bW1hcnlSb3dzXG4gIH0pO1xuICBjb25zdCB7XG4gICAgZ3JpZFRlbXBsYXRlQ29sdW1ucyxcbiAgICBoYW5kbGVDb2x1bW5SZXNpemVcbiAgfSA9IHVzZUNvbHVtbldpZHRocyhjb2x1bW5zLCB2aWV3cG9ydENvbHVtbnMsIHRlbXBsYXRlQ29sdW1ucywgZ3JpZFJlZiwgZ3JpZFdpZHRoLCByZXNpemVkQ29sdW1uV2lkdGhzLCBtZWFzdXJlZENvbHVtbldpZHRocywgc2V0UmVzaXplZENvbHVtbldpZHRocywgc2V0TWVhc3VyZWRDb2x1bW5XaWR0aHMsIG9uQ29sdW1uUmVzaXplKTtcbiAgY29uc3QgbWluQ29sSWR4ID0gaXNUcmVlR3JpZCA/IC0xIDogMDtcbiAgY29uc3QgbWF4Q29sSWR4ID0gY29sdW1ucy5sZW5ndGggLSAxO1xuICBjb25zdCBzZWxlY3RlZENlbGxJc1dpdGhpblNlbGVjdGlvbkJvdW5kcyA9IGlzQ2VsbFdpdGhpblNlbGVjdGlvbkJvdW5kcyhzZWxlY3RlZFBvc2l0aW9uKTtcbiAgY29uc3Qgc2VsZWN0ZWRDZWxsSXNXaXRoaW5WaWV3cG9ydEJvdW5kcyA9IGlzQ2VsbFdpdGhpblZpZXdwb3J0Qm91bmRzKHNlbGVjdGVkUG9zaXRpb24pO1xuICBjb25zdCBzY3JvbGxIZWlnaHQgPSBoZWFkZXJSb3dIZWlnaHQgKyB0b3RhbFJvd0hlaWdodCArIHN1bW1hcnlSb3dzSGVpZ2h0ICsgaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodDtcbiAgY29uc3QgaGFuZGxlQ29sdW1uUmVzaXplTGF0ZXN0ID0gdXNlTGF0ZXN0RnVuYyhoYW5kbGVDb2x1bW5SZXNpemUpO1xuICBjb25zdCBvbkNvbHVtbnNSZW9yZGVyTGFzdGVzdCA9IHVzZUxhdGVzdEZ1bmMob25Db2x1bW5zUmVvcmRlcik7XG4gIGNvbnN0IG9uU29ydENvbHVtbnNDaGFuZ2VMYXRlc3QgPSB1c2VMYXRlc3RGdW5jKG9uU29ydENvbHVtbnNDaGFuZ2UpO1xuICBjb25zdCBvbkNlbGxDbGlja0xhdGVzdCA9IHVzZUxhdGVzdEZ1bmMob25DZWxsQ2xpY2spO1xuICBjb25zdCBvbkNlbGxEb3VibGVDbGlja0xhdGVzdCA9IHVzZUxhdGVzdEZ1bmMob25DZWxsRG91YmxlQ2xpY2spO1xuICBjb25zdCBvbkNlbGxDb250ZXh0TWVudUxhdGVzdCA9IHVzZUxhdGVzdEZ1bmMob25DZWxsQ29udGV4dE1lbnUpO1xuICBjb25zdCBzZWxlY3RSb3dMYXRlc3QgPSB1c2VMYXRlc3RGdW5jKHNlbGVjdFJvdyk7XG4gIGNvbnN0IGhhbmRsZUZvcm1hdHRlclJvd0NoYW5nZUxhdGVzdCA9IHVzZUxhdGVzdEZ1bmModXBkYXRlUm93KTtcbiAgY29uc3Qgc2VsZWN0Q2VsbExhdGVzdCA9IHVzZUxhdGVzdEZ1bmMoc2VsZWN0Q2VsbCk7XG4gIGNvbnN0IHNlbGVjdEhlYWRlckNlbGxMYXRlc3QgPSB1c2VMYXRlc3RGdW5jKCh7XG4gICAgaWR4LFxuICAgIHJvd0lkeFxuICB9KSA9PiB7XG4gICAgc2VsZWN0Q2VsbCh7XG4gICAgICByb3dJZHg6IG1pblJvd0lkeCArIHJvd0lkeCAtIDEsXG4gICAgICBpZHhcbiAgICB9KTtcbiAgfSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFzZWxlY3RlZENlbGxJc1dpdGhpblNlbGVjdGlvbkJvdW5kcyB8fCBpc1NhbWVQb3NpdGlvbihzZWxlY3RlZFBvc2l0aW9uLCBwcmV2U2VsZWN0ZWRQb3NpdGlvbi5jdXJyZW50KSkge1xuICAgICAgcHJldlNlbGVjdGVkUG9zaXRpb24uY3VycmVudCA9IHNlbGVjdGVkUG9zaXRpb247XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByZXZTZWxlY3RlZFBvc2l0aW9uLmN1cnJlbnQgPSBzZWxlY3RlZFBvc2l0aW9uO1xuICAgIGlmIChzZWxlY3RlZFBvc2l0aW9uLmlkeCA9PT0gLTEpIHtcbiAgICAgIGZvY3VzU2lua1JlZi5jdXJyZW50LmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBzY3JvbGxJbnRvVmlldyhmb2N1c1NpbmtSZWYuY3VycmVudCk7XG4gICAgfVxuICB9KTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNob3VsZEZvY3VzQ2VsbFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgc2hvdWxkRm9jdXNDZWxsUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICBmb2N1c0NlbGxPckNlbGxDb250ZW50KCk7XG4gIH0pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gKHtcbiAgICBlbGVtZW50OiBncmlkUmVmLmN1cnJlbnQsXG4gICAgc2Nyb2xsVG9DZWxsKHtcbiAgICAgIGlkeCxcbiAgICAgIHJvd0lkeFxuICAgIH0pIHtcbiAgICAgIGNvbnN0IHNjcm9sbFRvSWR4ID0gaWR4ICE9PSB1bmRlZmluZWQgJiYgaWR4ID4gbGFzdEZyb3plbkNvbHVtbkluZGV4ICYmIGlkeCA8IGNvbHVtbnMubGVuZ3RoID8gaWR4IDogdW5kZWZpbmVkO1xuICAgICAgY29uc3Qgc2Nyb2xsVG9Sb3dJZHggPSByb3dJZHggIT09IHVuZGVmaW5lZCAmJiBpc1Jvd0lkeFdpdGhpblZpZXdwb3J0Qm91bmRzKHJvd0lkeCkgPyByb3dJZHggOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoc2Nyb2xsVG9JZHggIT09IHVuZGVmaW5lZCB8fCBzY3JvbGxUb1Jvd0lkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNldFNjcm9sbFRvUG9zaXRpb24oe1xuICAgICAgICAgIGlkeDogc2Nyb2xsVG9JZHgsXG4gICAgICAgICAgcm93SWR4OiBzY3JvbGxUb1Jvd0lkeFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNlbGVjdENlbGxcbiAgfSkpO1xuICBjb25zdCBzZXREcmFnZ2VkT3ZlclJvd0lkeCA9IHVzZUNhbGxiYWNrKHJvd0lkeCA9PiB7XG4gICAgc2V0T3ZlclJvd0lkeChyb3dJZHgpO1xuICAgIGxhdGVzdERyYWdnZWRPdmVyUm93SWR4LmN1cnJlbnQgPSByb3dJZHg7XG4gIH0sIFtdKTtcbiAgZnVuY3Rpb24gc2VsZWN0Um93KGFyZ3MpIHtcbiAgICBpZiAoIW9uU2VsZWN0ZWRSb3dzQ2hhbmdlKSByZXR1cm47XG4gICAgYXNzZXJ0SXNWYWxpZEtleUdldHRlcihyb3dLZXlHZXR0ZXIpO1xuICAgIGlmIChhcmdzLnR5cGUgPT09ICdIRUFERVInKSB7XG4gICAgICBjb25zdCBuZXdTZWxlY3RlZFJvd3MgPSBuZXcgU2V0KHNlbGVjdGVkUm93cyk7XG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgIGNvbnN0IHJvd0tleSA9IHJvd0tleUdldHRlcihyb3cpO1xuICAgICAgICBpZiAoYXJncy5jaGVja2VkKSB7XG4gICAgICAgICAgbmV3U2VsZWN0ZWRSb3dzLmFkZChyb3dLZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1NlbGVjdGVkUm93cy5kZWxldGUocm93S2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb25TZWxlY3RlZFJvd3NDaGFuZ2UobmV3U2VsZWN0ZWRSb3dzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcm93LFxuICAgICAgY2hlY2tlZCxcbiAgICAgIGlzU2hpZnRDbGlja1xuICAgIH0gPSBhcmdzO1xuICAgIGNvbnN0IG5ld1NlbGVjdGVkUm93cyA9IG5ldyBTZXQoc2VsZWN0ZWRSb3dzKTtcbiAgICBjb25zdCByb3dLZXkgPSByb3dLZXlHZXR0ZXIocm93KTtcbiAgICBjb25zdCBwcmV2aW91c1Jvd0lkeCA9IGxhc3RTZWxlY3RlZFJvd0lkeC5jdXJyZW50O1xuICAgIGNvbnN0IHJvd0lkeCA9IHJvd3MuaW5kZXhPZihyb3cpO1xuICAgIGxhc3RTZWxlY3RlZFJvd0lkeC5jdXJyZW50ID0gcm93SWR4O1xuICAgIGlmIChjaGVja2VkKSB7XG4gICAgICBuZXdTZWxlY3RlZFJvd3MuYWRkKHJvd0tleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1NlbGVjdGVkUm93cy5kZWxldGUocm93S2V5KTtcbiAgICB9XG4gICAgaWYgKGlzU2hpZnRDbGljayAmJiBwcmV2aW91c1Jvd0lkeCAhPT0gLTEgJiYgcHJldmlvdXNSb3dJZHggIT09IHJvd0lkeCAmJiBwcmV2aW91c1Jvd0lkeCA8IHJvd3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzdGVwID0gc2lnbihyb3dJZHggLSBwcmV2aW91c1Jvd0lkeCk7XG4gICAgICBmb3IgKGxldCBpID0gcHJldmlvdXNSb3dJZHggKyBzdGVwOyBpICE9PSByb3dJZHg7IGkgKz0gc3RlcCkge1xuICAgICAgICBjb25zdCByb3cgPSByb3dzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgIG5ld1NlbGVjdGVkUm93cy5hZGQocm93S2V5R2V0dGVyKHJvdykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1NlbGVjdGVkUm93cy5kZWxldGUocm93S2V5R2V0dGVyKHJvdykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG9uU2VsZWN0ZWRSb3dzQ2hhbmdlKG5ld1NlbGVjdGVkUm93cyk7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkeCxcbiAgICAgIHJvd0lkeCxcbiAgICAgIG1vZGVcbiAgICB9ID0gc2VsZWN0ZWRQb3NpdGlvbjtcbiAgICBpZiAobW9kZSA9PT0gJ0VESVQnKSByZXR1cm47XG4gICAgaWYgKG9uQ2VsbEtleURvd24gJiYgaXNSb3dJZHhXaXRoaW5WaWV3cG9ydEJvdW5kcyhyb3dJZHgpKSB7XG4gICAgICBjb25zdCByb3cgPSByb3dzW3Jvd0lkeF07XG4gICAgICBjb25zdCBjZWxsRXZlbnQgPSBjcmVhdGVDZWxsRXZlbnQoZXZlbnQpO1xuICAgICAgb25DZWxsS2V5RG93bih7XG4gICAgICAgIG1vZGU6ICdTRUxFQ1QnLFxuICAgICAgICByb3csXG4gICAgICAgIGNvbHVtbjogY29sdW1uc1tpZHhdLFxuICAgICAgICByb3dJZHgsXG4gICAgICAgIHNlbGVjdENlbGxcbiAgICAgIH0sIGNlbGxFdmVudCk7XG4gICAgICBpZiAoY2VsbEV2ZW50LmlzR3JpZERlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIShldmVudC50YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSkgcmV0dXJuO1xuICAgIGNvbnN0IGlzQ2VsbEV2ZW50ID0gZXZlbnQudGFyZ2V0LmNsb3Nlc3QoJy5yZGctY2VsbCcpICE9PSBudWxsO1xuICAgIGNvbnN0IGlzUm93RXZlbnQgPSBpc1RyZWVHcmlkICYmIGV2ZW50LnRhcmdldCA9PT0gZm9jdXNTaW5rUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFpc0NlbGxFdmVudCAmJiAhaXNSb3dFdmVudCkgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIGtleUNvZGVcbiAgICB9ID0gZXZlbnQ7XG4gICAgaWYgKHNlbGVjdGVkQ2VsbElzV2l0aGluVmlld3BvcnRCb3VuZHMgJiYgKG9uUGFzdGUgIT0gbnVsbCB8fCBvbkNvcHkgIT0gbnVsbCkgJiYgaXNDdHJsS2V5SGVsZERvd24oZXZlbnQpKSB7XG4gICAgICBjb25zdCBjS2V5ID0gNjc7XG4gICAgICBjb25zdCB2S2V5ID0gODY7XG4gICAgICBpZiAoa2V5Q29kZSA9PT0gY0tleSkge1xuICAgICAgICBpZiAod2luZG93LmdldFNlbGVjdGlvbigpPy5pc0NvbGxhcHNlZCA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgaGFuZGxlQ29weSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoa2V5Q29kZSA9PT0gdktleSkge1xuICAgICAgICBoYW5kbGVQYXN0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICBjYXNlICdFc2NhcGUnOlxuICAgICAgICBzZXRDb3BpZWRDZWxsKG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICBjYXNlICdBcnJvd0xlZnQnOlxuICAgICAgY2FzZSAnQXJyb3dSaWdodCc6XG4gICAgICBjYXNlICdUYWInOlxuICAgICAgY2FzZSAnSG9tZSc6XG4gICAgICBjYXNlICdFbmQnOlxuICAgICAgY2FzZSAnUGFnZVVwJzpcbiAgICAgIGNhc2UgJ1BhZ2VEb3duJzpcbiAgICAgICAgbmF2aWdhdGUoZXZlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGhhbmRsZUNlbGxJbnB1dChldmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVTY3JvbGwoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBzY3JvbGxUb3AsXG4gICAgICBzY3JvbGxMZWZ0XG4gICAgfSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgIHNldFNjcm9sbFRvcChzY3JvbGxUb3ApO1xuICAgICAgc2V0U2Nyb2xsTGVmdChhYnMoc2Nyb2xsTGVmdCkpO1xuICAgIH0pO1xuICAgIG9uU2Nyb2xsPy4oZXZlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVJvdyhjb2x1bW4sIHJvd0lkeCwgcm93KSB7XG4gICAgaWYgKHR5cGVvZiBvblJvd3NDaGFuZ2UgIT09ICdmdW5jdGlvbicpIHJldHVybjtcbiAgICBpZiAocm93ID09PSByb3dzW3Jvd0lkeF0pIHJldHVybjtcbiAgICBjb25zdCB1cGRhdGVkUm93cyA9IFsuLi5yb3dzXTtcbiAgICB1cGRhdGVkUm93c1tyb3dJZHhdID0gcm93O1xuICAgIG9uUm93c0NoYW5nZSh1cGRhdGVkUm93cywge1xuICAgICAgaW5kZXhlczogW3Jvd0lkeF0sXG4gICAgICBjb2x1bW5cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBjb21taXRFZGl0b3JDaGFuZ2VzKCkge1xuICAgIGlmIChzZWxlY3RlZFBvc2l0aW9uLm1vZGUgIT09ICdFRElUJykgcmV0dXJuO1xuICAgIHVwZGF0ZVJvdyhjb2x1bW5zW3NlbGVjdGVkUG9zaXRpb24uaWR4XSwgc2VsZWN0ZWRQb3NpdGlvbi5yb3dJZHgsIHNlbGVjdGVkUG9zaXRpb24ucm93KTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVDb3B5KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkeCxcbiAgICAgIHJvd0lkeFxuICAgIH0gPSBzZWxlY3RlZFBvc2l0aW9uO1xuICAgIGNvbnN0IHNvdXJjZVJvdyA9IHJvd3Nbcm93SWR4XTtcbiAgICBjb25zdCBzb3VyY2VDb2x1bW5LZXkgPSBjb2x1bW5zW2lkeF0ua2V5O1xuICAgIHNldENvcGllZENlbGwoe1xuICAgICAgcm93OiBzb3VyY2VSb3csXG4gICAgICBjb2x1bW5LZXk6IHNvdXJjZUNvbHVtbktleVxuICAgIH0pO1xuICAgIG9uQ29weT8uKHtcbiAgICAgIHNvdXJjZVJvdyxcbiAgICAgIHNvdXJjZUNvbHVtbktleVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVBhc3RlKCkge1xuICAgIGlmICghb25QYXN0ZSB8fCAhb25Sb3dzQ2hhbmdlIHx8IGNvcGllZENlbGwgPT09IG51bGwgfHwgIWlzQ2VsbEVkaXRhYmxlKHNlbGVjdGVkUG9zaXRpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGlkeCxcbiAgICAgIHJvd0lkeFxuICAgIH0gPSBzZWxlY3RlZFBvc2l0aW9uO1xuICAgIGNvbnN0IHRhcmdldENvbHVtbiA9IGNvbHVtbnNbaWR4XTtcbiAgICBjb25zdCB0YXJnZXRSb3cgPSByb3dzW3Jvd0lkeF07XG4gICAgY29uc3QgdXBkYXRlZFRhcmdldFJvdyA9IG9uUGFzdGUoe1xuICAgICAgc291cmNlUm93OiBjb3BpZWRDZWxsLnJvdyxcbiAgICAgIHNvdXJjZUNvbHVtbktleTogY29waWVkQ2VsbC5jb2x1bW5LZXksXG4gICAgICB0YXJnZXRSb3csXG4gICAgICB0YXJnZXRDb2x1bW5LZXk6IHRhcmdldENvbHVtbi5rZXlcbiAgICB9KTtcbiAgICB1cGRhdGVSb3codGFyZ2V0Q29sdW1uLCByb3dJZHgsIHVwZGF0ZWRUYXJnZXRSb3cpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZUNlbGxJbnB1dChldmVudCkge1xuICAgIGlmICghc2VsZWN0ZWRDZWxsSXNXaXRoaW5WaWV3cG9ydEJvdW5kcykgcmV0dXJuO1xuICAgIGNvbnN0IHJvdyA9IHJvd3Nbc2VsZWN0ZWRQb3NpdGlvbi5yb3dJZHhdO1xuICAgIGNvbnN0IHtcbiAgICAgIGtleSxcbiAgICAgIHNoaWZ0S2V5XG4gICAgfSA9IGV2ZW50O1xuICAgIGlmIChpc1NlbGVjdGFibGUgJiYgc2hpZnRLZXkgJiYga2V5ID09PSAnICcpIHtcbiAgICAgIGFzc2VydElzVmFsaWRLZXlHZXR0ZXIocm93S2V5R2V0dGVyKTtcbiAgICAgIGNvbnN0IHJvd0tleSA9IHJvd0tleUdldHRlcihyb3cpO1xuICAgICAgc2VsZWN0Um93KHtcbiAgICAgICAgdHlwZTogJ1JPVycsXG4gICAgICAgIHJvdyxcbiAgICAgICAgY2hlY2tlZDogIXNlbGVjdGVkUm93cy5oYXMocm93S2V5KSxcbiAgICAgICAgaXNTaGlmdENsaWNrOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNDZWxsRWRpdGFibGUoc2VsZWN0ZWRQb3NpdGlvbikgJiYgaXNEZWZhdWx0Q2VsbElucHV0KGV2ZW50KSkge1xuICAgICAgc2V0U2VsZWN0ZWRQb3NpdGlvbigoe1xuICAgICAgICBpZHgsXG4gICAgICAgIHJvd0lkeFxuICAgICAgfSkgPT4gKHtcbiAgICAgICAgaWR4LFxuICAgICAgICByb3dJZHgsXG4gICAgICAgIG1vZGU6ICdFRElUJyxcbiAgICAgICAgcm93LFxuICAgICAgICBvcmlnaW5hbFJvdzogcm93XG4gICAgICB9KSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGlzQ29sSWR4V2l0aGluU2VsZWN0aW9uQm91bmRzKGlkeCkge1xuICAgIHJldHVybiBpZHggPj0gbWluQ29sSWR4ICYmIGlkeCA8PSBtYXhDb2xJZHg7XG4gIH1cbiAgZnVuY3Rpb24gaXNSb3dJZHhXaXRoaW5WaWV3cG9ydEJvdW5kcyhyb3dJZHgpIHtcbiAgICByZXR1cm4gcm93SWR4ID49IDAgJiYgcm93SWR4IDwgcm93cy5sZW5ndGg7XG4gIH1cbiAgZnVuY3Rpb24gaXNDZWxsV2l0aGluU2VsZWN0aW9uQm91bmRzKHtcbiAgICBpZHgsXG4gICAgcm93SWR4XG4gIH0pIHtcbiAgICByZXR1cm4gcm93SWR4ID49IG1pblJvd0lkeCAmJiByb3dJZHggPD0gbWF4Um93SWR4ICYmIGlzQ29sSWR4V2l0aGluU2VsZWN0aW9uQm91bmRzKGlkeCk7XG4gIH1cbiAgZnVuY3Rpb24gaXNDZWxsV2l0aGluRWRpdEJvdW5kcyh7XG4gICAgaWR4LFxuICAgIHJvd0lkeFxuICB9KSB7XG4gICAgcmV0dXJuIGlzUm93SWR4V2l0aGluVmlld3BvcnRCb3VuZHMocm93SWR4KSAmJiBpZHggPj0gMCAmJiBpZHggPD0gbWF4Q29sSWR4O1xuICB9XG4gIGZ1bmN0aW9uIGlzQ2VsbFdpdGhpblZpZXdwb3J0Qm91bmRzKHtcbiAgICBpZHgsXG4gICAgcm93SWR4XG4gIH0pIHtcbiAgICByZXR1cm4gaXNSb3dJZHhXaXRoaW5WaWV3cG9ydEJvdW5kcyhyb3dJZHgpICYmIGlzQ29sSWR4V2l0aGluU2VsZWN0aW9uQm91bmRzKGlkeCk7XG4gIH1cbiAgZnVuY3Rpb24gaXNDZWxsRWRpdGFibGUocG9zaXRpb24pIHtcbiAgICByZXR1cm4gaXNDZWxsV2l0aGluRWRpdEJvdW5kcyhwb3NpdGlvbikgJiYgaXNTZWxlY3RlZENlbGxFZGl0YWJsZSh7XG4gICAgICBjb2x1bW5zLFxuICAgICAgcm93cyxcbiAgICAgIHNlbGVjdGVkUG9zaXRpb246IHBvc2l0aW9uXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc2VsZWN0Q2VsbChwb3NpdGlvbiwgZW5hYmxlRWRpdG9yKSB7XG4gICAgaWYgKCFpc0NlbGxXaXRoaW5TZWxlY3Rpb25Cb3VuZHMocG9zaXRpb24pKSByZXR1cm47XG4gICAgY29tbWl0RWRpdG9yQ2hhbmdlcygpO1xuICAgIGNvbnN0IHJvdyA9IHJvd3NbcG9zaXRpb24ucm93SWR4XTtcbiAgICBjb25zdCBzYW1lUG9zaXRpb24gPSBpc1NhbWVQb3NpdGlvbihzZWxlY3RlZFBvc2l0aW9uLCBwb3NpdGlvbik7XG4gICAgaWYgKGVuYWJsZUVkaXRvciAmJiBpc0NlbGxFZGl0YWJsZShwb3NpdGlvbikpIHtcbiAgICAgIHNldFNlbGVjdGVkUG9zaXRpb24oe1xuICAgICAgICAuLi5wb3NpdGlvbixcbiAgICAgICAgbW9kZTogJ0VESVQnLFxuICAgICAgICByb3csXG4gICAgICAgIG9yaWdpbmFsUm93OiByb3dcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoc2FtZVBvc2l0aW9uKSB7XG4gICAgICBzY3JvbGxJbnRvVmlldyhnZXRDZWxsVG9TY3JvbGwoZ3JpZFJlZi5jdXJyZW50KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZEZvY3VzQ2VsbFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIHNldFNlbGVjdGVkUG9zaXRpb24oe1xuICAgICAgICAuLi5wb3NpdGlvbixcbiAgICAgICAgbW9kZTogJ1NFTEVDVCdcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob25TZWxlY3RlZENlbGxDaGFuZ2UgJiYgIXNhbWVQb3NpdGlvbikge1xuICAgICAgb25TZWxlY3RlZENlbGxDaGFuZ2Uoe1xuICAgICAgICByb3dJZHg6IHBvc2l0aW9uLnJvd0lkeCxcbiAgICAgICAgcm93LFxuICAgICAgICBjb2x1bW46IGNvbHVtbnNbcG9zaXRpb24uaWR4XVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldE5leHRQb3NpdGlvbihrZXksIGN0cmxLZXksIHNoaWZ0S2V5KSB7XG4gICAgY29uc3Qge1xuICAgICAgaWR4LFxuICAgICAgcm93SWR4XG4gICAgfSA9IHNlbGVjdGVkUG9zaXRpb247XG4gICAgY29uc3QgaXNSb3dTZWxlY3RlZCA9IHNlbGVjdGVkQ2VsbElzV2l0aGluU2VsZWN0aW9uQm91bmRzICYmIGlkeCA9PT0gLTE7XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgJ0Fycm93VXAnOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkeCxcbiAgICAgICAgICByb3dJZHg6IHJvd0lkeCAtIDFcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWR4LFxuICAgICAgICAgIHJvd0lkeDogcm93SWR4ICsgMVxuICAgICAgICB9O1xuICAgICAgY2FzZSBsZWZ0S2V5OlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkeDogaWR4IC0gMSxcbiAgICAgICAgICByb3dJZHhcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgcmlnaHRLZXk6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWR4OiBpZHggKyAxLFxuICAgICAgICAgIHJvd0lkeFxuICAgICAgICB9O1xuICAgICAgY2FzZSAnVGFiJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZHg6IGlkeCArIChzaGlmdEtleSA/IC0xIDogMSksXG4gICAgICAgICAgcm93SWR4XG4gICAgICAgIH07XG4gICAgICBjYXNlICdIb21lJzpcbiAgICAgICAgaWYgKGlzUm93U2VsZWN0ZWQpIHJldHVybiB7XG4gICAgICAgICAgaWR4LFxuICAgICAgICAgIHJvd0lkeDogbWluUm93SWR4XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWR4OiAwLFxuICAgICAgICAgIHJvd0lkeDogY3RybEtleSA/IG1pblJvd0lkeCA6IHJvd0lkeFxuICAgICAgICB9O1xuICAgICAgY2FzZSAnRW5kJzpcbiAgICAgICAgaWYgKGlzUm93U2VsZWN0ZWQpIHJldHVybiB7XG4gICAgICAgICAgaWR4LFxuICAgICAgICAgIHJvd0lkeDogbWF4Um93SWR4XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWR4OiBtYXhDb2xJZHgsXG4gICAgICAgICAgcm93SWR4OiBjdHJsS2V5ID8gbWF4Um93SWR4IDogcm93SWR4XG4gICAgICAgIH07XG4gICAgICBjYXNlICdQYWdlVXAnOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkUG9zaXRpb24ucm93SWR4ID09PSBtaW5Sb3dJZHgpIHJldHVybiBzZWxlY3RlZFBvc2l0aW9uO1xuICAgICAgICAgIGNvbnN0IG5leHRSb3dZID0gZ2V0Um93VG9wKHJvd0lkeCkgKyBnZXRSb3dIZWlnaHQocm93SWR4KSAtIGNsaWVudEhlaWdodDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWR4LFxuICAgICAgICAgICAgcm93SWR4OiBuZXh0Um93WSA+IDAgPyBmaW5kUm93SWR4KG5leHRSb3dZKSA6IDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICBjYXNlICdQYWdlRG93bic6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWRQb3NpdGlvbi5yb3dJZHggPj0gcm93cy5sZW5ndGgpIHJldHVybiBzZWxlY3RlZFBvc2l0aW9uO1xuICAgICAgICAgIGNvbnN0IG5leHRSb3dZID0gZ2V0Um93VG9wKHJvd0lkeCkgKyBjbGllbnRIZWlnaHQ7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkeCxcbiAgICAgICAgICAgIHJvd0lkeDogbmV4dFJvd1kgPCB0b3RhbFJvd0hlaWdodCA/IGZpbmRSb3dJZHgobmV4dFJvd1kpIDogcm93cy5sZW5ndGggLSAxXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkUG9zaXRpb247XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG5hdmlnYXRlKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAga2V5LFxuICAgICAgc2hpZnRLZXlcbiAgICB9ID0gZXZlbnQ7XG4gICAgbGV0IGNlbGxOYXZpZ2F0aW9uTW9kZSA9ICdOT05FJztcbiAgICBpZiAoa2V5ID09PSAnVGFiJykge1xuICAgICAgaWYgKGNhbkV4aXRHcmlkKHtcbiAgICAgICAgc2hpZnRLZXksXG4gICAgICAgIG1heENvbElkeCxcbiAgICAgICAgbWluUm93SWR4LFxuICAgICAgICBtYXhSb3dJZHgsXG4gICAgICAgIHNlbGVjdGVkUG9zaXRpb25cbiAgICAgIH0pKSB7XG4gICAgICAgIGNvbW1pdEVkaXRvckNoYW5nZXMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2VsbE5hdmlnYXRpb25Nb2RlID0gJ0NIQU5HRV9ST1cnO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IGN0cmxLZXkgPSBpc0N0cmxLZXlIZWxkRG93bihldmVudCk7XG4gICAgY29uc3QgbmV4dFBvc2l0aW9uID0gZ2V0TmV4dFBvc2l0aW9uKGtleSwgY3RybEtleSwgc2hpZnRLZXkpO1xuICAgIGlmIChpc1NhbWVQb3NpdGlvbihzZWxlY3RlZFBvc2l0aW9uLCBuZXh0UG9zaXRpb24pKSByZXR1cm47XG4gICAgY29uc3QgbmV4dFNlbGVjdGVkQ2VsbFBvc2l0aW9uID0gZ2V0TmV4dFNlbGVjdGVkQ2VsbFBvc2l0aW9uKHtcbiAgICAgIG1vdmVVcDoga2V5ID09PSAnQXJyb3dVcCcsXG4gICAgICBtb3ZlTmV4dDoga2V5ID09PSByaWdodEtleSB8fCBrZXkgPT09ICdUYWInICYmICFzaGlmdEtleSxcbiAgICAgIGNvbHVtbnMsXG4gICAgICBjb2xTcGFuQ29sdW1ucyxcbiAgICAgIHJvd3MsXG4gICAgICB0b3BTdW1tYXJ5Um93cyxcbiAgICAgIGJvdHRvbVN1bW1hcnlSb3dzLFxuICAgICAgbWluUm93SWR4LFxuICAgICAgbWFpbkhlYWRlclJvd0lkeCxcbiAgICAgIG1heFJvd0lkeCxcbiAgICAgIGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgICAgIGNlbGxOYXZpZ2F0aW9uTW9kZSxcbiAgICAgIGN1cnJlbnRQb3NpdGlvbjogc2VsZWN0ZWRQb3NpdGlvbixcbiAgICAgIG5leHRQb3NpdGlvbixcbiAgICAgIGlzQ2VsbFdpdGhpbkJvdW5kczogaXNDZWxsV2l0aGluU2VsZWN0aW9uQm91bmRzXG4gICAgfSk7XG4gICAgc2VsZWN0Q2VsbChuZXh0U2VsZWN0ZWRDZWxsUG9zaXRpb24pO1xuICB9XG4gIGZ1bmN0aW9uIGdldERyYWdnZWRPdmVyQ2VsbElkeChjdXJyZW50Um93SWR4KSB7XG4gICAgaWYgKGRyYWdnZWRPdmVyUm93SWR4ID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICByb3dJZHhcbiAgICB9ID0gc2VsZWN0ZWRQb3NpdGlvbjtcbiAgICBjb25zdCBpc0RyYWdnZWRPdmVyID0gcm93SWR4IDwgZHJhZ2dlZE92ZXJSb3dJZHggPyByb3dJZHggPCBjdXJyZW50Um93SWR4ICYmIGN1cnJlbnRSb3dJZHggPD0gZHJhZ2dlZE92ZXJSb3dJZHggOiByb3dJZHggPiBjdXJyZW50Um93SWR4ICYmIGN1cnJlbnRSb3dJZHggPj0gZHJhZ2dlZE92ZXJSb3dJZHg7XG4gICAgcmV0dXJuIGlzRHJhZ2dlZE92ZXIgPyBzZWxlY3RlZFBvc2l0aW9uLmlkeCA6IHVuZGVmaW5lZDtcbiAgfVxuICBmdW5jdGlvbiBmb2N1c0NlbGxPckNlbGxDb250ZW50KCkge1xuICAgIGNvbnN0IGNlbGwgPSBnZXRDZWxsVG9TY3JvbGwoZ3JpZFJlZi5jdXJyZW50KTtcbiAgICBpZiAoY2VsbCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgIHNjcm9sbEludG9WaWV3KGNlbGwpO1xuICAgIGNvbnN0IGVsZW1lbnRUb0ZvY3VzID0gY2VsbC5xdWVyeVNlbGVjdG9yKCdbdGFiaW5kZXg9XCIwXCJdJykgPz8gY2VsbDtcbiAgICBlbGVtZW50VG9Gb2N1cy5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyRHJhZ0hhbmRsZSgpIHtcbiAgICBpZiAob25GaWxsID09IG51bGwgfHwgc2VsZWN0ZWRQb3NpdGlvbi5tb2RlID09PSAnRURJVCcgfHwgIWlzQ2VsbFdpdGhpblZpZXdwb3J0Qm91bmRzKHNlbGVjdGVkUG9zaXRpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGlkeCxcbiAgICAgIHJvd0lkeFxuICAgIH0gPSBzZWxlY3RlZFBvc2l0aW9uO1xuICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnNbaWR4XTtcbiAgICBpZiAoY29sdW1uLnJlbmRlckVkaXRDZWxsID09IG51bGwgfHwgY29sdW1uLmVkaXRhYmxlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb2x1bW5XaWR0aCA9IGdldENvbHVtbldpZHRoKGNvbHVtbik7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goRHJhZ0hhbmRsZSwge1xuICAgICAgZ3JpZFJvd1N0YXJ0OiBoZWFkZXJBbmRUb3BTdW1tYXJ5Um93c0NvdW50ICsgcm93SWR4ICsgMSxcbiAgICAgIHJvd3M6IHJvd3MsXG4gICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgIGNvbHVtbldpZHRoOiBjb2x1bW5XaWR0aCxcbiAgICAgIG1heENvbElkeDogbWF4Q29sSWR4LFxuICAgICAgaXNMYXN0Um93OiByb3dJZHggPT09IG1heFJvd0lkeCxcbiAgICAgIHNlbGVjdGVkUG9zaXRpb246IHNlbGVjdGVkUG9zaXRpb24sXG4gICAgICBpc0NlbGxFZGl0YWJsZTogaXNDZWxsRWRpdGFibGUsXG4gICAgICBsYXRlc3REcmFnZ2VkT3ZlclJvd0lkeDogbGF0ZXN0RHJhZ2dlZE92ZXJSb3dJZHgsXG4gICAgICBvblJvd3NDaGFuZ2U6IG9uUm93c0NoYW5nZSxcbiAgICAgIG9uQ2xpY2s6IGZvY3VzQ2VsbE9yQ2VsbENvbnRlbnQsXG4gICAgICBvbkZpbGw6IG9uRmlsbCxcbiAgICAgIHNldERyYWdnaW5nOiBzZXREcmFnZ2luZyxcbiAgICAgIHNldERyYWdnZWRPdmVyUm93SWR4OiBzZXREcmFnZ2VkT3ZlclJvd0lkeFxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdldENlbGxFZGl0b3Iocm93SWR4KSB7XG4gICAgaWYgKHNlbGVjdGVkUG9zaXRpb24ucm93SWR4ICE9PSByb3dJZHggfHwgc2VsZWN0ZWRQb3NpdGlvbi5tb2RlID09PSAnU0VMRUNUJykgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkeCxcbiAgICAgIHJvd1xuICAgIH0gPSBzZWxlY3RlZFBvc2l0aW9uO1xuICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnNbaWR4XTtcbiAgICBjb25zdCBjb2xTcGFuID0gZ2V0Q29sU3Bhbihjb2x1bW4sIGxhc3RGcm96ZW5Db2x1bW5JbmRleCwge1xuICAgICAgdHlwZTogJ1JPVycsXG4gICAgICByb3dcbiAgICB9KTtcbiAgICBjb25zdCBjbG9zZUVkaXRvciA9IHNob3VsZEZvY3VzQ2VsbCA9PiB7XG4gICAgICBzaG91bGRGb2N1c0NlbGxSZWYuY3VycmVudCA9IHNob3VsZEZvY3VzQ2VsbDtcbiAgICAgIHNldFNlbGVjdGVkUG9zaXRpb24oKHtcbiAgICAgICAgaWR4LFxuICAgICAgICByb3dJZHhcbiAgICAgIH0pID0+ICh7XG4gICAgICAgIGlkeCxcbiAgICAgICAgcm93SWR4LFxuICAgICAgICBtb2RlOiAnU0VMRUNUJ1xuICAgICAgfSkpO1xuICAgIH07XG4gICAgY29uc3Qgb25Sb3dDaGFuZ2UgPSAocm93LCBjb21taXRDaGFuZ2VzLCBzaG91bGRGb2N1c0NlbGwpID0+IHtcbiAgICAgIGlmIChjb21taXRDaGFuZ2VzKSB7XG4gICAgICAgIGZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgdXBkYXRlUm93KGNvbHVtbiwgc2VsZWN0ZWRQb3NpdGlvbi5yb3dJZHgsIHJvdyk7XG4gICAgICAgICAgY2xvc2VFZGl0b3Ioc2hvdWxkRm9jdXNDZWxsKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3RlZFBvc2l0aW9uKHBvc2l0aW9uID0+ICh7XG4gICAgICAgICAgLi4ucG9zaXRpb24sXG4gICAgICAgICAgcm93XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChyb3dzW3NlbGVjdGVkUG9zaXRpb24ucm93SWR4XSAhPT0gc2VsZWN0ZWRQb3NpdGlvbi5vcmlnaW5hbFJvdykge1xuICAgICAgY2xvc2VFZGl0b3IoZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gLyojX19QVVJFX18qL2pzeChFZGl0Q2VsbCwge1xuICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICBjb2xTcGFuOiBjb2xTcGFuLFxuICAgICAgcm93OiByb3csXG4gICAgICByb3dJZHg6IHJvd0lkeCxcbiAgICAgIG9uUm93Q2hhbmdlOiBvblJvd0NoYW5nZSxcbiAgICAgIGNsb3NlRWRpdG9yOiBjbG9zZUVkaXRvcixcbiAgICAgIG9uS2V5RG93bjogb25DZWxsS2V5RG93bixcbiAgICAgIG5hdmlnYXRlOiBuYXZpZ2F0ZVxuICAgIH0sIGNvbHVtbi5rZXkpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFJvd1ZpZXdwb3J0Q29sdW1ucyhyb3dJZHgpIHtcbiAgICBjb25zdCBzZWxlY3RlZENvbHVtbiA9IHNlbGVjdGVkUG9zaXRpb24uaWR4ID09PSAtMSA/IHVuZGVmaW5lZCA6IGNvbHVtbnNbc2VsZWN0ZWRQb3NpdGlvbi5pZHhdO1xuICAgIGlmIChzZWxlY3RlZENvbHVtbiAhPT0gdW5kZWZpbmVkICYmIHNlbGVjdGVkUG9zaXRpb24ucm93SWR4ID09PSByb3dJZHggJiYgIXZpZXdwb3J0Q29sdW1ucy5pbmNsdWRlcyhzZWxlY3RlZENvbHVtbikpIHtcbiAgICAgIHJldHVybiBzZWxlY3RlZFBvc2l0aW9uLmlkeCA+IGNvbE92ZXJzY2FuRW5kSWR4ID8gWy4uLnZpZXdwb3J0Q29sdW1ucywgc2VsZWN0ZWRDb2x1bW5dIDogWy4uLnZpZXdwb3J0Q29sdW1ucy5zbGljZSgwLCBsYXN0RnJvemVuQ29sdW1uSW5kZXggKyAxKSwgc2VsZWN0ZWRDb2x1bW4sIC4uLnZpZXdwb3J0Q29sdW1ucy5zbGljZShsYXN0RnJvemVuQ29sdW1uSW5kZXggKyAxKV07XG4gICAgfVxuICAgIHJldHVybiB2aWV3cG9ydENvbHVtbnM7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Vmlld3BvcnRSb3dzKCkge1xuICAgIGNvbnN0IHJvd0VsZW1lbnRzID0gW107XG4gICAgY29uc3Qge1xuICAgICAgaWR4OiBzZWxlY3RlZElkeCxcbiAgICAgIHJvd0lkeDogc2VsZWN0ZWRSb3dJZHhcbiAgICB9ID0gc2VsZWN0ZWRQb3NpdGlvbjtcbiAgICBjb25zdCBzdGFydFJvd0lkeCA9IHNlbGVjdGVkQ2VsbElzV2l0aGluVmlld3BvcnRCb3VuZHMgJiYgc2VsZWN0ZWRSb3dJZHggPCByb3dPdmVyc2NhblN0YXJ0SWR4ID8gcm93T3ZlcnNjYW5TdGFydElkeCAtIDEgOiByb3dPdmVyc2NhblN0YXJ0SWR4O1xuICAgIGNvbnN0IGVuZFJvd0lkeCA9IHNlbGVjdGVkQ2VsbElzV2l0aGluVmlld3BvcnRCb3VuZHMgJiYgc2VsZWN0ZWRSb3dJZHggPiByb3dPdmVyc2NhbkVuZElkeCA/IHJvd092ZXJzY2FuRW5kSWR4ICsgMSA6IHJvd092ZXJzY2FuRW5kSWR4O1xuICAgIGZvciAobGV0IHZpZXdwb3J0Um93SWR4ID0gc3RhcnRSb3dJZHg7IHZpZXdwb3J0Um93SWR4IDw9IGVuZFJvd0lkeDsgdmlld3BvcnRSb3dJZHgrKykge1xuICAgICAgY29uc3QgaXNSb3dPdXRzaWRlVmlld3BvcnQgPSB2aWV3cG9ydFJvd0lkeCA9PT0gcm93T3ZlcnNjYW5TdGFydElkeCAtIDEgfHwgdmlld3BvcnRSb3dJZHggPT09IHJvd092ZXJzY2FuRW5kSWR4ICsgMTtcbiAgICAgIGNvbnN0IHJvd0lkeCA9IGlzUm93T3V0c2lkZVZpZXdwb3J0ID8gc2VsZWN0ZWRSb3dJZHggOiB2aWV3cG9ydFJvd0lkeDtcbiAgICAgIGxldCByb3dDb2x1bW5zID0gdmlld3BvcnRDb2x1bW5zO1xuICAgICAgY29uc3Qgc2VsZWN0ZWRDb2x1bW4gPSBzZWxlY3RlZElkeCA9PT0gLTEgPyB1bmRlZmluZWQgOiBjb2x1bW5zW3NlbGVjdGVkSWR4XTtcbiAgICAgIGlmIChzZWxlY3RlZENvbHVtbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1Jvd091dHNpZGVWaWV3cG9ydCkge1xuICAgICAgICAgIHJvd0NvbHVtbnMgPSBbc2VsZWN0ZWRDb2x1bW5dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvd0NvbHVtbnMgPSBnZXRSb3dWaWV3cG9ydENvbHVtbnMocm93SWR4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgcm93ID0gcm93c1tyb3dJZHhdO1xuICAgICAgY29uc3QgZ3JpZFJvd1N0YXJ0ID0gaGVhZGVyQW5kVG9wU3VtbWFyeVJvd3NDb3VudCArIHJvd0lkeCArIDE7XG4gICAgICBsZXQga2V5ID0gcm93SWR4O1xuICAgICAgbGV0IGlzUm93U2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGlmICh0eXBlb2Ygcm93S2V5R2V0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGtleSA9IHJvd0tleUdldHRlcihyb3cpO1xuICAgICAgICBpc1Jvd1NlbGVjdGVkID0gc2VsZWN0ZWRSb3dzPy5oYXMoa2V5KSA/PyBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJvd0VsZW1lbnRzLnB1c2gocmVuZGVyUm93KGtleSwge1xuICAgICAgICAnYXJpYS1yb3dpbmRleCc6IGhlYWRlckFuZFRvcFN1bW1hcnlSb3dzQ291bnQgKyByb3dJZHggKyAxLFxuICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IGlzU2VsZWN0YWJsZSA/IGlzUm93U2VsZWN0ZWQgOiB1bmRlZmluZWQsXG4gICAgICAgIHJvd0lkeCxcbiAgICAgICAgcm93LFxuICAgICAgICB2aWV3cG9ydENvbHVtbnM6IHJvd0NvbHVtbnMsXG4gICAgICAgIGlzUm93U2VsZWN0ZWQsXG4gICAgICAgIG9uQ2VsbENsaWNrOiBvbkNlbGxDbGlja0xhdGVzdCxcbiAgICAgICAgb25DZWxsRG91YmxlQ2xpY2s6IG9uQ2VsbERvdWJsZUNsaWNrTGF0ZXN0LFxuICAgICAgICBvbkNlbGxDb250ZXh0TWVudTogb25DZWxsQ29udGV4dE1lbnVMYXRlc3QsXG4gICAgICAgIHJvd0NsYXNzLFxuICAgICAgICBncmlkUm93U3RhcnQsXG4gICAgICAgIGNvcGllZENlbGxJZHg6IGNvcGllZENlbGwgIT09IG51bGwgJiYgY29waWVkQ2VsbC5yb3cgPT09IHJvdyA/IGNvbHVtbnMuZmluZEluZGV4KGMgPT4gYy5rZXkgPT09IGNvcGllZENlbGwuY29sdW1uS2V5KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc2VsZWN0ZWRDZWxsSWR4OiBzZWxlY3RlZFJvd0lkeCA9PT0gcm93SWR4ID8gc2VsZWN0ZWRJZHggOiB1bmRlZmluZWQsXG4gICAgICAgIGRyYWdnZWRPdmVyQ2VsbElkeDogZ2V0RHJhZ2dlZE92ZXJDZWxsSWR4KHJvd0lkeCksXG4gICAgICAgIHNldERyYWdnZWRPdmVyUm93SWR4OiBpc0RyYWdnaW5nID8gc2V0RHJhZ2dlZE92ZXJSb3dJZHggOiB1bmRlZmluZWQsXG4gICAgICAgIGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgICAgICAgb25Sb3dDaGFuZ2U6IGhhbmRsZUZvcm1hdHRlclJvd0NoYW5nZUxhdGVzdCxcbiAgICAgICAgc2VsZWN0Q2VsbDogc2VsZWN0Q2VsbExhdGVzdCxcbiAgICAgICAgc2VsZWN0ZWRDZWxsRWRpdG9yOiBnZXRDZWxsRWRpdG9yKHJvd0lkeClcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvd0VsZW1lbnRzO1xuICB9XG4gIGlmIChzZWxlY3RlZFBvc2l0aW9uLmlkeCA+IG1heENvbElkeCB8fCBzZWxlY3RlZFBvc2l0aW9uLnJvd0lkeCA+IG1heFJvd0lkeCkge1xuICAgIHNldFNlbGVjdGVkUG9zaXRpb24oe1xuICAgICAgaWR4OiAtMSxcbiAgICAgIHJvd0lkeDogbWluUm93SWR4IC0gMSxcbiAgICAgIG1vZGU6ICdTRUxFQ1QnXG4gICAgfSk7XG4gICAgc2V0RHJhZ2dlZE92ZXJSb3dJZHgodW5kZWZpbmVkKTtcbiAgfVxuICBsZXQgdGVtcGxhdGVSb3dzID0gYHJlcGVhdCgke2hlYWRlclJvd3NDb3VudH0sICR7aGVhZGVyUm93SGVpZ2h0fXB4KWA7XG4gIGlmICh0b3BTdW1tYXJ5Um93c0NvdW50ID4gMCkge1xuICAgIHRlbXBsYXRlUm93cyArPSBgIHJlcGVhdCgke3RvcFN1bW1hcnlSb3dzQ291bnR9LCAke3N1bW1hcnlSb3dIZWlnaHR9cHgpYDtcbiAgfVxuICBpZiAocm93cy5sZW5ndGggPiAwKSB7XG4gICAgdGVtcGxhdGVSb3dzICs9IGdyaWRUZW1wbGF0ZVJvd3M7XG4gIH1cbiAgaWYgKGJvdHRvbVN1bW1hcnlSb3dzQ291bnQgPiAwKSB7XG4gICAgdGVtcGxhdGVSb3dzICs9IGAgcmVwZWF0KCR7Ym90dG9tU3VtbWFyeVJvd3NDb3VudH0sICR7c3VtbWFyeVJvd0hlaWdodH1weClgO1xuICB9XG4gIGNvbnN0IGlzR3JvdXBSb3dGb2N1c2VkID0gc2VsZWN0ZWRQb3NpdGlvbi5pZHggPT09IC0xICYmIHNlbGVjdGVkUG9zaXRpb24ucm93SWR4ICE9PSBtaW5Sb3dJZHggLSAxO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeHMoXCJkaXZcIiwge1xuICAgIHJvbGU6IHJvbGUsXG4gICAgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbCxcbiAgICBcImFyaWEtbGFiZWxsZWRieVwiOiBhcmlhTGFiZWxsZWRCeSxcbiAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogYXJpYURlc2NyaWJlZEJ5LFxuICAgIFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcIjogaXNTZWxlY3RhYmxlID8gdHJ1ZSA6IHVuZGVmaW5lZCxcbiAgICBcImFyaWEtY29sY291bnRcIjogY29sdW1ucy5sZW5ndGgsXG4gICAgXCJhcmlhLXJvd2NvdW50XCI6IGFyaWFSb3dDb3VudCxcbiAgICBjbGFzc05hbWU6IGNsc3gocm9vdENsYXNzbmFtZSwgY2xhc3NOYW1lLCBpc0RyYWdnaW5nICYmIHZpZXdwb3J0RHJhZ2dpbmdDbGFzc25hbWUpLFxuICAgIHN0eWxlOiB7XG4gICAgICAuLi5zdHlsZSxcbiAgICAgIHNjcm9sbFBhZGRpbmdJbmxpbmVTdGFydDogc2VsZWN0ZWRQb3NpdGlvbi5pZHggPiBsYXN0RnJvemVuQ29sdW1uSW5kZXggfHwgc2Nyb2xsVG9Qb3NpdGlvbj8uaWR4ICE9PSB1bmRlZmluZWQgPyBgJHt0b3RhbEZyb3plbkNvbHVtbldpZHRofXB4YCA6IHVuZGVmaW5lZCxcbiAgICAgIHNjcm9sbFBhZGRpbmdCbG9jazogaXNSb3dJZHhXaXRoaW5WaWV3cG9ydEJvdW5kcyhzZWxlY3RlZFBvc2l0aW9uLnJvd0lkeCkgfHwgc2Nyb2xsVG9Qb3NpdGlvbj8ucm93SWR4ICE9PSB1bmRlZmluZWQgPyBgJHtoZWFkZXJSb3dzSGVpZ2h0ICsgdG9wU3VtbWFyeVJvd3NDb3VudCAqIHN1bW1hcnlSb3dIZWlnaHR9cHggJHtib3R0b21TdW1tYXJ5Um93c0NvdW50ICogc3VtbWFyeVJvd0hlaWdodH1weGAgOiB1bmRlZmluZWQsXG4gICAgICBncmlkVGVtcGxhdGVDb2x1bW5zLFxuICAgICAgZ3JpZFRlbXBsYXRlUm93czogdGVtcGxhdGVSb3dzLFxuICAgICAgJy0tcmRnLWhlYWRlci1yb3ctaGVpZ2h0JzogYCR7aGVhZGVyUm93SGVpZ2h0fXB4YCxcbiAgICAgICctLXJkZy1zY3JvbGwtaGVpZ2h0JzogYCR7c2Nyb2xsSGVpZ2h0fXB4YCxcbiAgICAgIC4uLmxheW91dENzc1ZhcnNcbiAgICB9LFxuICAgIGRpcjogZGlyZWN0aW9uLFxuICAgIHJlZjogZ3JpZFJlZixcbiAgICBvblNjcm9sbDogaGFuZGxlU2Nyb2xsLFxuICAgIG9uS2V5RG93bjogaGFuZGxlS2V5RG93bixcbiAgICBcImRhdGEtdGVzdGlkXCI6IHRlc3RJZCxcbiAgICBjaGlsZHJlbjogWy8qI19fUFVSRV9fKi9qc3goRGF0YUdyaWREZWZhdWx0UmVuZGVyZXJzUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBkZWZhdWx0R3JpZENvbXBvbmVudHMsXG4gICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeHMoUm93U2VsZWN0aW9uQ2hhbmdlUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHNlbGVjdFJvd0xhdGVzdCxcbiAgICAgICAgY2hpbGRyZW46IFsvKiNfX1BVUkVfXyovanN4cyhSb3dTZWxlY3Rpb25Qcm92aWRlciwge1xuICAgICAgICAgIHZhbHVlOiBhbGxSb3dzU2VsZWN0ZWQsXG4gICAgICAgICAgY2hpbGRyZW46IFtBcnJheS5mcm9tKHtcbiAgICAgICAgICAgIGxlbmd0aDogZ3JvdXBlZENvbHVtbkhlYWRlclJvd3NDb3VudFxuICAgICAgICAgIH0sIChfLCBpbmRleCkgPT4gLyojX19QVVJFX18qL2pzeChHcm91cGVkQ29sdW1uSGVhZGVyUm93JDEsIHtcbiAgICAgICAgICAgIHJvd0lkeDogaW5kZXggKyAxLFxuICAgICAgICAgICAgbGV2ZWw6IC1ncm91cGVkQ29sdW1uSGVhZGVyUm93c0NvdW50ICsgaW5kZXgsXG4gICAgICAgICAgICBjb2x1bW5zOiBnZXRSb3dWaWV3cG9ydENvbHVtbnMobWluUm93SWR4ICsgaW5kZXgpLFxuICAgICAgICAgICAgc2VsZWN0ZWRDZWxsSWR4OiBzZWxlY3RlZFBvc2l0aW9uLnJvd0lkeCA9PT0gbWluUm93SWR4ICsgaW5kZXggPyBzZWxlY3RlZFBvc2l0aW9uLmlkeCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNlbGVjdENlbGw6IHNlbGVjdEhlYWRlckNlbGxMYXRlc3RcbiAgICAgICAgICB9LCBpbmRleCkpLCAvKiNfX1BVUkVfXyovanN4KEhlYWRlclJvdyQxLCB7XG4gICAgICAgICAgICByb3dJZHg6IGhlYWRlclJvd3NDb3VudCxcbiAgICAgICAgICAgIGNvbHVtbnM6IGdldFJvd1ZpZXdwb3J0Q29sdW1ucyhtYWluSGVhZGVyUm93SWR4KSxcbiAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplOiBoYW5kbGVDb2x1bW5SZXNpemVMYXRlc3QsXG4gICAgICAgICAgICBvbkNvbHVtbnNSZW9yZGVyOiBvbkNvbHVtbnNSZW9yZGVyTGFzdGVzdCxcbiAgICAgICAgICAgIHNvcnRDb2x1bW5zOiBzb3J0Q29sdW1ucyxcbiAgICAgICAgICAgIG9uU29ydENvbHVtbnNDaGFuZ2U6IG9uU29ydENvbHVtbnNDaGFuZ2VMYXRlc3QsXG4gICAgICAgICAgICBsYXN0RnJvemVuQ29sdW1uSW5kZXg6IGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgICAgICAgICAgIHNlbGVjdGVkQ2VsbElkeDogc2VsZWN0ZWRQb3NpdGlvbi5yb3dJZHggPT09IG1haW5IZWFkZXJSb3dJZHggPyBzZWxlY3RlZFBvc2l0aW9uLmlkeCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNlbGVjdENlbGw6IHNlbGVjdEhlYWRlckNlbGxMYXRlc3QsXG4gICAgICAgICAgICBzaG91bGRGb2N1c0dyaWQ6ICFzZWxlY3RlZENlbGxJc1dpdGhpblNlbGVjdGlvbkJvdW5kcyxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgICAgICAgfSldXG4gICAgICAgIH0pLCByb3dzLmxlbmd0aCA9PT0gMCAmJiBub1Jvd3NGYWxsYmFjayA/IG5vUm93c0ZhbGxiYWNrIDogLyojX19QVVJFX18qL2pzeHMoRnJhZ21lbnQsIHtcbiAgICAgICAgICBjaGlsZHJlbjogW3RvcFN1bW1hcnlSb3dzPy5tYXAoKHJvdywgcm93SWR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBncmlkUm93U3RhcnQgPSBoZWFkZXJSb3dzQ291bnQgKyAxICsgcm93SWR4O1xuICAgICAgICAgICAgY29uc3Qgc3VtbWFyeVJvd0lkeCA9IG1haW5IZWFkZXJSb3dJZHggKyAxICsgcm93SWR4O1xuICAgICAgICAgICAgY29uc3QgaXNTdW1tYXJ5Um93U2VsZWN0ZWQgPSBzZWxlY3RlZFBvc2l0aW9uLnJvd0lkeCA9PT0gc3VtbWFyeVJvd0lkeDtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGhlYWRlclJvd3NIZWlnaHQgKyBzdW1tYXJ5Um93SGVpZ2h0ICogcm93SWR4O1xuICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goU3VtbWFyeVJvdyQxLCB7XG4gICAgICAgICAgICAgIFwiYXJpYS1yb3dpbmRleFwiOiBncmlkUm93U3RhcnQsXG4gICAgICAgICAgICAgIHJvd0lkeDogc3VtbWFyeVJvd0lkeCxcbiAgICAgICAgICAgICAgZ3JpZFJvd1N0YXJ0OiBncmlkUm93U3RhcnQsXG4gICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgYm90dG9tOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHZpZXdwb3J0Q29sdW1uczogZ2V0Um93Vmlld3BvcnRDb2x1bW5zKHN1bW1hcnlSb3dJZHgpLFxuICAgICAgICAgICAgICBsYXN0RnJvemVuQ29sdW1uSW5kZXg6IGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgICAgICAgICAgICAgc2VsZWN0ZWRDZWxsSWR4OiBpc1N1bW1hcnlSb3dTZWxlY3RlZCA/IHNlbGVjdGVkUG9zaXRpb24uaWR4IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBpc1RvcDogdHJ1ZSxcbiAgICAgICAgICAgICAgc2VsZWN0Q2VsbDogc2VsZWN0Q2VsbExhdGVzdFxuICAgICAgICAgICAgfSwgcm93SWR4KTtcbiAgICAgICAgICB9KSwgZ2V0Vmlld3BvcnRSb3dzKCksIGJvdHRvbVN1bW1hcnlSb3dzPy5tYXAoKHJvdywgcm93SWR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBncmlkUm93U3RhcnQgPSBoZWFkZXJBbmRUb3BTdW1tYXJ5Um93c0NvdW50ICsgcm93cy5sZW5ndGggKyByb3dJZHggKyAxO1xuICAgICAgICAgICAgY29uc3Qgc3VtbWFyeVJvd0lkeCA9IHJvd3MubGVuZ3RoICsgcm93SWR4O1xuICAgICAgICAgICAgY29uc3QgaXNTdW1tYXJ5Um93U2VsZWN0ZWQgPSBzZWxlY3RlZFBvc2l0aW9uLnJvd0lkeCA9PT0gc3VtbWFyeVJvd0lkeDtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGNsaWVudEhlaWdodCA+IHRvdGFsUm93SGVpZ2h0ID8gZ3JpZEhlaWdodCAtIHN1bW1hcnlSb3dIZWlnaHQgKiAoYm90dG9tU3VtbWFyeVJvd3MubGVuZ3RoIC0gcm93SWR4KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IHRvcCA9PT0gdW5kZWZpbmVkID8gc3VtbWFyeVJvd0hlaWdodCAqIChib3R0b21TdW1tYXJ5Um93cy5sZW5ndGggLSAxIC0gcm93SWR4KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFN1bW1hcnlSb3ckMSwge1xuICAgICAgICAgICAgICBcImFyaWEtcm93aW5kZXhcIjogYXJpYVJvd0NvdW50IC0gYm90dG9tU3VtbWFyeVJvd3NDb3VudCArIHJvd0lkeCArIDEsXG4gICAgICAgICAgICAgIHJvd0lkeDogc3VtbWFyeVJvd0lkeCxcbiAgICAgICAgICAgICAgZ3JpZFJvd1N0YXJ0OiBncmlkUm93U3RhcnQsXG4gICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgYm90dG9tOiBib3R0b20sXG4gICAgICAgICAgICAgIHZpZXdwb3J0Q29sdW1uczogZ2V0Um93Vmlld3BvcnRDb2x1bW5zKHN1bW1hcnlSb3dJZHgpLFxuICAgICAgICAgICAgICBsYXN0RnJvemVuQ29sdW1uSW5kZXg6IGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgICAgICAgICAgICAgc2VsZWN0ZWRDZWxsSWR4OiBpc1N1bW1hcnlSb3dTZWxlY3RlZCA/IHNlbGVjdGVkUG9zaXRpb24uaWR4IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBpc1RvcDogZmFsc2UsXG4gICAgICAgICAgICAgIHNlbGVjdENlbGw6IHNlbGVjdENlbGxMYXRlc3RcbiAgICAgICAgICAgIH0sIHJvd0lkeCk7XG4gICAgICAgICAgfSldXG4gICAgICAgIH0pXVxuICAgICAgfSlcbiAgICB9KSwgcmVuZGVyRHJhZ0hhbmRsZSgpLCByZW5kZXJNZWFzdXJpbmdDZWxscyh2aWV3cG9ydENvbHVtbnMpLCBpc1RyZWVHcmlkICYmIC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgICAgcmVmOiBmb2N1c1NpbmtSZWYsXG4gICAgICB0YWJJbmRleDogaXNHcm91cFJvd0ZvY3VzZWQgPyAwIDogLTEsXG4gICAgICBjbGFzc05hbWU6IGNsc3goZm9jdXNTaW5rQ2xhc3NuYW1lLCBpc0dyb3VwUm93Rm9jdXNlZCAmJiBbcm93U2VsZWN0ZWQsIGxhc3RGcm96ZW5Db2x1bW5JbmRleCAhPT0gLTEgJiYgcm93U2VsZWN0ZWRXaXRoRnJvemVuQ2VsbF0sICFpc1Jvd0lkeFdpdGhpblZpZXdwb3J0Qm91bmRzKHNlbGVjdGVkUG9zaXRpb24ucm93SWR4KSAmJiBmb2N1c1NpbmtIZWFkZXJBbmRTdW1tYXJ5Q2xhc3NuYW1lKSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGdyaWRSb3dTdGFydDogc2VsZWN0ZWRQb3NpdGlvbi5yb3dJZHggKyBoZWFkZXJBbmRUb3BTdW1tYXJ5Um93c0NvdW50ICsgMVxuICAgICAgfVxuICAgIH0pLCBzY3JvbGxUb1Bvc2l0aW9uICE9PSBudWxsICYmIC8qI19fUFVSRV9fKi9qc3goU2Nyb2xsVG9DZWxsLCB7XG4gICAgICBzY3JvbGxUb1Bvc2l0aW9uOiBzY3JvbGxUb1Bvc2l0aW9uLFxuICAgICAgc2V0U2Nyb2xsVG9DZWxsUG9zaXRpb246IHNldFNjcm9sbFRvUG9zaXRpb24sXG4gICAgICBncmlkRWxlbWVudDogZ3JpZFJlZi5jdXJyZW50XG4gICAgfSldXG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0Q2VsbFRvU2Nyb2xsKGdyaWRFbCkge1xuICByZXR1cm4gZ3JpZEVsLnF1ZXJ5U2VsZWN0b3IoJzpzY29wZSA+IFtyb2xlPVwicm93XCJdID4gW3RhYmluZGV4PVwiMFwiXScpO1xufVxuZnVuY3Rpb24gaXNTYW1lUG9zaXRpb24ocDEsIHAyKSB7XG4gIHJldHVybiBwMS5pZHggPT09IHAyLmlkeCAmJiBwMS5yb3dJZHggPT09IHAyLnJvd0lkeDtcbn1cbmNvbnN0IERhdGFHcmlkJDEgPSAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZihEYXRhR3JpZCk7XG5cbmZ1bmN0aW9uIEdyb3VwQ2VsbCh7XG4gIGlkLFxuICBncm91cEtleSxcbiAgY2hpbGRSb3dzLFxuICBpc0V4cGFuZGVkLFxuICBpc0NlbGxTZWxlY3RlZCxcbiAgY29sdW1uLFxuICByb3csXG4gIGdyb3VwQ29sdW1uSW5kZXgsXG4gIGlzR3JvdXBCeUNvbHVtbixcbiAgdG9nZ2xlR3JvdXA6IHRvZ2dsZUdyb3VwV3JhcHBlclxufSkge1xuICBjb25zdCB7XG4gICAgdGFiSW5kZXgsXG4gICAgY2hpbGRUYWJJbmRleCxcbiAgICBvbkZvY3VzXG4gIH0gPSB1c2VSb3ZpbmdUYWJJbmRleChpc0NlbGxTZWxlY3RlZCk7XG4gIGZ1bmN0aW9uIHRvZ2dsZUdyb3VwKCkge1xuICAgIHRvZ2dsZUdyb3VwV3JhcHBlcihpZCk7XG4gIH1cbiAgY29uc3QgaXNMZXZlbE1hdGNoaW5nID0gaXNHcm91cEJ5Q29sdW1uICYmIGdyb3VwQ29sdW1uSW5kZXggPT09IGNvbHVtbi5pZHg7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICByb2xlOiBcImdyaWRjZWxsXCIsXG4gICAgXCJhcmlhLWNvbGluZGV4XCI6IGNvbHVtbi5pZHggKyAxLFxuICAgIFwiYXJpYS1zZWxlY3RlZFwiOiBpc0NlbGxTZWxlY3RlZCxcbiAgICB0YWJJbmRleDogdGFiSW5kZXgsXG4gICAgY2xhc3NOYW1lOiBnZXRDZWxsQ2xhc3NuYW1lKGNvbHVtbiksXG4gICAgc3R5bGU6IHtcbiAgICAgIC4uLmdldENlbGxTdHlsZShjb2x1bW4pLFxuICAgICAgY3Vyc29yOiBpc0xldmVsTWF0Y2hpbmcgPyAncG9pbnRlcicgOiAnZGVmYXVsdCdcbiAgICB9LFxuICAgIG9uQ2xpY2s6IGlzTGV2ZWxNYXRjaGluZyA/IHRvZ2dsZUdyb3VwIDogdW5kZWZpbmVkLFxuICAgIG9uRm9jdXM6IG9uRm9jdXMsXG4gICAgY2hpbGRyZW46ICghaXNHcm91cEJ5Q29sdW1uIHx8IGlzTGV2ZWxNYXRjaGluZykgJiYgY29sdW1uLnJlbmRlckdyb3VwQ2VsbD8uKHtcbiAgICAgIGdyb3VwS2V5LFxuICAgICAgY2hpbGRSb3dzLFxuICAgICAgY29sdW1uLFxuICAgICAgcm93LFxuICAgICAgaXNFeHBhbmRlZCxcbiAgICAgIHRhYkluZGV4OiBjaGlsZFRhYkluZGV4LFxuICAgICAgdG9nZ2xlR3JvdXBcbiAgICB9KVxuICB9LCBjb2x1bW4ua2V5KTtcbn1cbmNvbnN0IEdyb3VwQ2VsbCQxID0gLyojX19QVVJFX18qL21lbW8oR3JvdXBDZWxsKTtcblxuY29uc3QgZ3JvdXBSb3cgPSBcImcxeXhsdXYzNy0wLTAtYmV0YS00NlwiO1xuY29uc3QgZ3JvdXBSb3dDbGFzc25hbWUgPSBgcmRnLWdyb3VwLXJvdyAke2dyb3VwUm93fWA7XG5mdW5jdGlvbiBHcm91cGVkUm93KHtcbiAgY2xhc3NOYW1lLFxuICByb3csXG4gIHJvd0lkeCxcbiAgdmlld3BvcnRDb2x1bW5zLFxuICBzZWxlY3RlZENlbGxJZHgsXG4gIGlzUm93U2VsZWN0ZWQsXG4gIHNlbGVjdENlbGwsXG4gIGdyaWRSb3dTdGFydCxcbiAgZ3JvdXBCeSxcbiAgdG9nZ2xlR3JvdXAsXG4gIC4uLnByb3BzXG59KSB7XG4gIGNvbnN0IGlkeCA9IHZpZXdwb3J0Q29sdW1uc1swXS5rZXkgPT09IFNFTEVDVF9DT0xVTU5fS0VZID8gcm93LmxldmVsICsgMSA6IHJvdy5sZXZlbDtcbiAgZnVuY3Rpb24gaGFuZGxlU2VsZWN0R3JvdXAoKSB7XG4gICAgc2VsZWN0Q2VsbCh7XG4gICAgICByb3dJZHgsXG4gICAgICBpZHg6IC0xXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goUm93U2VsZWN0aW9uUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogaXNSb3dTZWxlY3RlZCxcbiAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChcImRpdlwiLCB7XG4gICAgICByb2xlOiBcInJvd1wiLFxuICAgICAgXCJhcmlhLWxldmVsXCI6IHJvdy5sZXZlbCArIDEsXG4gICAgICBcImFyaWEtc2V0c2l6ZVwiOiByb3cuc2V0U2l6ZSxcbiAgICAgIFwiYXJpYS1wb3NpbnNldFwiOiByb3cucG9zSW5TZXQgKyAxLFxuICAgICAgXCJhcmlhLWV4cGFuZGVkXCI6IHJvdy5pc0V4cGFuZGVkLFxuICAgICAgY2xhc3NOYW1lOiBjbHN4KHJvd0NsYXNzbmFtZSwgZ3JvdXBSb3dDbGFzc25hbWUsIGByZGctcm93LSR7cm93SWR4ICUgMiA9PT0gMCA/ICdldmVuJyA6ICdvZGQnfWAsIGNsYXNzTmFtZSwgc2VsZWN0ZWRDZWxsSWR4ID09PSAtMSAmJiByb3dTZWxlY3RlZENsYXNzbmFtZSksXG4gICAgICBvbkNsaWNrOiBoYW5kbGVTZWxlY3RHcm91cCxcbiAgICAgIHN0eWxlOiBnZXRSb3dTdHlsZShncmlkUm93U3RhcnQpLFxuICAgICAgLi4ucHJvcHMsXG4gICAgICBjaGlsZHJlbjogdmlld3BvcnRDb2x1bW5zLm1hcChjb2x1bW4gPT4gLyojX19QVVJFX18qL2pzeChHcm91cENlbGwkMSwge1xuICAgICAgICBpZDogcm93LmlkLFxuICAgICAgICBncm91cEtleTogcm93Lmdyb3VwS2V5LFxuICAgICAgICBjaGlsZFJvd3M6IHJvdy5jaGlsZFJvd3MsXG4gICAgICAgIGlzRXhwYW5kZWQ6IHJvdy5pc0V4cGFuZGVkLFxuICAgICAgICBpc0NlbGxTZWxlY3RlZDogc2VsZWN0ZWRDZWxsSWR4ID09PSBjb2x1bW4uaWR4LFxuICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgcm93OiByb3csXG4gICAgICAgIGdyb3VwQ29sdW1uSW5kZXg6IGlkeCxcbiAgICAgICAgdG9nZ2xlR3JvdXA6IHRvZ2dsZUdyb3VwLFxuICAgICAgICBpc0dyb3VwQnlDb2x1bW46IGdyb3VwQnkuaW5jbHVkZXMoY29sdW1uLmtleSlcbiAgICAgIH0sIGNvbHVtbi5rZXkpKVxuICAgIH0pXG4gIH0pO1xufVxuY29uc3QgR3JvdXBlZFJvdyQxID0gLyojX19QVVJFX18qL21lbW8oR3JvdXBlZFJvdyk7XG5cbmZ1bmN0aW9uIFRyZWVEYXRhR3JpZCh7XG4gIGNvbHVtbnM6IHJhd0NvbHVtbnMsXG4gIHJvd3M6IHJhd1Jvd3MsXG4gIHJvd0hlaWdodDogcmF3Um93SGVpZ2h0LFxuICByb3dLZXlHZXR0ZXI6IHJhd1Jvd0tleUdldHRlcixcbiAgb25DZWxsS2V5RG93bjogcmF3T25DZWxsS2V5RG93bixcbiAgb25Sb3dzQ2hhbmdlLFxuICBzZWxlY3RlZFJvd3M6IHJhd1NlbGVjdGVkUm93cyxcbiAgb25TZWxlY3RlZFJvd3NDaGFuZ2U6IHJhd09uU2VsZWN0ZWRSb3dzQ2hhbmdlLFxuICByZW5kZXJlcnMsXG4gIGdyb3VwQnk6IHJhd0dyb3VwQnksXG4gIHJvd0dyb3VwZXIsXG4gIGV4cGFuZGVkR3JvdXBJZHMsXG4gIG9uRXhwYW5kZWRHcm91cElkc0NoYW5nZSxcbiAgLi4ucHJvcHNcbn0sIHJlZikge1xuICBjb25zdCBkZWZhdWx0UmVuZGVyZXJzID0gdXNlRGVmYXVsdFJlbmRlcmVycygpO1xuICBjb25zdCByYXdSZW5kZXJSb3cgPSByZW5kZXJlcnM/LnJlbmRlclJvdyA/PyBkZWZhdWx0UmVuZGVyZXJzPy5yZW5kZXJSb3cgPz8gZGVmYXVsdFJlbmRlclJvdztcbiAgY29uc3QgaGVhZGVyQW5kVG9wU3VtbWFyeVJvd3NDb3VudCA9IDEgKyAocHJvcHMudG9wU3VtbWFyeVJvd3M/Lmxlbmd0aCA/PyAwKTtcbiAgY29uc3QgaXNSdGwgPSBwcm9wcy5kaXJlY3Rpb24gPT09ICdydGwnO1xuICBjb25zdCBsZWZ0S2V5ID0gaXNSdGwgPyAnQXJyb3dSaWdodCcgOiAnQXJyb3dMZWZ0JztcbiAgY29uc3QgcmlnaHRLZXkgPSBpc1J0bCA/ICdBcnJvd0xlZnQnIDogJ0Fycm93UmlnaHQnO1xuICBjb25zdCB0b2dnbGVHcm91cExhdGVzdCA9IHVzZUxhdGVzdEZ1bmModG9nZ2xlR3JvdXApO1xuICBjb25zdCB7XG4gICAgY29sdW1ucyxcbiAgICBncm91cEJ5XG4gIH0gPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBjb2x1bW5zID0gWy4uLnJhd0NvbHVtbnNdLnNvcnQoKHtcbiAgICAgIGtleTogYUtleVxuICAgIH0sIHtcbiAgICAgIGtleTogYktleVxuICAgIH0pID0+IHtcbiAgICAgIGlmIChhS2V5ID09PSBTRUxFQ1RfQ09MVU1OX0tFWSkgcmV0dXJuIC0xO1xuICAgICAgaWYgKGJLZXkgPT09IFNFTEVDVF9DT0xVTU5fS0VZKSByZXR1cm4gMTtcbiAgICAgIGlmIChyYXdHcm91cEJ5LmluY2x1ZGVzKGFLZXkpKSB7XG4gICAgICAgIGlmIChyYXdHcm91cEJ5LmluY2x1ZGVzKGJLZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIHJhd0dyb3VwQnkuaW5kZXhPZihhS2V5KSAtIHJhd0dyb3VwQnkuaW5kZXhPZihiS2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZiAocmF3R3JvdXBCeS5pbmNsdWRlcyhiS2V5KSkgcmV0dXJuIDE7XG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcbiAgICBjb25zdCBncm91cEJ5ID0gW107XG4gICAgZm9yIChjb25zdCBbaW5kZXgsIGNvbHVtbl0gb2YgY29sdW1ucy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChyYXdHcm91cEJ5LmluY2x1ZGVzKGNvbHVtbi5rZXkpKSB7XG4gICAgICAgIGdyb3VwQnkucHVzaChjb2x1bW4ua2V5KTtcbiAgICAgICAgY29sdW1uc1tpbmRleF0gPSB7XG4gICAgICAgICAgLi4uY29sdW1uLFxuICAgICAgICAgIGZyb3plbjogdHJ1ZSxcbiAgICAgICAgICByZW5kZXJDZWxsOiAoKSA9PiBudWxsLFxuICAgICAgICAgIHJlbmRlckdyb3VwQ2VsbDogY29sdW1uLnJlbmRlckdyb3VwQ2VsbCA/PyByZW5kZXJUb2dnbGVHcm91cCxcbiAgICAgICAgICBlZGl0YWJsZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtbnMsXG4gICAgICBncm91cEJ5XG4gICAgfTtcbiAgfSwgW3Jhd0NvbHVtbnMsIHJhd0dyb3VwQnldKTtcbiAgY29uc3QgW2dyb3VwZWRSb3dzLCByb3dzQ291bnRdID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKGdyb3VwQnkubGVuZ3RoID09PSAwKSByZXR1cm4gW3VuZGVmaW5lZCwgcmF3Um93cy5sZW5ndGhdO1xuICAgIGNvbnN0IGdyb3VwUm93cyA9IChyb3dzLCBbZ3JvdXBCeUtleSwgLi4ucmVtYWluaW5nR3JvdXBCeUtleXNdLCBzdGFydFJvd0luZGV4KSA9PiB7XG4gICAgICBsZXQgZ3JvdXBSb3dzQ291bnQgPSAwO1xuICAgICAgY29uc3QgZ3JvdXBzID0ge307XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIGNoaWxkUm93c10gb2YgT2JqZWN0LmVudHJpZXMocm93R3JvdXBlcihyb3dzLCBncm91cEJ5S2V5KSkpIHtcbiAgICAgICAgY29uc3QgW2NoaWxkR3JvdXBzLCBjaGlsZFJvd3NDb3VudF0gPSByZW1haW5pbmdHcm91cEJ5S2V5cy5sZW5ndGggPT09IDAgPyBbY2hpbGRSb3dzLCBjaGlsZFJvd3MubGVuZ3RoXSA6IGdyb3VwUm93cyhjaGlsZFJvd3MsIHJlbWFpbmluZ0dyb3VwQnlLZXlzLCBzdGFydFJvd0luZGV4ICsgZ3JvdXBSb3dzQ291bnQgKyAxKTtcbiAgICAgICAgZ3JvdXBzW2tleV0gPSB7XG4gICAgICAgICAgY2hpbGRSb3dzLFxuICAgICAgICAgIGNoaWxkR3JvdXBzLFxuICAgICAgICAgIHN0YXJ0Um93SW5kZXg6IHN0YXJ0Um93SW5kZXggKyBncm91cFJvd3NDb3VudFxuICAgICAgICB9O1xuICAgICAgICBncm91cFJvd3NDb3VudCArPSBjaGlsZFJvd3NDb3VudCArIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2dyb3VwcywgZ3JvdXBSb3dzQ291bnRdO1xuICAgIH07XG4gICAgcmV0dXJuIGdyb3VwUm93cyhyYXdSb3dzLCBncm91cEJ5LCAwKTtcbiAgfSwgW2dyb3VwQnksIHJvd0dyb3VwZXIsIHJhd1Jvd3NdKTtcbiAgY29uc3QgW3Jvd3MsIGlzR3JvdXBSb3ddID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgYWxsR3JvdXBSb3dzID0gbmV3IFNldCgpO1xuICAgIGlmICghZ3JvdXBlZFJvd3MpIHJldHVybiBbcmF3Um93cywgaXNHcm91cFJvd107XG4gICAgY29uc3QgZmxhdHRlbmVkUm93cyA9IFtdO1xuICAgIGNvbnN0IGV4cGFuZEdyb3VwID0gKHJvd3MsIHBhcmVudElkLCBsZXZlbCkgPT4ge1xuICAgICAgaWYgKGlzUmVhZG9ubHlBcnJheShyb3dzKSkge1xuICAgICAgICBmbGF0dGVuZWRSb3dzLnB1c2goLi4ucm93cyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5rZXlzKHJvd3MpLmZvckVhY2goKGdyb3VwS2V5LCBwb3NJblNldCwga2V5cykgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IHBhcmVudElkICE9PSB1bmRlZmluZWQgPyBgJHtwYXJlbnRJZH1fXyR7Z3JvdXBLZXl9YCA6IGdyb3VwS2V5O1xuICAgICAgICBjb25zdCBpc0V4cGFuZGVkID0gZXhwYW5kZWRHcm91cElkcy5oYXMoaWQpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY2hpbGRSb3dzLFxuICAgICAgICAgIGNoaWxkR3JvdXBzLFxuICAgICAgICAgIHN0YXJ0Um93SW5kZXhcbiAgICAgICAgfSA9IHJvd3NbZ3JvdXBLZXldO1xuICAgICAgICBjb25zdCBncm91cFJvdyA9IHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwYXJlbnRJZCxcbiAgICAgICAgICBncm91cEtleSxcbiAgICAgICAgICBpc0V4cGFuZGVkLFxuICAgICAgICAgIGNoaWxkUm93cyxcbiAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICBwb3NJblNldCxcbiAgICAgICAgICBzdGFydFJvd0luZGV4LFxuICAgICAgICAgIHNldFNpemU6IGtleXMubGVuZ3RoXG4gICAgICAgIH07XG4gICAgICAgIGZsYXR0ZW5lZFJvd3MucHVzaChncm91cFJvdyk7XG4gICAgICAgIGFsbEdyb3VwUm93cy5hZGQoZ3JvdXBSb3cpO1xuICAgICAgICBpZiAoaXNFeHBhbmRlZCkge1xuICAgICAgICAgIGV4cGFuZEdyb3VwKGNoaWxkR3JvdXBzLCBpZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBleHBhbmRHcm91cChncm91cGVkUm93cywgdW5kZWZpbmVkLCAwKTtcbiAgICByZXR1cm4gW2ZsYXR0ZW5lZFJvd3MsIGlzR3JvdXBSb3ddO1xuICAgIGZ1bmN0aW9uIGlzR3JvdXBSb3cocm93KSB7XG4gICAgICByZXR1cm4gYWxsR3JvdXBSb3dzLmhhcyhyb3cpO1xuICAgIH1cbiAgfSwgW2V4cGFuZGVkR3JvdXBJZHMsIGdyb3VwZWRSb3dzLCByYXdSb3dzXSk7XG4gIGNvbnN0IHJvd0hlaWdodCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgcmF3Um93SGVpZ2h0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcm93ID0+IHtcbiAgICAgICAgaWYgKGlzR3JvdXBSb3cocm93KSkge1xuICAgICAgICAgIHJldHVybiByYXdSb3dIZWlnaHQoe1xuICAgICAgICAgICAgdHlwZTogJ0dST1VQJyxcbiAgICAgICAgICAgIHJvd1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYXdSb3dIZWlnaHQoe1xuICAgICAgICAgIHR5cGU6ICdST1cnLFxuICAgICAgICAgIHJvd1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiByYXdSb3dIZWlnaHQ7XG4gIH0sIFtpc0dyb3VwUm93LCByYXdSb3dIZWlnaHRdKTtcbiAgY29uc3QgZ2V0UGFyZW50Um93QW5kSW5kZXggPSB1c2VDYWxsYmFjayhyb3cgPT4ge1xuICAgIGNvbnN0IHJvd0lkeCA9IHJvd3MuaW5kZXhPZihyb3cpO1xuICAgIGZvciAobGV0IGkgPSByb3dJZHggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgcGFyZW50Um93ID0gcm93c1tpXTtcbiAgICAgIGlmIChpc0dyb3VwUm93KHBhcmVudFJvdykgJiYgKCFpc0dyb3VwUm93KHJvdykgfHwgcm93LnBhcmVudElkID09PSBwYXJlbnRSb3cuaWQpKSB7XG4gICAgICAgIHJldHVybiBbcGFyZW50Um93LCBpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSwgW2lzR3JvdXBSb3csIHJvd3NdKTtcbiAgY29uc3Qgcm93S2V5R2V0dGVyID0gdXNlQ2FsbGJhY2socm93ID0+IHtcbiAgICBpZiAoaXNHcm91cFJvdyhyb3cpKSB7XG4gICAgICByZXR1cm4gcm93LmlkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJhd1Jvd0tleUdldHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHJhd1Jvd0tleUdldHRlcihyb3cpO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRSb3dBbmRJbmRleCA9IGdldFBhcmVudFJvd0FuZEluZGV4KHJvdyk7XG4gICAgaWYgKHBhcmVudFJvd0FuZEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RhcnRSb3dJbmRleCxcbiAgICAgICAgY2hpbGRSb3dzXG4gICAgICB9ID0gcGFyZW50Um93QW5kSW5kZXhbMF07XG4gICAgICBjb25zdCBncm91cEluZGV4ID0gY2hpbGRSb3dzLmluZGV4T2Yocm93KTtcbiAgICAgIHJldHVybiBzdGFydFJvd0luZGV4ICsgZ3JvdXBJbmRleCArIDE7XG4gICAgfVxuICAgIHJldHVybiByb3dzLmluZGV4T2Yocm93KTtcbiAgfSwgW2dldFBhcmVudFJvd0FuZEluZGV4LCBpc0dyb3VwUm93LCByYXdSb3dLZXlHZXR0ZXIsIHJvd3NdKTtcbiAgY29uc3Qgc2VsZWN0ZWRSb3dzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHJhd1NlbGVjdGVkUm93cyA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICBhc3NlcnRJc1ZhbGlkS2V5R2V0dGVyKHJhd1Jvd0tleUdldHRlcik7XG4gICAgY29uc3Qgc2VsZWN0ZWRSb3dzID0gbmV3IFNldChyYXdTZWxlY3RlZFJvd3MpO1xuICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgIGlmIChpc0dyb3VwUm93KHJvdykpIHtcbiAgICAgICAgY29uc3QgaXNHcm91cFJvd1NlbGVjdGVkID0gcm93LmNoaWxkUm93cy5ldmVyeShjciA9PiByYXdTZWxlY3RlZFJvd3MuaGFzKHJhd1Jvd0tleUdldHRlcihjcikpKTtcbiAgICAgICAgaWYgKGlzR3JvdXBSb3dTZWxlY3RlZCkge1xuICAgICAgICAgIHNlbGVjdGVkUm93cy5hZGQocm93LmlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRSb3dzO1xuICB9LCBbaXNHcm91cFJvdywgcmF3Um93S2V5R2V0dGVyLCByYXdTZWxlY3RlZFJvd3MsIHJvd3NdKTtcbiAgZnVuY3Rpb24gb25TZWxlY3RlZFJvd3NDaGFuZ2UobmV3U2VsZWN0ZWRSb3dzKSB7XG4gICAgaWYgKCFyYXdPblNlbGVjdGVkUm93c0NoYW5nZSkgcmV0dXJuO1xuICAgIGFzc2VydElzVmFsaWRLZXlHZXR0ZXIocmF3Um93S2V5R2V0dGVyKTtcbiAgICBjb25zdCBuZXdSYXdTZWxlY3RlZFJvd3MgPSBuZXcgU2V0KHJhd1NlbGVjdGVkUm93cyk7XG4gICAgZm9yIChjb25zdCByb3cgb2Ygcm93cykge1xuICAgICAgY29uc3Qga2V5ID0gcm93S2V5R2V0dGVyKHJvdyk7XG4gICAgICBpZiAoc2VsZWN0ZWRSb3dzPy5oYXMoa2V5KSAmJiAhbmV3U2VsZWN0ZWRSb3dzLmhhcyhrZXkpKSB7XG4gICAgICAgIGlmIChpc0dyb3VwUm93KHJvdykpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGNyIG9mIHJvdy5jaGlsZFJvd3MpIHtcbiAgICAgICAgICAgIG5ld1Jhd1NlbGVjdGVkUm93cy5kZWxldGUocmF3Um93S2V5R2V0dGVyKGNyKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1Jhd1NlbGVjdGVkUm93cy5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc2VsZWN0ZWRSb3dzPy5oYXMoa2V5KSAmJiBuZXdTZWxlY3RlZFJvd3MuaGFzKGtleSkpIHtcbiAgICAgICAgaWYgKGlzR3JvdXBSb3cocm93KSkge1xuICAgICAgICAgIGZvciAoY29uc3QgY3Igb2Ygcm93LmNoaWxkUm93cykge1xuICAgICAgICAgICAgbmV3UmF3U2VsZWN0ZWRSb3dzLmFkZChyYXdSb3dLZXlHZXR0ZXIoY3IpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3UmF3U2VsZWN0ZWRSb3dzLmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJhd09uU2VsZWN0ZWRSb3dzQ2hhbmdlKG5ld1Jhd1NlbGVjdGVkUm93cyk7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihhcmdzLCBldmVudCkge1xuICAgIHJhd09uQ2VsbEtleURvd24/LihhcmdzLCBldmVudCk7XG4gICAgaWYgKGV2ZW50LmlzR3JpZERlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuO1xuICAgIGlmIChhcmdzLm1vZGUgPT09ICdFRElUJykgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbHVtbixcbiAgICAgIHJvd0lkeCxcbiAgICAgIHNlbGVjdENlbGxcbiAgICB9ID0gYXJncztcbiAgICBjb25zdCBpZHggPSBjb2x1bW4/LmlkeCA/PyAtMTtcbiAgICBjb25zdCByb3cgPSByb3dzW3Jvd0lkeF07XG4gICAgaWYgKCFpc0dyb3VwUm93KHJvdykpIHJldHVybjtcbiAgICBpZiAoaWR4ID09PSAtMSAmJiAoZXZlbnQua2V5ID09PSBsZWZ0S2V5ICYmIHJvdy5pc0V4cGFuZGVkIHx8IGV2ZW50LmtleSA9PT0gcmlnaHRLZXkgJiYgIXJvdy5pc0V4cGFuZGVkKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnByZXZlbnRHcmlkRGVmYXVsdCgpO1xuICAgICAgdG9nZ2xlR3JvdXAocm93LmlkKTtcbiAgICB9XG4gICAgaWYgKGlkeCA9PT0gLTEgJiYgZXZlbnQua2V5ID09PSBsZWZ0S2V5ICYmICFyb3cuaXNFeHBhbmRlZCAmJiByb3cubGV2ZWwgIT09IDApIHtcbiAgICAgIGNvbnN0IHBhcmVudFJvd0FuZEluZGV4ID0gZ2V0UGFyZW50Um93QW5kSW5kZXgocm93KTtcbiAgICAgIGlmIChwYXJlbnRSb3dBbmRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnRHcmlkRGVmYXVsdCgpO1xuICAgICAgICBzZWxlY3RDZWxsKHtcbiAgICAgICAgICBpZHgsXG4gICAgICAgICAgcm93SWR4OiBwYXJlbnRSb3dBbmRJbmRleFsxXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQ3RybEtleUhlbGREb3duKGV2ZW50KSAmJiAoZXZlbnQua2V5Q29kZSA9PT0gNjcgfHwgZXZlbnQua2V5Q29kZSA9PT0gODYpKSB7XG4gICAgICBldmVudC5wcmV2ZW50R3JpZERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlUm93c0NoYW5nZSh1cGRhdGVkUm93cywge1xuICAgIGluZGV4ZXMsXG4gICAgY29sdW1uXG4gIH0pIHtcbiAgICBpZiAoIW9uUm93c0NoYW5nZSkgcmV0dXJuO1xuICAgIGNvbnN0IHVwZGF0ZWRSYXdSb3dzID0gWy4uLnJhd1Jvd3NdO1xuICAgIGNvbnN0IHJhd0luZGV4ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4ZXMpIHtcbiAgICAgIGNvbnN0IHJhd0luZGV4ID0gcmF3Um93cy5pbmRleE9mKHJvd3NbaW5kZXhdKTtcbiAgICAgIHVwZGF0ZWRSYXdSb3dzW3Jhd0luZGV4XSA9IHVwZGF0ZWRSb3dzW2luZGV4XTtcbiAgICAgIHJhd0luZGV4ZXMucHVzaChyYXdJbmRleCk7XG4gICAgfVxuICAgIG9uUm93c0NoYW5nZSh1cGRhdGVkUmF3Um93cywge1xuICAgICAgaW5kZXhlczogcmF3SW5kZXhlcyxcbiAgICAgIGNvbHVtblxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHRvZ2dsZUdyb3VwKGdyb3VwSWQpIHtcbiAgICBjb25zdCBuZXdFeHBhbmRlZEdyb3VwSWRzID0gbmV3IFNldChleHBhbmRlZEdyb3VwSWRzKTtcbiAgICBpZiAobmV3RXhwYW5kZWRHcm91cElkcy5oYXMoZ3JvdXBJZCkpIHtcbiAgICAgIG5ld0V4cGFuZGVkR3JvdXBJZHMuZGVsZXRlKGdyb3VwSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdFeHBhbmRlZEdyb3VwSWRzLmFkZChncm91cElkKTtcbiAgICB9XG4gICAgb25FeHBhbmRlZEdyb3VwSWRzQ2hhbmdlKG5ld0V4cGFuZGVkR3JvdXBJZHMpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlclJvdyhrZXksIHtcbiAgICByb3csXG4gICAgcm93Q2xhc3MsXG4gICAgb25DZWxsQ2xpY2ssXG4gICAgb25DZWxsRG91YmxlQ2xpY2ssXG4gICAgb25DZWxsQ29udGV4dE1lbnUsXG4gICAgb25Sb3dDaGFuZ2UsXG4gICAgbGFzdEZyb3plbkNvbHVtbkluZGV4LFxuICAgIGNvcGllZENlbGxJZHgsXG4gICAgZHJhZ2dlZE92ZXJDZWxsSWR4LFxuICAgIHNldERyYWdnZWRPdmVyUm93SWR4LFxuICAgIHNlbGVjdGVkQ2VsbEVkaXRvcixcbiAgICAuLi5yb3dQcm9wc1xuICB9KSB7XG4gICAgaWYgKGlzR3JvdXBSb3cocm93KSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdGFydFJvd0luZGV4XG4gICAgICB9ID0gcm93O1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goR3JvdXBlZFJvdyQxLCB7XG4gICAgICAgIC4uLnJvd1Byb3BzLFxuICAgICAgICBcImFyaWEtcm93aW5kZXhcIjogaGVhZGVyQW5kVG9wU3VtbWFyeVJvd3NDb3VudCArIHN0YXJ0Um93SW5kZXggKyAxLFxuICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgZ3JvdXBCeTogZ3JvdXBCeSxcbiAgICAgICAgdG9nZ2xlR3JvdXA6IHRvZ2dsZUdyb3VwTGF0ZXN0XG4gICAgICB9LCBrZXkpO1xuICAgIH1cbiAgICBsZXQgYXJpYVJvd0luZGV4ID0gcm93UHJvcHNbJ2FyaWEtcm93aW5kZXgnXTtcbiAgICBjb25zdCBwYXJlbnRSb3dBbmRJbmRleCA9IGdldFBhcmVudFJvd0FuZEluZGV4KHJvdyk7XG4gICAgaWYgKHBhcmVudFJvd0FuZEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RhcnRSb3dJbmRleCxcbiAgICAgICAgY2hpbGRSb3dzXG4gICAgICB9ID0gcGFyZW50Um93QW5kSW5kZXhbMF07XG4gICAgICBjb25zdCBncm91cEluZGV4ID0gY2hpbGRSb3dzLmluZGV4T2Yocm93KTtcbiAgICAgIGFyaWFSb3dJbmRleCA9IHN0YXJ0Um93SW5kZXggKyBoZWFkZXJBbmRUb3BTdW1tYXJ5Um93c0NvdW50ICsgZ3JvdXBJbmRleCArIDI7XG4gICAgfVxuICAgIHJldHVybiByYXdSZW5kZXJSb3coa2V5LCB7XG4gICAgICAuLi5yb3dQcm9wcyxcbiAgICAgICdhcmlhLXJvd2luZGV4JzogYXJpYVJvd0luZGV4LFxuICAgICAgcm93LFxuICAgICAgcm93Q2xhc3MsXG4gICAgICBvbkNlbGxDbGljayxcbiAgICAgIG9uQ2VsbERvdWJsZUNsaWNrLFxuICAgICAgb25DZWxsQ29udGV4dE1lbnUsXG4gICAgICBvblJvd0NoYW5nZSxcbiAgICAgIGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcbiAgICAgIGNvcGllZENlbGxJZHgsXG4gICAgICBkcmFnZ2VkT3ZlckNlbGxJZHgsXG4gICAgICBzZXREcmFnZ2VkT3ZlclJvd0lkeCxcbiAgICAgIHNlbGVjdGVkQ2VsbEVkaXRvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KERhdGFHcmlkJDEsIHtcbiAgICAuLi5wcm9wcyxcbiAgICByb2xlOiBcInRyZWVncmlkXCIsXG4gICAgXCJhcmlhLXJvd2NvdW50XCI6IHJvd3NDb3VudCArIDEgKyAocHJvcHMudG9wU3VtbWFyeVJvd3M/Lmxlbmd0aCA/PyAwKSArIChwcm9wcy5ib3R0b21TdW1tYXJ5Um93cz8ubGVuZ3RoID8/IDApLFxuICAgIHJlZjogcmVmLFxuICAgIGNvbHVtbnM6IGNvbHVtbnMsXG4gICAgcm93czogcm93cyxcbiAgICByb3dIZWlnaHQ6IHJvd0hlaWdodCxcbiAgICByb3dLZXlHZXR0ZXI6IHJvd0tleUdldHRlcixcbiAgICBvblJvd3NDaGFuZ2U6IGhhbmRsZVJvd3NDaGFuZ2UsXG4gICAgc2VsZWN0ZWRSb3dzOiBzZWxlY3RlZFJvd3MsXG4gICAgb25TZWxlY3RlZFJvd3NDaGFuZ2U6IG9uU2VsZWN0ZWRSb3dzQ2hhbmdlLFxuICAgIG9uQ2VsbEtleURvd246IGhhbmRsZUtleURvd24sXG4gICAgcmVuZGVyZXJzOiB7XG4gICAgICAuLi5yZW5kZXJlcnMsXG4gICAgICByZW5kZXJSb3dcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNSZWFkb25seUFycmF5KGFycikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpO1xufVxuY29uc3QgVHJlZURhdGFHcmlkJDEgPSAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZihUcmVlRGF0YUdyaWQpO1xuXG5jb25zdCB0ZXh0RWRpdG9ySW50ZXJuYWxDbGFzc25hbWUgPSBcInQ3dnl4M2k3LTAtMC1iZXRhLTQ2XCI7XG5jb25zdCB0ZXh0RWRpdG9yQ2xhc3NuYW1lID0gYHJkZy10ZXh0LWVkaXRvciAke3RleHRFZGl0b3JJbnRlcm5hbENsYXNzbmFtZX1gO1xuZnVuY3Rpb24gYXV0b0ZvY3VzQW5kU2VsZWN0KGlucHV0KSB7XG4gIGlucHV0Py5mb2N1cygpO1xuICBpbnB1dD8uc2VsZWN0KCk7XG59XG5mdW5jdGlvbiB0ZXh0RWRpdG9yKHtcbiAgcm93LFxuICBjb2x1bW4sXG4gIG9uUm93Q2hhbmdlLFxuICBvbkNsb3NlXG59KSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiaW5wdXRcIiwge1xuICAgIGNsYXNzTmFtZTogdGV4dEVkaXRvckNsYXNzbmFtZSxcbiAgICByZWY6IGF1dG9Gb2N1c0FuZFNlbGVjdCxcbiAgICB2YWx1ZTogcm93W2NvbHVtbi5rZXldLFxuICAgIG9uQ2hhbmdlOiBldmVudCA9PiBvblJvd0NoYW5nZSh7XG4gICAgICAuLi5yb3csXG4gICAgICBbY29sdW1uLmtleV06IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgIH0pLFxuICAgIG9uQmx1cjogKCkgPT4gb25DbG9zZSh0cnVlLCBmYWxzZSlcbiAgfSk7XG59XG5cbmV4cG9ydCB7IERhdGFHcmlkRGVmYXVsdFJlbmRlcmVyc1Byb3ZpZGVyLCBSb3dDb21wb25lbnQkMSBhcyBSb3csIFNFTEVDVF9DT0xVTU5fS0VZLCBTZWxlY3RDZWxsRm9ybWF0dGVyLCBTZWxlY3RDb2x1bW4sIFRvZ2dsZUdyb3VwLCBUcmVlRGF0YUdyaWQkMSBhcyBUcmVlRGF0YUdyaWQsIERhdGFHcmlkJDEgYXMgZGVmYXVsdCwgcmVuZGVyQ2hlY2tib3gsIHJlbmRlckhlYWRlckNlbGwsIHJlbmRlclNvcnRJY29uLCByZW5kZXJTb3J0UHJpb3JpdHksIHJlbmRlclRvZ2dsZUdyb3VwLCByZW5kZXJWYWx1ZSwgdGV4dEVkaXRvciwgdXNlUm93U2VsZWN0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idW5kbGUuanMubWFwXG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VNZW1vIiwidXNlRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0JDEiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwibWVtbyIsInVzZUlkIiwiZm9yd2FyZFJlZiIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJmbHVzaFN5bmMiLCJjbHN4IiwianN4IiwianN4cyIsIkZyYWdtZW50IiwiZ2V0Q29sU3BhbiIsImNvbHVtbiIsImxhc3RGcm96ZW5Db2x1bW5JbmRleCIsImFyZ3MiLCJjb2xTcGFuIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiZnJvemVuIiwiaWR4IiwidW5kZWZpbmVkIiwic3RvcFByb3BhZ2F0aW9uIiwiZXZlbnQiLCJzY3JvbGxJbnRvVmlldyIsImVsZW1lbnQiLCJpbmxpbmUiLCJibG9jayIsImNyZWF0ZUNlbGxFdmVudCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJjZWxsRXZlbnQiLCJwcmV2ZW50R3JpZERlZmF1bHQiLCJpc0dyaWREZWZhdWx0UHJldmVudGVkIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIm5vbklucHV0S2V5cyIsIlNldCIsImlzQ3RybEtleUhlbGREb3duIiwiZSIsImN0cmxLZXkiLCJtZXRhS2V5Iiwia2V5IiwiaXNEZWZhdWx0Q2VsbElucHV0IiwidktleSIsImtleUNvZGUiLCJoYXMiLCJvbkVkaXRvck5hdmlnYXRpb24iLCJ0YXJnZXQiLCJIVE1MSW5wdXRFbGVtZW50IiwiSFRNTFRleHRBcmVhRWxlbWVudCIsIkhUTUxTZWxlY3RFbGVtZW50IiwiY2xvc2VzdCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJsZW5ndGgiLCJtZWFzdXJpbmdDZWxsQ2xhc3NuYW1lIiwicmVuZGVyTWVhc3VyaW5nQ2VsbHMiLCJ2aWV3cG9ydENvbHVtbnMiLCJtYXAiLCJtaW5XaWR0aCIsIm1heFdpZHRoIiwiY2xhc3NOYW1lIiwic3R5bGUiLCJncmlkQ29sdW1uU3RhcnQiLCJpc1NlbGVjdGVkQ2VsbEVkaXRhYmxlIiwic2VsZWN0ZWRQb3NpdGlvbiIsImNvbHVtbnMiLCJyb3dzIiwicm93Iiwicm93SWR4IiwiaXNDZWxsRWRpdGFibGVVdGlsIiwicmVuZGVyRWRpdENlbGwiLCJlZGl0YWJsZSIsImdldFNlbGVjdGVkQ2VsbENvbFNwYW4iLCJ0b3BTdW1tYXJ5Um93cyIsImJvdHRvbVN1bW1hcnlSb3dzIiwibWFpbkhlYWRlclJvd0lkeCIsInRvcFN1bW1hcnlSb3dzQ291bnQiLCJ0eXBlIiwiZ2V0TmV4dFNlbGVjdGVkQ2VsbFBvc2l0aW9uIiwibW92ZVVwIiwibW92ZU5leHQiLCJjZWxsTmF2aWdhdGlvbk1vZGUiLCJjb2xTcGFuQ29sdW1ucyIsIm1pblJvd0lkeCIsIm1heFJvd0lkeCIsImN1cnJlbnRQb3NpdGlvbiIsImN1cnJlbnRJZHgiLCJjdXJyZW50Um93SWR4IiwibmV4dFBvc2l0aW9uIiwiaXNDZWxsV2l0aGluQm91bmRzIiwibmV4dElkeCIsIm5leHRSb3dJZHgiLCJjb2x1bW5zQ291bnQiLCJzZXRDb2xTcGFuIiwiY29sSWR4IiwiZ2V0UGFyZW50Um93SWR4IiwicGFyZW50IiwibGV2ZWwiLCJzZXRIZWFkZXJHcm91cENvbEFuZFJvd1NwYW4iLCJuZXh0Q29sdW1uIiwicGFyZW50Um93SWR4IiwiZm91bmQiLCJpc0FmdGVyTGFzdENvbHVtbiIsImlzQmVmb3JlRmlyc3RDb2x1bW4iLCJpc0xhc3RSb3ciLCJpc0ZpcnN0Um93IiwibmV4dFBhcmVudFJvd0lkeCIsImNhbkV4aXRHcmlkIiwibWF4Q29sSWR4Iiwic2hpZnRLZXkiLCJhdExhc3RDZWxsSW5Sb3ciLCJhdEZpcnN0Q2VsbEluUm93IiwiYXRMYXN0Um93IiwiYXRGaXJzdFJvdyIsImNlbGwiLCJjZWxsQ2xhc3NuYW1lIiwiY2VsbEZyb3plbiIsImNlbGxGcm96ZW5DbGFzc25hbWUiLCJnZXRSb3dTdHlsZSIsImdldEhlYWRlckNlbGxTdHlsZSIsInJvd1NwYW4iLCJncmlkUm93RW5kIiwicGFkZGluZ0Jsb2NrU3RhcnQiLCJpbnNldEJsb2NrU3RhcnQiLCJncmlkUm93U3RhcnQiLCJnZXRDZWxsU3R5bGUiLCJpbmRleCIsImdyaWRDb2x1bW5FbmQiLCJpbnNldElubGluZVN0YXJ0IiwiZ2V0Q2VsbENsYXNzbmFtZSIsImV4dHJhQ2xhc3NlcyIsIm1pbiIsIm1heCIsImZsb29yIiwic2lnbiIsImFicyIsIk1hdGgiLCJhc3NlcnRJc1ZhbGlkS2V5R2V0dGVyIiwia2V5R2V0dGVyIiwiRXJyb3IiLCJjbGFtcENvbHVtbldpZHRoIiwid2lkdGgiLCJnZXRIZWFkZXJDZWxsUm93U3BhbiIsImNoZWNrYm94Q29udGFpbmVyIiwiY2hlY2tib3giLCJjaGVja2JveENsYXNzbmFtZSIsInJlbmRlckNoZWNrYm94Iiwib25DaGFuZ2UiLCJwcm9wcyIsImhhbmRsZUNoYW5nZSIsImNoZWNrZWQiLCJuYXRpdmVFdmVudCIsImNoaWxkcmVuIiwiZ3JvdXBDZWxsQ29udGVudCIsImdyb3VwQ2VsbENvbnRlbnRDbGFzc25hbWUiLCJjYXJldCIsImNhcmV0Q2xhc3NuYW1lIiwicmVuZGVyVG9nZ2xlR3JvdXAiLCJUb2dnbGVHcm91cCIsImdyb3VwS2V5IiwiaXNFeHBhbmRlZCIsInRhYkluZGV4IiwidG9nZ2xlR3JvdXAiLCJoYW5kbGVLZXlEb3duIiwiZCIsIm9uS2V5RG93biIsInZpZXdCb3giLCJoZWlnaHQiLCJyZW5kZXJWYWx1ZSIsIkRhdGFHcmlkRGVmYXVsdFJlbmRlcmVyc0NvbnRleHQiLCJEYXRhR3JpZERlZmF1bHRSZW5kZXJlcnNQcm92aWRlciIsIlByb3ZpZGVyIiwidXNlRGVmYXVsdFJlbmRlcmVycyIsIlNlbGVjdENlbGxGb3JtYXR0ZXIiLCJ2YWx1ZSIsImRpc2FibGVkIiwiYXJpYUxhYmVsIiwiYXJpYUxhYmVsbGVkQnkiLCJSb3dTZWxlY3Rpb25Db250ZXh0IiwiUm93U2VsZWN0aW9uUHJvdmlkZXIiLCJSb3dTZWxlY3Rpb25DaGFuZ2VDb250ZXh0IiwiUm93U2VsZWN0aW9uQ2hhbmdlUHJvdmlkZXIiLCJ1c2VSb3dTZWxlY3Rpb24iLCJyb3dTZWxlY3Rpb25Db250ZXh0Iiwicm93U2VsZWN0aW9uQ2hhbmdlQ29udGV4dCIsIlNFTEVDVF9DT0xVTU5fS0VZIiwiSGVhZGVyUmVuZGVyZXIiLCJpc1Jvd1NlbGVjdGVkIiwib25Sb3dTZWxlY3Rpb25DaGFuZ2UiLCJTZWxlY3RGb3JtYXR0ZXIiLCJpc1NoaWZ0Q2xpY2siLCJTZWxlY3RHcm91cEZvcm1hdHRlciIsIlNlbGVjdENvbHVtbiIsIm5hbWUiLCJyZXNpemFibGUiLCJzb3J0YWJsZSIsInJlbmRlckhlYWRlckNlbGwiLCJyZW5kZXJDZWxsIiwicmVuZGVyR3JvdXBDZWxsIiwiREVGQVVMVF9DT0xVTU5fV0lEVEgiLCJERUZBVUxUX0NPTFVNTl9NSU5fV0lEVEgiLCJ1c2VDYWxjdWxhdGVkQ29sdW1ucyIsInJhd0NvbHVtbnMiLCJkZWZhdWx0Q29sdW1uT3B0aW9ucyIsImdldENvbHVtbldpZHRoIiwidmlld3BvcnRXaWR0aCIsInNjcm9sbExlZnQiLCJlbmFibGVWaXJ0dWFsaXphdGlvbiIsImRlZmF1bHRXaWR0aCIsImRlZmF1bHRNaW5XaWR0aCIsImRlZmF1bHRNYXhXaWR0aCIsImRlZmF1bHRDZWxsUmVuZGVyZXIiLCJkZWZhdWx0U29ydGFibGUiLCJkZWZhdWx0UmVzaXphYmxlIiwiZGVmYXVsdERyYWdnYWJsZSIsImRyYWdnYWJsZSIsImhlYWRlclJvd3NDb3VudCIsImNvbGxlY3RDb2x1bW5zIiwicmF3Q29sdW1uIiwiY2FsY3VsYXRlZENvbHVtblBhcmVudCIsImhlYWRlckNlbGxDbGFzcyIsInB1c2giLCJzb3J0IiwiYUtleSIsImZyb3plbkEiLCJiS2V5IiwiZnJvemVuQiIsImZvckVhY2giLCJ1cGRhdGVDb2x1bW5QYXJlbnQiLCJ0ZW1wbGF0ZUNvbHVtbnMiLCJsYXlvdXRDc3NWYXJzIiwidG90YWxGcm96ZW5Db2x1bW5XaWR0aCIsImNvbHVtbk1ldHJpY3MiLCJNYXAiLCJsZWZ0Iiwic2V0IiwiY29sdW1uTWV0cmljIiwiZ2V0IiwiaSIsImNvbE92ZXJzY2FuU3RhcnRJZHgiLCJjb2xPdmVyc2NhbkVuZElkeCIsInZpZXdwb3J0TGVmdCIsInZpZXdwb3J0UmlnaHQiLCJsYXN0Q29sSWR4IiwiZmlyc3RVbmZyb3plbkNvbHVtbklkeCIsImNvbFZpc2libGVTdGFydElkeCIsImNvbFZpc2libGVFbmRJZHgiLCJ1c2VDb2x1bW5XaWR0aHMiLCJncmlkUmVmIiwiZ3JpZFdpZHRoIiwicmVzaXplZENvbHVtbldpZHRocyIsIm1lYXN1cmVkQ29sdW1uV2lkdGhzIiwic2V0UmVzaXplZENvbHVtbldpZHRocyIsInNldE1lYXN1cmVkQ29sdW1uV2lkdGhzIiwib25Db2x1bW5SZXNpemUiLCJwcmV2R3JpZFdpZHRoUmVmIiwiY29sdW1uc0NhbkZsZXgiLCJpZ25vcmVQcmV2aW91c2x5TWVhc3VyZWRDb2x1bW5zIiwiY3VycmVudCIsIm5ld1RlbXBsYXRlQ29sdW1ucyIsImNvbHVtbnNUb01lYXN1cmUiLCJncmlkVGVtcGxhdGVDb2x1bW5zIiwiam9pbiIsInVwZGF0ZU1lYXN1cmVkV2lkdGhzIiwibmV3TWVhc3VyZWRDb2x1bW5XaWR0aHMiLCJoYXNDaGFuZ2VzIiwibWVhc3VyZWRXaWR0aCIsIm1lYXN1cmVDb2x1bW5XaWR0aCIsImRlbGV0ZSIsImhhbmRsZUNvbHVtblJlc2l6ZSIsIm5leHRXaWR0aCIsInJlc2l6aW5nS2V5IiwibmV3UmVzaXplZENvbHVtbldpZHRocyIsInNlbGVjdG9yIiwiQ1NTIiwiZXNjYXBlIiwibWVhc3VyaW5nQ2VsbCIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ1c2VHcmlkRGltZW5zaW9ucyIsImlubGluZVNpemUiLCJzZXRJbmxpbmVTaXplIiwiYmxvY2tTaXplIiwic2V0QmxvY2tTaXplIiwiaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCIsInNldEhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQiLCJSZXNpemVPYnNlcnZlciIsIndpbmRvdyIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJpbml0aWFsSG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCIsImluaXRpYWxXaWR0aCIsImluaXRpYWxIZWlnaHQiLCJyZXNpemVPYnNlcnZlciIsImVudHJpZXMiLCJzaXplIiwiY29udGVudEJveFNpemUiLCJvYnNlcnZlIiwiZGlzY29ubmVjdCIsInVzZUxhdGVzdEZ1bmMiLCJmbiIsInJlZiIsImNhbGxiYWNrRm4iLCJ1c2VSb3ZpbmdUYWJJbmRleCIsImlzU2VsZWN0ZWQiLCJpc0NoaWxkRm9jdXNlZCIsInNldElzQ2hpbGRGb2N1c2VkIiwib25Gb2N1cyIsImN1cnJlbnRUYXJnZXQiLCJpc0ZvY3VzYWJsZSIsImNoaWxkVGFiSW5kZXgiLCJ1c2VWaWV3cG9ydENvbHVtbnMiLCJyb3dPdmVyc2NhblN0YXJ0SWR4Iiwicm93T3ZlcnNjYW5FbmRJZHgiLCJzdGFydElkeCIsInVwZGF0ZVN0YXJ0SWR4IiwidXNlVmlld3BvcnRSb3dzIiwicm93SGVpZ2h0Iiwic2Nyb2xsVG9wIiwidG90YWxSb3dIZWlnaHQiLCJncmlkVGVtcGxhdGVSb3dzIiwiZ2V0Um93VG9wIiwiZ2V0Um93SGVpZ2h0IiwiZmluZFJvd0lkeCIsIm9mZnNldCIsInJvd1Bvc2l0aW9ucyIsImN1cnJlbnRSb3dIZWlnaHQiLCJwb3NpdGlvbiIsInRvcCIsInZhbGlkYXRlUm93SWR4Iiwic3RhcnQiLCJlbmQiLCJtaWRkbGUiLCJjdXJyZW50T2Zmc2V0Iiwib3ZlcnNjYW5UaHJlc2hvbGQiLCJyb3dWaXNpYmxlU3RhcnRJZHgiLCJyb3dWaXNpYmxlRW5kSWR4IiwiY2VsbERyYWdIYW5kbGUiLCJjZWxsRHJhZ0hhbmRsZUZyb3plbkNsYXNzbmFtZSIsImNlbGxEcmFnSGFuZGxlQ2xhc3NuYW1lIiwiRHJhZ0hhbmRsZSIsImNvbHVtbldpZHRoIiwibGF0ZXN0RHJhZ2dlZE92ZXJSb3dJZHgiLCJpc0NlbGxFZGl0YWJsZSIsIm9uUm93c0NoYW5nZSIsIm9uRmlsbCIsIm9uQ2xpY2siLCJzZXREcmFnZ2luZyIsInNldERyYWdnZWRPdmVyUm93SWR4IiwiaGFuZGxlTW91c2VEb3duIiwicHJldmVudERlZmF1bHQiLCJidXR0b25zIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uTW91c2VPdmVyIiwib25Nb3VzZVVwIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhbmRsZURyYWdFbmQiLCJvdmVyUm93SWR4Iiwic3RhcnRSb3dJbmRleCIsImVuZFJvd0luZGV4IiwidXBkYXRlUm93cyIsImhhbmRsZURvdWJsZUNsaWNrIiwic3RhcnRSb3dJZHgiLCJlbmRSb3dJZHgiLCJzb3VyY2VSb3ciLCJ1cGRhdGVkUm93cyIsImluZGV4ZXMiLCJ1cGRhdGVkUm93IiwiY29sdW1uS2V5IiwidGFyZ2V0Um93IiwiZ2V0U3R5bGUiLCJtYXJnaW5FbmQiLCJpc0xhc3RDb2x1bW4iLCJtYXJnaW5JbmxpbmVFbmQiLCJtYXJnaW5CbG9ja0VuZCIsIm9uTW91c2VEb3duIiwib25Eb3VibGVDbGljayIsImNlbGxFZGl0aW5nIiwiRWRpdENlbGwiLCJvblJvd0NoYW5nZSIsImNsb3NlRWRpdG9yIiwibmF2aWdhdGUiLCJmcmFtZVJlcXVlc3RSZWYiLCJjb21taXRPbk91dHNpZGVDbGljayIsImVkaXRvck9wdGlvbnMiLCJjb21taXRPbk91dHNpZGVNb3VzZURvd24iLCJvbkNsb3NlIiwib25XaW5kb3dDYXB0dXJlTW91c2VEb3duIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FwdHVyZSIsImNhbmNlbEZyYW1lUmVxdWVzdCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwibW9kZSIsImNvbW1pdENoYW5nZXMiLCJzaG91bGRGb2N1c0NlbGwiLCJvbkVkaXRvclJvd0NoYW5nZSIsImNvbW1pdENoYW5nZXNBbmRGb2N1cyIsImNlbGxDbGFzcyIsImRpc3BsYXlDZWxsQ29udGVudCIsInJvbGUiLCJvbk1vdXNlRG93bkNhcHR1cmUiLCJHcm91cGVkQ29sdW1uSGVhZGVyQ2VsbCIsImlzQ2VsbFNlbGVjdGVkIiwic2VsZWN0Q2VsbCIsImhlYWRlclNvcnRDZWxsQ2xhc3NuYW1lIiwiaGVhZGVyU29ydE5hbWUiLCJoZWFkZXJTb3J0TmFtZUNsYXNzbmFtZSIsInNvcnREaXJlY3Rpb24iLCJwcmlvcml0eSIsIlNvcnRhYmxlSGVhZGVyQ2VsbCIsInJlbmRlclNvcnRTdGF0dXMiLCJjZWxsU29ydGFibGVDbGFzc25hbWUiLCJjZWxsUmVzaXphYmxlIiwiY2VsbFJlc2l6YWJsZUNsYXNzbmFtZSIsInJlc2l6ZUhhbmRsZUNsYXNzbmFtZSIsImNlbGxEcmFnZ2FibGVDbGFzc25hbWUiLCJjZWxsRHJhZ2dpbmciLCJjZWxsRHJhZ2dpbmdDbGFzc25hbWUiLCJjZWxsT3ZlciIsImNlbGxPdmVyQ2xhc3NuYW1lIiwiSGVhZGVyQ2VsbCIsIm9uQ29sdW1uc1Jlb3JkZXIiLCJzb3J0Q29sdW1ucyIsIm9uU29ydENvbHVtbnNDaGFuZ2UiLCJzaG91bGRGb2N1c0dyaWQiLCJkaXJlY3Rpb24iLCJkcmFnRHJvcEtleSIsImlzRHJhZ2dpbmciLCJzZXRJc0RyYWdnaW5nIiwiaXNPdmVyIiwic2V0SXNPdmVyIiwiaXNSdGwiLCJzb3J0SW5kZXgiLCJmaW5kSW5kZXgiLCJzb3J0Q29sdW1uIiwiYXJpYVNvcnQiLCJyZW5kZXJIZWFkZXJDZWxsJDEiLCJvblBvaW50ZXJEb3duIiwicG9pbnRlclR5cGUiLCJwb2ludGVySWQiLCJoZWFkZXJDZWxsIiwicGFyZW50RWxlbWVudCIsInJpZ2h0IiwiY2xpZW50WCIsIm9uUG9pbnRlck1vdmUiLCJvbkxvc3RQb2ludGVyQ2FwdHVyZSIsInNldFBvaW50ZXJDYXB0dXJlIiwib25Tb3J0IiwiY3RybENsaWNrIiwic29ydERlc2NlbmRpbmdGaXJzdCIsIm5leHRTb3J0IiwibmV4dFNvcnRDb2x1bW4iLCJuZXh0U29ydENvbHVtbnMiLCJzcGxpY2UiLCJoYW5kbGVGb2N1cyIsIm9uRHJhZ1N0YXJ0IiwiZGF0YVRyYW5zZmVyIiwic2V0RGF0YSIsImRyb3BFZmZlY3QiLCJvbkRyYWdFbmQiLCJvbkRyYWdPdmVyIiwib25Ecm9wIiwidHlwZXMiLCJpbmNsdWRlcyIsInNvdXJjZUtleSIsImdldERhdGEiLCJvbkRyYWdFbnRlciIsImlzRXZlbnRQZXJ0aW5lbnQiLCJvbkRyYWdMZWF2ZSIsImRyYWdnYWJsZVByb3BzIiwicmVsYXRlZFRhcmdldCIsImNvbnRhaW5zIiwicm93Q2xhc3NuYW1lIiwicm93U2VsZWN0ZWQiLCJyb3dTZWxlY3RlZENsYXNzbmFtZSIsInJvd1NlbGVjdGVkV2l0aEZyb3plbkNlbGwiLCJ0b3BTdW1tYXJ5Um93Q2xhc3NuYW1lIiwiYm90dG9tU3VtbWFyeVJvd0NsYXNzbmFtZSIsImhlYWRlclJvdyIsImhlYWRlclJvd0NsYXNzbmFtZSIsIkhlYWRlclJvdyIsInNlbGVjdGVkQ2VsbElkeCIsImNlbGxzIiwiSGVhZGVyUm93JDEiLCJHcm91cGVkQ29sdW1uSGVhZGVyUm93IiwicmVuZGVyZWRQYXJlbnRzIiwiYWRkIiwiR3JvdXBlZENvbHVtbkhlYWRlclJvdyQxIiwiY2VsbENvcGllZCIsImNlbGxDb3BpZWRDbGFzc25hbWUiLCJjZWxsRHJhZ2dlZE92ZXIiLCJjZWxsRHJhZ2dlZE92ZXJDbGFzc25hbWUiLCJDZWxsIiwiaXNDb3BpZWQiLCJpc0RyYWdnZWRPdmVyIiwib25Db250ZXh0TWVudSIsImlzRWRpdGFibGUiLCJzZWxlY3RDZWxsV3JhcHBlciIsIm9wZW5FZGl0b3IiLCJoYW5kbGVDbGljayIsImhhbmRsZUNvbnRleHRNZW51IiwiaGFuZGxlUm93Q2hhbmdlIiwibmV3Um93IiwiQ2VsbCQxIiwiUm93IiwiY29waWVkQ2VsbElkeCIsImRyYWdnZWRPdmVyQ2VsbElkeCIsInNlbGVjdGVkQ2VsbEVkaXRvciIsIm9uQ2VsbENsaWNrIiwib25DZWxsRG91YmxlQ2xpY2siLCJvbkNlbGxDb250ZXh0TWVudSIsInJvd0NsYXNzIiwib25Nb3VzZUVudGVyIiwiaGFuZGxlRHJhZ0VudGVyIiwiUm93Q29tcG9uZW50IiwiUm93Q29tcG9uZW50JDEiLCJkZWZhdWx0UmVuZGVyUm93IiwiU2Nyb2xsVG9DZWxsIiwic2Nyb2xsVG9Qb3NpdGlvbiIsImdyaWRFbGVtZW50Iiwic2V0U2Nyb2xsVG9DZWxsUG9zaXRpb24iLCJyZW1vdmVTY3JvbGxUb0NlbGwiLCJvYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwicm9vdCIsInRocmVzaG9sZCIsImdyaWRDb2x1bW4iLCJncmlkUm93IiwiYXJyb3ciLCJhcnJvd0NsYXNzbmFtZSIsInJlbmRlclNvcnRJY29uIiwicmVuZGVyU29ydFByaW9yaXR5Iiwicm9vdENsYXNzbmFtZSIsInZpZXdwb3J0RHJhZ2dpbmciLCJ2aWV3cG9ydERyYWdnaW5nQ2xhc3NuYW1lIiwiZm9jdXNTaW5rQ2xhc3NuYW1lIiwiZm9jdXNTaW5rSGVhZGVyQW5kU3VtbWFyeUNsYXNzbmFtZSIsInN1bW1hcnlDZWxsQ2xhc3NuYW1lIiwiU3VtbWFyeUNlbGwiLCJzdW1tYXJ5Q2VsbENsYXNzIiwicmVuZGVyU3VtbWFyeUNlbGwiLCJTdW1tYXJ5Q2VsbCQxIiwic3VtbWFyeVJvdyIsInRvcFN1bW1hcnlSb3ciLCJzdW1tYXJ5Um93Q2xhc3NuYW1lIiwiU3VtbWFyeVJvdyIsImJvdHRvbSIsImlzVG9wIiwiYXJpYVJvd0luZGV4IiwiU3VtbWFyeVJvdyQxIiwiRGF0YUdyaWQiLCJyb3dLZXlHZXR0ZXIiLCJyYXdSb3dIZWlnaHQiLCJoZWFkZXJSb3dIZWlnaHQiLCJyYXdIZWFkZXJSb3dIZWlnaHQiLCJzdW1tYXJ5Um93SGVpZ2h0IiwicmF3U3VtbWFyeVJvd0hlaWdodCIsInNlbGVjdGVkUm93cyIsIm9uU2VsZWN0ZWRSb3dzQ2hhbmdlIiwib25DZWxsS2V5RG93biIsIm9uU2VsZWN0ZWRDZWxsQ2hhbmdlIiwib25TY3JvbGwiLCJvbkNvcHkiLCJvblBhc3RlIiwicmF3RW5hYmxlVmlydHVhbGl6YXRpb24iLCJyZW5kZXJlcnMiLCJyYXdEaXJlY3Rpb24iLCJyYXdSb2xlIiwiYXJpYURlc2NyaWJlZEJ5IiwicmF3QXJpYVJvd0NvdW50IiwidGVzdElkIiwiZGVmYXVsdFJlbmRlcmVycyIsInJlbmRlclJvdyIsInJlbmRlclNvcnRTdGF0dXMkMSIsInJlbmRlckNoZWNrYm94JDEiLCJub1Jvd3NGYWxsYmFjayIsInNldFNjcm9sbFRvcCIsInNldFNjcm9sbExlZnQiLCJjb3BpZWRDZWxsIiwic2V0Q29waWVkQ2VsbCIsImRyYWdnZWRPdmVyUm93SWR4Iiwic2V0T3ZlclJvd0lkeCIsInNldFNjcm9sbFRvUG9zaXRpb24iLCJncmlkSGVpZ2h0IiwiYm90dG9tU3VtbWFyeVJvd3NDb3VudCIsInN1bW1hcnlSb3dzQ291bnQiLCJoZWFkZXJBbmRUb3BTdW1tYXJ5Um93c0NvdW50IiwiZ3JvdXBlZENvbHVtbkhlYWRlclJvd3NDb3VudCIsInNldFNlbGVjdGVkUG9zaXRpb24iLCJwcmV2U2VsZWN0ZWRQb3NpdGlvbiIsImxhc3RTZWxlY3RlZFJvd0lkeCIsImZvY3VzU2lua1JlZiIsInNob3VsZEZvY3VzQ2VsbFJlZiIsImlzVHJlZUdyaWQiLCJoZWFkZXJSb3dzSGVpZ2h0Iiwic3VtbWFyeVJvd3NIZWlnaHQiLCJpc1NlbGVjdGFibGUiLCJsZWZ0S2V5IiwicmlnaHRLZXkiLCJhcmlhUm93Q291bnQiLCJkZWZhdWx0R3JpZENvbXBvbmVudHMiLCJhbGxSb3dzU2VsZWN0ZWQiLCJldmVyeSIsIm1pbkNvbElkeCIsInNlbGVjdGVkQ2VsbElzV2l0aGluU2VsZWN0aW9uQm91bmRzIiwiaXNDZWxsV2l0aGluU2VsZWN0aW9uQm91bmRzIiwic2VsZWN0ZWRDZWxsSXNXaXRoaW5WaWV3cG9ydEJvdW5kcyIsImlzQ2VsbFdpdGhpblZpZXdwb3J0Qm91bmRzIiwic2Nyb2xsSGVpZ2h0IiwiaGFuZGxlQ29sdW1uUmVzaXplTGF0ZXN0Iiwib25Db2x1bW5zUmVvcmRlckxhc3Rlc3QiLCJvblNvcnRDb2x1bW5zQ2hhbmdlTGF0ZXN0Iiwib25DZWxsQ2xpY2tMYXRlc3QiLCJvbkNlbGxEb3VibGVDbGlja0xhdGVzdCIsIm9uQ2VsbENvbnRleHRNZW51TGF0ZXN0Iiwic2VsZWN0Um93TGF0ZXN0Iiwic2VsZWN0Um93IiwiaGFuZGxlRm9ybWF0dGVyUm93Q2hhbmdlTGF0ZXN0IiwidXBkYXRlUm93Iiwic2VsZWN0Q2VsbExhdGVzdCIsInNlbGVjdEhlYWRlckNlbGxMYXRlc3QiLCJpc1NhbWVQb3NpdGlvbiIsImZvY3VzIiwicHJldmVudFNjcm9sbCIsImZvY3VzQ2VsbE9yQ2VsbENvbnRlbnQiLCJzY3JvbGxUb0NlbGwiLCJzY3JvbGxUb0lkeCIsInNjcm9sbFRvUm93SWR4IiwiaXNSb3dJZHhXaXRoaW5WaWV3cG9ydEJvdW5kcyIsIm5ld1NlbGVjdGVkUm93cyIsInJvd0tleSIsInByZXZpb3VzUm93SWR4IiwiaW5kZXhPZiIsInN0ZXAiLCJFbGVtZW50IiwiaXNDZWxsRXZlbnQiLCJpc1Jvd0V2ZW50IiwiY0tleSIsImdldFNlbGVjdGlvbiIsImlzQ29sbGFwc2VkIiwiaGFuZGxlQ29weSIsImhhbmRsZVBhc3RlIiwiaGFuZGxlQ2VsbElucHV0IiwiaGFuZGxlU2Nyb2xsIiwiY29tbWl0RWRpdG9yQ2hhbmdlcyIsInNvdXJjZUNvbHVtbktleSIsInRhcmdldENvbHVtbiIsInVwZGF0ZWRUYXJnZXRSb3ciLCJ0YXJnZXRDb2x1bW5LZXkiLCJvcmlnaW5hbFJvdyIsImlzQ29sSWR4V2l0aGluU2VsZWN0aW9uQm91bmRzIiwiaXNDZWxsV2l0aGluRWRpdEJvdW5kcyIsImVuYWJsZUVkaXRvciIsInNhbWVQb3NpdGlvbiIsImdldENlbGxUb1Njcm9sbCIsImdldE5leHRQb3NpdGlvbiIsIm5leHRSb3dZIiwibmV4dFNlbGVjdGVkQ2VsbFBvc2l0aW9uIiwiZ2V0RHJhZ2dlZE92ZXJDZWxsSWR4IiwiZWxlbWVudFRvRm9jdXMiLCJyZW5kZXJEcmFnSGFuZGxlIiwiZ2V0Q2VsbEVkaXRvciIsImdldFJvd1ZpZXdwb3J0Q29sdW1ucyIsInNlbGVjdGVkQ29sdW1uIiwic2xpY2UiLCJnZXRWaWV3cG9ydFJvd3MiLCJyb3dFbGVtZW50cyIsInNlbGVjdGVkSWR4Iiwic2VsZWN0ZWRSb3dJZHgiLCJ2aWV3cG9ydFJvd0lkeCIsImlzUm93T3V0c2lkZVZpZXdwb3J0Iiwicm93Q29sdW1ucyIsImMiLCJ0ZW1wbGF0ZVJvd3MiLCJpc0dyb3VwUm93Rm9jdXNlZCIsInNjcm9sbFBhZGRpbmdJbmxpbmVTdGFydCIsInNjcm9sbFBhZGRpbmdCbG9jayIsImRpciIsIkFycmF5IiwiZnJvbSIsIl8iLCJzdW1tYXJ5Um93SWR4IiwiaXNTdW1tYXJ5Um93U2VsZWN0ZWQiLCJncmlkRWwiLCJwMSIsInAyIiwiRGF0YUdyaWQkMSIsIkdyb3VwQ2VsbCIsImlkIiwiY2hpbGRSb3dzIiwiZ3JvdXBDb2x1bW5JbmRleCIsImlzR3JvdXBCeUNvbHVtbiIsInRvZ2dsZUdyb3VwV3JhcHBlciIsImlzTGV2ZWxNYXRjaGluZyIsImN1cnNvciIsIkdyb3VwQ2VsbCQxIiwiZ3JvdXBSb3ciLCJncm91cFJvd0NsYXNzbmFtZSIsIkdyb3VwZWRSb3ciLCJncm91cEJ5IiwiaGFuZGxlU2VsZWN0R3JvdXAiLCJzZXRTaXplIiwicG9zSW5TZXQiLCJHcm91cGVkUm93JDEiLCJUcmVlRGF0YUdyaWQiLCJyYXdSb3dzIiwicmF3Um93S2V5R2V0dGVyIiwicmF3T25DZWxsS2V5RG93biIsInJhd1NlbGVjdGVkUm93cyIsInJhd09uU2VsZWN0ZWRSb3dzQ2hhbmdlIiwicmF3R3JvdXBCeSIsInJvd0dyb3VwZXIiLCJleHBhbmRlZEdyb3VwSWRzIiwib25FeHBhbmRlZEdyb3VwSWRzQ2hhbmdlIiwicmF3UmVuZGVyUm93IiwidG9nZ2xlR3JvdXBMYXRlc3QiLCJncm91cGVkUm93cyIsInJvd3NDb3VudCIsImdyb3VwUm93cyIsImdyb3VwQnlLZXkiLCJyZW1haW5pbmdHcm91cEJ5S2V5cyIsImdyb3VwUm93c0NvdW50IiwiZ3JvdXBzIiwiY2hpbGRHcm91cHMiLCJjaGlsZFJvd3NDb3VudCIsImlzR3JvdXBSb3ciLCJhbGxHcm91cFJvd3MiLCJmbGF0dGVuZWRSb3dzIiwiZXhwYW5kR3JvdXAiLCJwYXJlbnRJZCIsImlzUmVhZG9ubHlBcnJheSIsImtleXMiLCJnZXRQYXJlbnRSb3dBbmRJbmRleCIsInBhcmVudFJvdyIsInBhcmVudFJvd0FuZEluZGV4IiwiZ3JvdXBJbmRleCIsImlzR3JvdXBSb3dTZWxlY3RlZCIsImNyIiwibmV3UmF3U2VsZWN0ZWRSb3dzIiwiaGFuZGxlUm93c0NoYW5nZSIsInVwZGF0ZWRSYXdSb3dzIiwicmF3SW5kZXhlcyIsInJhd0luZGV4IiwiZ3JvdXBJZCIsIm5ld0V4cGFuZGVkR3JvdXBJZHMiLCJyb3dQcm9wcyIsImFyciIsImlzQXJyYXkiLCJUcmVlRGF0YUdyaWQkMSIsInRleHRFZGl0b3JJbnRlcm5hbENsYXNzbmFtZSIsInRleHRFZGl0b3JDbGFzc25hbWUiLCJhdXRvRm9jdXNBbmRTZWxlY3QiLCJpbnB1dCIsInNlbGVjdCIsInRleHRFZGl0b3IiLCJvbkJsdXIiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-data-grid/lib/bundle.js\n");

/***/ })

};
;